Определения JS:
1) Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров,
посетителей и других данных. Для создания переменной в JavaScript используйте ключевое слово let.
<script>
    let message = 'Hello!'; // определяем переменную и присваиваем ей значение
    alert(message); // Hello!
</script>
В старых скриптах вы также можете найти другое ключевое слово: var вместо let:
var message = 'Hello';
Чтобы объявить константную ("константу"), то есть, неизменяемую переменную, используйте const вместо let. Названия
таких констант можно так же писать с использованием заглавных букв и подчёркивания.

2) Функция - это способ группировки команд.



Урок 33: Находим аналогию между js и php (2022-07-29)
<!--План:
php и js почти не имеют отличий-->

33.1 Отличия php и js (00:01:00)
В PHP для перехода на другую страницу по ссылке нам нужно обновить страницу, в JS этого делать не нужно. JS так же
позовляет добавлять вспылывающие окна, добавление комментариев где угодно. У JS - динамическая работа страниц.
При удалении коментария с помощью JS высвечивается окошко с просьбой подтвердить удаление, затем идет обновление
страницы и мы видем, что комментарий удалился и появилось второе окошко, которое сообщает, что комментарий удален.
После загрузки страницы в браузер пользователя вместе в html, css, картинками подгружается и js. PHP после выполнения
скрипта "умирает" /закрывается связь с сервером до следующего запроса и пользователь работает с JS без запроса к
серверу. Как в таком случае информация о выполнении JS скрипта попадает на сервер? JS параллельно с тем, что выполнил
JS скрипт, допустим нам добавил комментарий на страницу, сделал дубликат и отправил эту информацию на сервер.

Если PHP обрабатывается на стороне сервера, с помощью Апача например, то JS обрабатывается с помощью средства встроенных
в браузер (у Chrome, Firefox. IE, Safari ... у всех свой). Поэтому на этапе тестирования уже нужно проверять наши
страницы в разных броузерах, включая мобильные броузеры, чтобы быть уверенным, что пользователи увидят вашу страницу
так, как вы задумывали.

У JS нет доступа к MySQL.

33.2 Основы JS
JS работает в html. PHP тоже может работать в HTML.
Код JS содержится внутри блока: <script> </script>
Этот блок пользователь не видит, но при просмотре исходного кода (правой кнопкой мыши "Просмотр кода страницы") мы
уже видим код JS

33.3 Hello World (00:25:00)
<script>
    alert('Hello World'); //предупреждение - запуск всплывающего окна с тектом приветствия
</script>

33.4 Синтаксис JS (00:26:30)
<script>
    $x = 10;
    $y = 5;
    $result = $x - $y
    alert($result);
</script>

На самом деле в JS символ $ не нужен, так как он используется как обычный символ, поэтому скрипт правильно писать так:
<script>
    x = 10;
    y = 5;
    result = x - y
    alert(result);
</script>
Переменной может быть любой набор символов, при условии, что оно не начинается с цифры. В JS var и $var это разные
переменные.

В php для отделения переменных от строки мы ставили точки и брали строки в одинарные кавычки - конкатенация строк:
($x. '-' .$y. '=' .$result)
В JS конкатенация выполняется не точками, а знаком плюс :
<script>
    x = 10;
    y = 3;
    result = x + y // в этом случае будет не конкатенация, а сложение переменных
    alert(x+ '-' +y+ '=' +result) // получаем вывод на экран 10-3 = 7
</script>

Если две переменные является числом, то + будет подразумевать сложение, а если переменные строки, то конкатенация.
Это обязует указывание типа переменных.

33.5 Для JS обязательно указывать кодировку - utf8 (00:31:00)
При использовании другой кодировки, можем столкнуться с некоторыми проблемами. Без него вместо кирилицы будут крякозябры.

33.6 Циклы в JS (00:32:00)
33.6.1 WHILE
<script>
    //Выведем простой цикл увеличения переменной от 1 до 2
    x = 1
    while(x<3) {
        alert(x); //1 и 2
        ++x;
    }
</script>
Мы видим, что структура цикла ничем не отличается от php.
Стоит заметить, что в отличие от PHP в JS точка с запятой в конце строки не является обязательной и скрипт все равно
будет работать. В таком случае каждую логическую строку придется начинать с новой строки.

33.6.2 DO WHILE - имеет абсолютно такой же синтаксис:
<script>
    do {
        alert(x); //1 и 2
        ++x;
    } while (x<3);
</script>

33.6.3 FOR:
<script>
    for(i=1; i<10; ++i) {
        alert(i);
    }
</script>

33.6.4 FOR .. IN  - аналог цикла foreach в php и используется для вывода массивов, хотя на самом деле эта функция
выводит не массивы, а объекты

33.7 Вызов диалогового окна в JS: alert, prompt, confirm (00:37:00)
На появление диалогового окна влияет место размещения JS кода. К примеру если alert разместить до формы, то сначала
появится диалоговое окно, затем форма. Если если после формы, то наоборот. Например:

<body>
<form action="http://google.com" method="get" onSubmit="return del()">
    <input type="text">
    <input type="submit" value="Отправить в гугл">
</form>
<script>
    alert('Текст');
</script>
</body>

На видео сначала форма прогрузилась, а у меня в примере сначала прогрузился алерт!


33.7.1 alert('Произвольный текст');
<!--получим окно с текстом 'Произвольный текст' и кнопкой "ок"-->

33.7.2 prompt('Произвольный текст');
<!--Получим надпись 'Произвольный текст' + поле для ввода текста + кнопки "ок" и "отмена"-->
У prompt есть два параметра: 1) надпись сверху, 2) надпись, которая будет по умолчанию в поле ввода (не обязательный
параметр).
А куда уходят данные, которые мы вводим в всплывающее поле? Для этого мы этот вопрос приведем к переменной:
x = prompt('Сколько вам лет?', 18);
alert(x);
<!--Еще пример:-->
var answer = prompt("Вот такой вопрос.", 'Ответ по умолчанию');
alert(answer);

33.7.3 confirm('Вы точно хотите удалить комментарий?');
<!--Предлагает вопрос и два варианта "Да" и "Нет"-->
confirm - это обычная функция, которая возвращае true | false
<!--Реализация:-->
<script>
    //x = confirm('Вы точно хотите удалить комментарий?');
    if(confirm('Вы точно хотите удалить комментарий?')) {
        //удаляем код
        //alert('Вы согласились с удалением')
    } else {
        alert('Вы отказались удалять')
    }
</script>

Еще вариант:
<script>
    var res = confirm('Вы точно хотите удалить комментарий?');
    alert(res);
</script>


Везде где мы что-то удяляем желательно использовать JS и confirm, чтобы избежать случайного мисклика.
Так же confirm можно использовать, если предлагаете принять какое-то важное решение, например забанить кого-то.

33.8 Функции JS (00:47:00)
33.8.1 Разберем на примере калькулятора (синтаксис тот же, что и в php):
<script>
function calc(num1, num2, action) {
    //дефолтные параметры:
    if(action === undefined) { //если переменная не определена, то... (важно: undefined не в кавычках!)
        action = 'plus';
    }
    var res = 0; //указание, что переменная локальная
    //вычисления
    if(action == 'plus') {
        res = num1 + num2;
    } else if(action == 'minus') {
        res = num1 - num2;
    }
    return res; //возвращаем одно значение, если нужно вернуть несколько, то нужно вернуть в массиве.
}
//Вызов функции:
x = calc(1,5);
alert('Результат: ' + x); //6
x = calc(6,5, 'minus');
alert('Результат: ' + x); //1
</script>

33.8.2 Область видимости переменных: (00:52:40)
В PHP:
$x - это локальная переменная
$_SESSION, $_COOKIE, $_GLOBALS, $_FILES - суперглобальные переменные
define('X', '123') - константы

В JS:
var x - локальная <!--$ - не является обязательным символом-->
x - глобальная <!--$ - не является обязательным символом-->

Внутри функций в JS грамотно использовать локальные переменные, чтобы эти переменные небыли видны во внешней среде!!!

Глобальная переменная может быть переназначена внутри функции:
<script>
    x = 5;
    function calc(num1, num2, action) {
        x = 6; //переназначена глобальная переменная
        //остальной код
    }
    alert(x); //выведет 5, так как мы функцию еще не вызывали
    y = calc(1,5);
    alert(x); //в этом месте тот же алерт уже выведет 6, так как отработала функция и используется переназначенная
    // переменная
</script>

Если мы в функции используем глобальную переменную, то считается правильным сначала задать ее указав х = 0;
а потом уже внутри функции ее переназначить.

33.8.3 Вывод ошибок на экран в JS отсутствует, просто код не отрабатывается и все.
Как работать с ошибками, через урок будем разбираться. В старых версиях не верный код не работал, а в новых браузеры его
либо игнорируют, либо исправляют.

33.8.4 Функция ucFirst() - Переделывает первую буквы слова на заглавную:
alert(ucFirst("вася")); //
// Должно быть "Вася", но в реальности ошибка "Uncaught ReferenceError: ucFirst is not defined"

33.8.5 Функция parseInt() - приведение к типу число или округление до целого числа:
alert(parseInt('12px')); //12
В PHP мы просто пишем $x = '12px'; $x = (int)$x; //12

33.8.6 По аналогии в JS еще одна функция - parseFloat() - приведение к типу (дробное число)


Урок 34: ДОМ дерево, объекты и события(2022-07-30)
<!--План:
DOM структура HTML
Изучаем события в примерах-->

34.1 DOM («Document Object Model») структура HTML
<!--https://learn.javascript.ru/dom-nodes-->
Основой HTML-документа являются теги.
В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом.
Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.
Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.
Например, document.body – объект для тега <body>.

HTML/XML документы представлены в браузере в виде DOM-дерева.

Теги становятся узлами-элементами и формируют структуру документа.
Текст становится текстовыми узлами.
… и т.д. Всё, что записано в HTML, есть и в DOM-дереве, даже комментарии.
Для изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.

34.2. Два новых понятия: window и document (00:20:20)
window - это окно браузера (этот параметр не обязательный)

<body>
    <div id='xx' style="background-color:yellow">text</div>
</body>
DOM дерево:
body.div.text

document – «входная точка» в DOM.
Если у div есть свой идентификатор 'id', то можно сразу обращаться к этой папке через 'id'. Для этого используем:
<script>
    document.getElementById('xx')// где 'xx' - это id блока div
</script>
Это можно сравнить с функцией, в которую подставился блок div. Мы можем идти глубже и обращаться к его свойствам,
к его атрибутам ('id', 'style'). Мы можем ссылаться на какие-нибудь внутренние элементы внутри него (text) или
ссылаться на его свойства или методы.

Мы можем docunent переназначить переменной:
x = document.getElementById('xx');
Это удобно для того, чтобы каждый раз не писать всю строчку, а работать уже с переменной. Далее обращаясь к переменной
х мы будем уже работать с данным элементом или его частичкой.
<script>
    x = document.getElementById('xx').innerHTML;// теперь мы ссылаемся на text внутри div
    alert(x); // выведет 'text'
</script>


34.3 Get и Set (00:27:40)
<script>
    x = 5; // это set, так как мы устанавливаем значение переменной равной 5
    alert(x);// это get, так как мы получаем переменную
</script>

<script>
    x = document.getElementById('xx').innerHTML;//это GET, так как мы принимаем данные из html
    document.getElementById('xx').innerHTML = 'Какой-то текст'; //Это Set, так как мы переобозначаем
</script>
В результате в div текст 'text' заменится на 'Какой-то текст'.
<script>
    alert(1);//на фоне всплывающего окна увидим 'text'
    document.getElementById('xx').innerHTML = 'Какой-то текст'; //Это Set, так как мы переобозначаем
    alert(1);//на фоне всплывающего окна увидим 'Какой-то текст'
</script>

34.4 Смена стиля в JS (00:30:40)
34.4.1 Смена фона
По аналогии со сменой текста через innerHTML можно обратиться к свойству блока style и через точку выбрать доступные
стили css:
<script>
    alert(1);//на фоне всплывающего окна увидим 'text' на желтом фоне
    document.getElementById('xx').innerHTML = 'Какой-то текст'; //Это Set, так как мы переобозначаем
    alert(1);//на фоне всплывающего окна увидим 'Какой-то текст' на желтом фоне
    document.getElementById('xx').style.backgroundColor = 'red'; //замена фона на красный цвет
    alert(1);//на фоне всплывающего окна увидим 'Какой-то текст' на красном фоне
</script>
Нужно запомнить, что если в css мы пишем 'background-color', то в JS 'backgroundColor' (верблюжий стиль)

34.4.2 style.display(00:33:00):
<script>
    document.getElementById('xx').style.display = 'none'; // скрываем блок
    alert(1);
    document.getElementById('xx').style.display = 'block'; // включаем отображение блока
    document.getElementById('xx').style.display = ''; // включаем отображение блока, пустое значение возвращает
    // к дефолтным настройкам
</script>
С помощью этого параметра можно обращаться к скрытым формам или блокам, например на форуме при клике на ячейку
сообщения появляется форма/блок "Скрыть 1 сообщение", админская функция.


34.5 Изучаем события в примерах (00:42:00)
JS должен срабатывать не на открытие страницы, а на определенные действия пользователя. При нажатии на какую-то галочку,
кнопку, наведении мыши -  происходит событие.
У html тегов есть атрибуты, универсальные атрибуты и события

34.5.1 Универсальные атрибуты  <!--http://htmlbook.ru/html/attr/common-->
Универсальные атрибуты применяются практически ко всем тегам, поэтому выделены в отдельную группу, чтобы не повторять
их для всех тегов.
1) accesskey - Позволяет получить доступ к элементу с помощью заданного сочетания клавиш.
2) class - Определяет имя класса, которое позволяет связать тег со стилевым оформлением.
3) contenteditable - Сообщает, что элемент доступен для редактирования пользователем.
4) contextmenu - Устанавливает контекстное меню для элемента.
5) dir - Задает направление и отображение текста — слева направо или справа налево.
6) hidden - Скрывает содержимое элемента от просмотра.
7) id - Указывает имя стилевого идентификатора.
8) lang - Браузер использует значение параметра для правильного отображения некоторых национальных символов.
9) spellcheck - Указывает браузеру проверять или нет правописание и грамматику в тексте.
10) style - Применяется для определения стиля элемента с помощью правил CSS.
11) tabindex - Устанавливает порядок получения фокуса при переходе между элементами с помощью клавиши Tab.
12) title - Описывает содержимое элемента в виде всплывающей подсказки.
13) xml:lang - Этот атрибут по своему действию похож на lang, но применяется только в XHTML-документах и указывает
язык всего текста или его фрагмента.


34.5.2 События: <!--http://htmlbook.ru/html/attr/event-->
События выполняются так:
<script>
    событие="скрипт"
</script>

<textarea>
1. onblur - Потеря фокуса.
Событие возникает при потере элемента фокуса. Это обычно происходит, если щелкнуть на другой элемент текущего документа.
Событие onblur противоположно по своему действию событию onfocus.

2. onchange - Изменение значения элемента формы.
Событие возникает при изменении значения элемента формы, вроде текстового поля или списка. Например, событие onchange
добавленное к тегу <textarea> срабатывает каждый раз, когда введен новый текст и поле потеряло фокус.

3. onclick - Щелчок левой кнопкой мыши на элементе.
Событие onclick возникает при щелчке левой кнопкой мыши на элементе, к которому добавлен атрибут onclick.

4. ondblclick - Двойной щелчок левой кнопкой мыши на элементе.
Событие ondblclick возникает при двойном щелчке левой кнопкой мыши на элементе.

5. onfocus - Получение фокуса
Событие onfocus возникает при получении элементом фокуса. Например, для текстового поля фокусом называется возможность
вводить текст. Событие onfocus по своему действию противоположно onblur.

6. onkeydown - Клавиша нажата, но не отпущена.
Событие onkeydown cрабатывает в момент нажатия клавиши, но когда она еще не отпущена.

7. onkeypress - Клавиша нажата и отпущена.
Событие onkeypress срабатывает, когда клавиша на клавиатуре нажата и отпущена, что эквивалентно совместному действию
onkeydown и onkeyup.

8. onkeyup - Клавиша отпущена.
Событие onkeyup возникает в момент отпускания нажатой клавиши.

9. onload - Документ загружен.
Событие onload используется как указатель, что веб-страница полностью загружена, включая содержание, изображения,
стилевые файлы и внешние скрипты.

10. onmousedown - Нажата левая кнопка мыши.
Событие onmousedown по своему действию похоже на onclick и отличается от него тем, что срабатывает в момент нажатия
на кнопку мыши. onclick же в каком-то смысле является комбинацией событий onmousedown и onmouseup.

11. onmousemove - Перемещение курсора мыши.
Событие onmousemove используется для определения перемещения курсора мыши в любом направлении экрана. Это событие
применяется для создания различных эффектов, связанных с курсором мыши: всплывающие подсказки, перетаскивание объектов
и др.

12. onmouseout - Курсор покидает элемент.
Событие onmouseout срабатывает, когда курсор мыши выходит за пределы элемента, к которому добавляется параметр
onmouseout. Это событие обычно работает в связке с параметром onmouseover.

13. onmouseover - Курсор наводится на элемент.
Событие onmouseover срабатывает, когда курсор мыши наводится на элемент, к которому добавлен атрибут onmouseover.
Это один из самых популярных атрибутов, применяемый для создания различных эффектов с изображениями и другими
объектами веб-страницы. Обычно работает в связке с событием onmouseout.

14. onmouseup - Левая кнопка мыши отпущена.
Событие onmouseup по своему действию противоположно событию onmousedown и происходит при отпускании кнопки мыши,
пока курсор находится в пределах элемента, к которому добавлен атрибут onmouseup.
onmouseup="скрипт"

15. onreset - Форма очищена.
Событие onreset возникает при очистке формы, происходящей при нажатии на кнопку Reset. Такая кнопка не обязательна
и может отсутствовать в форме, а при ее использовании данные формы возвращаются в свое исходное значение.

16. onselect - Выделен текст в поле формы.
Событие onselect применяется в текстовых полях формы и включается при выделении текста с помощью мыши или клавиатуры.

17. onsubmit - Форма отправлена.
Событие onsubmit возникает при отправке формы, это обычно происходит, когда пользователь нажимает специальную
кнопку Submit.

18. onunload - Закрытие окна.
Событие onunload срабатывает в том случае, когда страница не загрузилась по каким-либо причинам, либо при закрытии
окна (вкладки) браузера.
</textarea>

34.6 Примеры событий:
Создаем блок:
<body>
    <div id='xx' style="background-color:yellow">text</div>
    <div style="font-size:16px;">НАЖМИ НА МЕНЯ</div>
</body>

Попробуем использовать событие onclick:
<div style="font-size:16px;" onclick="alert('Вау!!!')">НАЖМИ НА МЕНЯ</div>
можно так же усложнить:
<div style="font-size:16px;" onclick="document.getElementById('xx').innerHTML = 'Hello'; document.getElementById('xx').style.display = 'none';">НАЖМИ НА МЕНЯ</div>
В этом скрипте на нажатии мышкой на блок div происходит выполненение двух кодов:
1) выполняется замена текста на Hello
2) скрытие блока.
Стоит учесть, что в событиях можно ставить пробел, но нельзя делать перенос строки! Несколько скриптов внутри события
отделяются друг от друга точной с запятой.
Такие длинные надписи читать не удобно, поэтому мы сделаем функцию, как на php:
<body>
    <div id='xx' style="background-color:yellow; display:block">text</div> <!--добавили видимость блока по умолчанию-->
    <div style="font-size:16px;" onclick="hideShow()">НАЖМИ НА МЕНЯ</div>
</body>

<script>
    function hideShow() {
        if(document.getElementById('xx').style.display == 'block') {
            document.getElementById('xx').style.display = 'none';
        } else {
            document.getElementById('xx').style.display = 'block';
        }
    }
</script>
Получился скрипт, который развертывает или скрывает блок. Можно то же делать с меню.

Можно функцию сократить, поместив части скрипта в объект (назначить переменную):
<script>
    function hideShow() {
        var x = document.getElementById('xx');
        if(x.style.display == 'block') {
            x.style.display = 'none';
        } else {
            x.style.display = 'block';
        }
    }
</script>

34.7 Консоль ошибок. (01:06:00)
Для просмотра ошибок JS нужно перейти в консоль ошибок (Ctrl+Shift+J)
Об отладке поговорим позже в других уроках.

34.8 Размещение скриптов.
Скрипты лучше размещать в отдельном файле, если нет возможности, то в <head></head>
Для того чтобы с начала загрузилось все DOM дерево, а потом уже JS используется 'onload':
<script>
    window.onload = function (){
        alert(document.getElementById('xx').innerHTML);
    }
</script>

34.9 Второй вариант - работа JS через 'id' (01:11:20)
Если в первом варианте работы JS мы использовали скрипты в тегах html, то во втором варианте работу JS выносим отдельно.
С помощью синтаксиса ... = function (){... мы можем избавиться от написания прямо в div событий, в нашем примере onclick:
<body>
    <div style="font-size:16px;" id="keeeey">НАЖМИ НА МЕНЯ</div><!-- удалили onclick="hideShow()", но добавили 'id' -->
    <div id='xx' style="background-color:yellow; display:none">куку</div>
</body>
Теперь мы можем ссылаться на этот идентификатор:
<script>
    window.onload = function (){
        //назначаем id 'keeeey' событие с безымянной функцией:
        document.getElementById('keeeey').onclick = function () {
            //переносим скрипт из функции hideShow() сюда:
            var x = document.getElementById('xx');
            if(x.style.display == 'block') {
                x.style.display = 'none';
            } else {
                x.style.display = 'block';
            }
        }
    }
</script>

34.10 Третий вариант - совмещенние двух предыдущих.
Для этого используем нашу ранее написанную функцию hideShow():
<script>
    window.onload = function (){
        document.getElementById('keeeey').onclick = hideShow();
    }
</script>
В разработке используеются все три варианта. Первый вариант onclock в тегах очень полезен, когда мы не можем создать
определенное событие для каких-то данных, которые подгружаются именно динамически, с помощью AJAX подгружаем новый
элемент блоков, новые кнопки, на которые необходимо будет повесить отдельные события.

34.11 Развитие функции hideShow():
Можно доделать нашу функцию, чтобы она скрывала/отображала блоки с определенным идентификатором:
<body>
    <div id='yyy' style="background-color:yellow; display:block">text</div> <!--скрываем показываем этот блок-->
    <div style="font-size:16px;" onclick="hideShow(yyy)">НАЖМИ НА МЕНЯ</div>
</body>

<script>
    function hideShow(id) {
        var x = document.getElementById(id);
        if(x.style.display == 'block') {
            x.style.display = 'none';
        } else {
            x.style.display = 'block';
        }
    }
</script>
Можно создавать много еще блоков div, но чтобы они работали независимо нужно каждому присваивать отдельный идентификатор.

34.12 Запрет срабатывания стандартных атрибутов тегов html (01:22:00)
Пример:
<a href="http://google.com" onclick="alert(1)">google</a>
В этом случае сначала сработает JS в виде всплывающего окна с цифрой 1, а только потом уже переход по ссылке происходит.
Для того, чтобы данные встроенные теги не срабатывали мы добавляем "возврат с ошибкой":
<a href="http://google.com" onclick="alert(1); return false">google</a>
после этого переадресации уже не будет. Если исправить на "return true", то переадресация произойдет.
Таким образом мы можем перехватывать какие-то события и делать операции по работе с объектами.

34.13 Функция проверки длинны запроса
Где можно использовать "return false"? Можно при работе с формой на примере проверки длинны запроса:
<form action="http://google.com" method="get" onsubmit="return lenthCheck()">
    <input type="text" id="key" value="">
    <input type="submit" value="Отправить">
</form>
<script>
    function lenthCheck() {
        var l = document.getElementById('key').value.length; // проверка количество символов в запросе
        if(l < 5) {
            alert('Вы не заполнили поле, минимум 5 символов! Вы ввели только'+l);
            return false; //запрос поиска не выполнится
        }
    }
</script>
Такой вывод ошибки можно сделать и в php, но без всплывающего окна и с перезагрузкой страницы.

34.14 Функция удаления по ссылке (01:29:00)
Мы ранее обсуждали, что при удалении необходимо спрсить подтверждение
<a onclick="return areYouSureDel()">Удалить статью</a>
<script>
    function areYouSureDel() {
        var x = confirm('Вы уверены, что хотите удалить?');
        if(!x) {//пользователь отказался
            return false; //удаление не произойдет.
        }
    }
</script>
В дальнейшем при любом удалении в админке использовать эту функцию


Урок 35: script в отдельном файле, консоль, setInterval и setTimeout (2022-08-01)
<!--План:
Отдельные файлы js
Кеш файлов
console
setInterval
setTimeout-->

35.1 Отдельные файлы js (00:01:45)
В корне хранить JS скрипты в общем-то не правильно. Они занимают много места + проблемы с кешированием.
Для ускорения загрузки страниц скрипты помещаются в отдельный файл, у нас в проекте в папке js создаем script_v1.js

Файлы JS подгружаются на страницу путем добавления в шапку head записи:
<script type="text/javascript" src="/skins/default/js/script.js"></script>

35.2 Кеш файлов
При первом посещении сайта произойдет загрузка такого скрипта в кеш браузера и вызываться от туда по мере необходимости
будут вызываться разные функции. При следующем переходе на этот сайт будет совершен запрос на сервер и если скрипт на
сервере и в кеше совпадают, то скрипт не будет загружаться повторно. Стили CSS так же подгружаются единоразово и затем
берутся из кеша браузера (кроме случаев разработки, когда приходится отключать кеширование стилей, чтобы тестировать
разные новые стили). HTML и изображения подгружают каждый раз заново.

Для подгрузки в кеш браузера измененного скрипта нужно нажать CTRl+R и CTRL+F5, если не помогло - повторить.
В Chrome можно зайти в консоль (правой кнопкой мыши), вкладка сеть, правой кнопкой по списку файлов выбрать "Очистить
кеш браузера", затем F5.

Первый вариант донести изменения скрипта до пользователя - изменение имени скрипта, script_v2.js или script_v1_1.js,
затем путь к этому файлу меняем так же в шапке html.

Второй вариант - передача версии через get параметр:
<script type="text/javascript" src="/skins/default/js/script.js?1"></script>
Название файла script_v1.js не меняется и потому можно вообще все время называть script.js, а изменяется только GET.
После внесения изменений в скрипт мы изменяем строку, а именно цифру версии:
<script type="text/javascript" src="/skins/default/js/script.js?2"></script>

Есть еще и другие способы хранения версий, например SVN (Subversion), но мы его пока рассматривать не будем.

35.3 Взаимодействие с PHP (00:31:25)
Разберемся как передавать какие-то данные из PHP в JS
<?php
    $x = 'Hello World';
?>
<script>
    var x = '<?php echo $x; ?>' //'Hello World'
</script>

PHP нормально обрабатывается в файлах формата php, html, tpl, но не будет обрабатываться в файлах формата js.
Если скрипт находится в отдельном файле script.js, то никакие php переменные он наследовать не будет. Поэтому
стандартная практика - переменные мы создаем в корне

В нашем проекте для того, чтобы подгрузить JS на страницу activate.php вверху пишем надпись:
<?php
Core::$JS[] = '<script type="text/javascript" src="/skins/default/js/script.js?2"></script>';
?>
Скрипты подключаем только на тех страницах, где есть необходимость в этом скрипте. Затем в коде html вызываем скрипт
и по необходимости меняем параметры функций из JS скрипта и устанавливаем связи с php.


35.4 console.log (00:43:00)
Вывод сообщений для разработчика в консоль (по правой кнопке мыши), при этом пользователь этой надписи не видит.
<script>
    console.log('Скрипт подгрузился!'); //перейдя в консоль браузера мы увидим эту надпись.
</script>
console.log используется для отладки JS. С помощью него мы можем в каком-то участке кода поместить в него в скобки
каку-то переменную и проследить, что выводится. Можно проверять результат математических операций:
<script>
    var x = 0.1;
    var y = 0.4;
    var z = x + y;
    console.log(z); //перейдя в консоль браузера мы увидим эту надпись.
</script>

35.5 Рассмотрим еще две новые функции: setInterval и setTimeout (00:48:30)
35.5.1 setInterval - позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
Если часто отправлять запросы мы можем "завалить сайт", так как сервер не будет успевать обрабатывать запросы.
<script>
    i = 1;
    while (i == 1) {
        console.log('lalala'); //произойдет бесконечная отправка 'lalala'
    }
</script>
Завалить сайт может скрипт, как в примере выше, поэтому можно ограничить по периодам отправку запросов в console.log
<script>
    function test() {
        console.log('lalala');
    }
    var intervalId = setInterval("test()", 2000);// каждые 2 секунды отправляет в консоль текст 'lalala'
</script>

35.5.2 clearinterval - эта функция очищает интервал:
<script>
    x = 0;
    function test() {
        ++x;
        console.log('lalala' + x);
        if (x == 5) {
            clearinterval (intervalId);//очистка интервала по достижении lalala5 - остановка скрипта.
        }
    }
    var intervalId = setInterval(test, 2000);// каждые 2 секунды отправляет в консоль текст 'lalala'
</script>
Функция используется очень редко, но все же знать о ней нужно.

35.5.3 Особенности вызова функции в JS: (00:58:25)
Вызвать функцию test() вписав в нее аргументы test('arg1', 'arg2') считается не правильным, так как в разных браузерах
может работать, а может не работать. Правильно для вызова функции и передачи ей аргументов нужно использовать
безимянную функцию и внутри ее написать что мы вызываем:.
<script>
    var intervalId = setInterval(function() {test('arg1', 'arg2');}, 2000);
</script>
Так можно использовать сразу несколько функций (для наглядности оформим с переносом строк):
<script>
    var intervalId = setInterval(function() {
        test('arg1', 'arg2');
        hideShow('id');
        }, 2000);
</script>

35.5.4 setTimeout - позволяет вызвать функцию один раз через определённый интервал времени.
<script>
    var intervalId = setTimeout(test, 2000); //вызовем функцию через 2 сек и только один раз.
</script>


Урок 36: Объекты наше всё. Аналогия ассоциативных массивов на PHP
<!--План:
Изучаем объекты и их синтаксис-->

36.1 Закрепим прошлый материал
JS скрипт если стоит до блока, к которому он обращается, не может сработать и вызовет ошибку. Для вызова блока div из
скрипта, который располагается до блока нужно использовать onload (мы это уже ранее рассматривали):
<script>
    window.onload = function () {
        var intervalId = setInterval(hide, 2000);
        //var intervalId = setInterval(show, 2000); второй setInterval нельзя вызывать
    }
</script>
Нельзя в одной функции использовать 2 setInterval, так как они будут сбиваться и начнуть "ускоряться", поэтому
использовать можно только один.

Для использования двух функций можно написать такую функцию - каждый второй вызов будет использовать функцию show():
<script>
    function hide() {
        $i = 0;
        if(++$i%2 == 0) { //$i%2 - означает, что $i кратно 2, то есть получаем остаток от деления и сравниваем его с 0.
            show();
        }
    }
</script>

36.2 Массивы в php (00:09:00):
<?php
$array = array(1,2,3);
//Для вызова цифры 2 из массива нужно указать ключ этой цифры:
$array[1];
?>
Существуют ассоциативные массивы, с ними гораздо удобнее работать, в них мы используем не какие-то цифровые ключи,
а ассоциации в словах:
<?php
$country = array (
    'Ukraine' => array('Киев', 'Днепр', 'Донецк'),
    'Poland' => array('Варшава', 'Вроцлав', 'Люблин')
);
$users = array (
  'user1' => array(
        'Имя' => 'Стас',
        'Nick' => 'inpost',
        'Age' => '26',
    ),
    'user2' => array(
        'Имя' => 'Михаил',
        'Nick' => 'Myrzz',
        'Age' => '13',
    ),
);
echo $users['user1']['Nick'];
echo $users['user2']['Age'];
?>
Этот массив чем-то напоминает базу данных.

Если в массиве вместо слов в ключах только цифры, то такой массив называется индексным:
<?php
$users = array (
    '0' => array(
        '0' => 'Стас',
        '1' => 'inpost',
        '2' => '26',
    ),
);
?>

36.3 Массивы в JS (00:15:00):
Индесный принцип построения массивов присутствует в JS, а ассоциативный - отсутствует. Ассоциативный принцип перебрался
в объект и работа с ним такая же простая, как если бы мы работали с php.
<script>
var users = { //фигурная скобка говорит, что мы создаем объект
    'key' : 'value',
    'key2' : 'value2'
}
alert(users['key']);
</script>

В php к ассоциативному массиву обратиться так: $users['Nick'];
В php к свойствам объекта можно обратиться так: $users->Nick;

В JS к свойствам объекта можно обратиться двумя способами:
1) alert(users['key']);
2) alert(users.key);

В JS объекты это теже массивы из php, только по другому называются. Как и в большинстве языков программирования -
отличия только в названиях.

Создадим многомертный массив / объекст:
<script>
    var users = { //фигурная скобка говорит, что мы создаем объект
        'user1' : {
            'Имя' : 'Александр',
            'Nick' : 'Пистолетов',
            'age' : '32',
            'skilllevel' : '100500'
        },
        'key2' : 'value2'
    };
    console.log('Пользователь: ' + users.user1.Nick + users['user1']['age']);//совместили два способа
</script>

Вывод на экран содержимого объекта циклом:
<script>
    var users = { //фигурная скобка говорит, что мы создаем объект
        'user1' : {
            'Имя' : 'Александр',
            'Nick' : 'Пистолетов',
            'age' : '32',
            'skilllevel' : '100500'
        },
        'key2' : 'value2'
    };

    for(key in users.user1) {
        console.log(users.user1[key])
    }
    //console.log('Пользователь: ' + users.user1.Nick + users['user1']['age']);//совместили два способа
</script>
Выведет:
Александр
Пистолетов
32
100500

Многомерный объект -расширим:
<script>
    var users = { //фигурная скобка говорит, что мы создаем объект
        'user1' : {
            'Имя' : 'Александр',
            'Nick' : 'Пистолетов',
            'age' : '32',
            'skilllevel' : '100500'
        },
        'user2' : {
            'Имя' : 'Степан',
            'Nick' : 'Мих',
            'age' : '25',
            'skilllevel' : '101'
        },
        'user3' : {
            'Имя' : 'Петро',
            'Nick' : 'Байрактаров',
            'age' : '69',
            'skilllevel' : '100500500'
        },
    };

    for(key in users) {
        //console.log(users[key])//выведет полную инвормацию по всем пользователям
        console.log(users[key].Nick + ':' + users[key].age + ',' + users[key].skilllevel)
    }
</script>
Мы вывели ник, возраст и скилллвл. Именно так в чатах и используется - кто написал, дата написания, текст.
Вместо 'user1' в объексте коментариев №комментария.
Новые данные добавляются, а дальше выводятся через известный нам innerHTML

36.4 Домашняя работа: (00:31:00)
Пробуем сделать модальное окно для блока авторизации на главной странице. Если сил много - пробуем проверку этого поля
сделать на уровне JS. Вспоминаем, как у формы работает onsubmit="return func();", где false остановит отправку формы
в случае, если поля не верно заполнены. Хватит даже простой проверки на длину поля.

<form onsubmit="return check();"></form>
