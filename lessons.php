<?php
// PHP с нуля - 1 урок - Основы языка и синтаксиса
1-1
/*
* Если нам нужно, чтобы часть кода ниже команды перестала обрабатываться, то мы прописываем следующее:
* <?php exit; ?>
*/
1-2
/*
* echo 'Hello World';
* echo - значит вывести на экран, 'это то что мы хотим вывести на экран', а ';' - это значит мы закончили команду.
*/
1-3
/*
 * Правило №1 текст выводится в кавычках '', а цифры без кавычек.
 * Если цифры часть текста, то тоже в кавычках.
 * 		echo '<b>Hello World</b>';
 *		echo  321;
 */
1-4
/*
 * Математические операции пишем в скобках:
 * echo (1+1);
 */
1-5
/*
 * Можно в начале кода прописать переменные, а потом где-то в середине им пользоваться, например:
 * <?php $num=7;
 * $text = 'Hello World'
 <?php echo $text?>
*/
1-6
/*
 * Правило програмирования №2:
 * PHP выполняется сверху вниз, слева на право!
 * Например: echo $text3; $text3 = 'Vasya'; - не правильно!
 * Правильно: $text3 = 'Vasya'; echo $text3;
 */
1-7
/*
 * Правило №3 РНР код всегда выполняется с нуля, с нулевой строчки кода!
 * То есть если у клиента открылась страница, код считался, то он и будет отображаться
 * а если часть кода скрыть, то при повторном запросе /обновлении страницы  - выдаст ошибку по этому коду!
 */
1-8
/*
 * РНР код можно сократить - вместо: <?php echo $title; ?>
 * можно записать: <?=$title;?> - это короткая запись по выводу команды
 */


// PHP с нуля - 2 урок - работа сервера, переменные, типы данных
// Урок 2: Углубляемся в типы данных и переменные

2-1
/*
 *После запроса от сервера к пользователю приходит только HTML, а РНР выполняется на стороне сервера и отправлояет
 * сгенерированный HTML! Всего кода, что мы пишем на РНР - в браузере клиента его нет.
 * РНР - это серверный язык программирования, потому что он выполняется на сервере, где лежит сайт.
 */


2-2 // Чтобы положить информацию в файл пишем:
file_put_contents('1.txt', $text);
// достаем информацию из файла так:
$text = file_get_contents(filename:'1.txt');
echo $text;
//Но можно еще сократить вывод, одной строчкой:
echo file_get_contents('1.txt');


2-3 //Если два раза написать переменную, но каждый раз с разными значениями, то на экран пользователя выведется последння
 	$text = 'Hello World';
	$text ='Zimbabve'; //заменит значение переменной
//Но если перед знак присвоения поставить точку в последней пееременной, то выведутся оба текста вместе, например:
 	$text = 'Hello World';
	$text.=' Zimbabve'; //объединяется

//Следующий вариант - треться строчка затрет две предыдущие:
 	$text = 'Hello World';
	$text.=' Zimbabve';
	$text='Vasyan'; // выведется на экран только новое значение переменной - Vasyan

2-4 //Если у нас в HTML встречаются несколько переменных с одинаковым названием, то можно использовуать константы, например
$text = 'Вступительный урок'; /*эта запись не нужна теперь - для ознаколмления написана*/
define('TEXT', 'Вступительный урок'); /*define - константа, ТЕХТ большими буквами*/
/* <h1><?=TEXT; ?></h1>
 * помещаем константу в HTML
 * Константой мы утверждаем настройки, котрые не будем менять в коде.
 */

2-5 // Типы переменных:
$text = 'Произвольный текст'; // string - строка, текст
$num = 10; // int, integer - целые числа
$float = 1.2; //float - дробные, с плавающей запятой
$bool = true; // bool, boolean (true или false)

$result = $text + $num; //выдаст ошибку, так как разные типы переменных складывать нельзя!
echo $result;
$result = $text.$num.$float //не выдаст ошибку, так как с точкой не складывает, а склеивает все подряд в одно слово
echo $result; //Произвольный текст101.2
$result = $text.' '.$num.' '.$float // тоже не выдаст ошибку + поставит между значениями переменных пробелы
echo $result; //Произвольный текст 10 1.2

//Пример:
$num1 = 10;
$num2 = 15;
$calc_result = $num1 + $num2; // или $calcResult - тоже самое "Верблюжий стиль"
var_dump($calc_result); //вывод на экран результатов - int(25)

$calc_result = $num1 / $num2; // тоже , только с делением
var_dump($calc_result); // float(0.6666666666666666) -число с плавающей запятой

//Приведение к типам - пример:
$num1 = (string) $num1; // вместо числа задаем новую переменную - строка
var_dump($num1); // получим string(2) "10" - число превратили в текст, в скобках указано количество знаков, байт

$num1 = (bool) $num1; // еще вариант
var_dump($num1); // bool(true) - правда все кроме нуля, даже с минусом правда (true)

/*
 * Допускаются следующие приведения типов:
(int), (integer) - приведение к int - целые числа
(bool), (boolean) - приведение к bool - логический
(float), (double), (real) - приведение к float - дробные числа
(string) - приведение к string - строка
(array) - приведение к array - множество, массив
(object) - приведение к object - объект
(unset) - приведение к NULL  — удаляет переменную
 */


// PHP с нуля - 3 урок - Управляющие конструкции и операторы сравнения
// Урок 3: Управляющие конструкции и операторы сравнения

3-1
/*
 * условия:
 * == равенство по значению - не путайте = и == в коде! В операторах сравнения не существует одного равно,
 * это обычное присвоение переменной значения. А значение присваивается ВСЕГДА. И это распространённая ошибка,
 * новички путают = и ==.
 * === равенство по значению и ТИПУ
 * != не равно
 * !== не равенство по значению или типу
 * < меньше
 * > больше
 * <= меньше или равно
 * >= больше или равно
 */
// Управляющие конструкции - if, elseif, else. Своимм словами:
// if (или так), elseif (или тоже так, но с другми условиями), else (или по другому совсем)
//Расмотрим на примере корзины добавления товара в интернет магазине: первый вариант:
$cart_count = 0;
if ($cart_count >0) { // если больше нуля
	echo 'В корзине '.$cart_count.' товаров';
	}
else { //если нет
	echo 'Нет товаров в корзине';
}

//второй вариант - меняем местами строчки:
$cart_count = '3';
if ($cart_count ==0) { // если да?
	echo 'Нет товаров в корзине';
}
else { //если нет
	echo 'В корзине '.$cart_count.' товаров';
}
 //третий вариант - с текстом:
$cart_count = 'Пиво';
if ($cart_count == 0) { // строка при переводе в число - превращается в ноль,
	// как вариант можно записать так: if ((int)$cart_count == 0)
	//ответ при == будет да, если  === то нет
	echo 'Да';
}
else { //если нет
	echo 'Нет';
}

// для уменьшения кода можно писать иногда без else :
$is_buy = 1;
if ($is_buy === (3-2)) // можно так же записать в виде:
	//if (true)
	echo 'Yes';

3-2
//Разбор вариантов с окончанием слов в корзине
//0 рублей
//1 рубль
//2 рубля
//первый вариант:
$rub = 2;
if ($rub === 0) {
	echo $rub.' рублей';
} else {
	if ($rub === 1) {
		echo $rub.' рубль';
	} else {
		echo $rub.' рубля';
	}
}
//второй вариант - с использованием elseif - пишем когда нужен дополнительный вариант условия if:
$rub = 3;
if ($rub === 0) {
	echo $rub.' рублей';
} elseif ($rub === 1) {
	echo $rub.' рубль';
} elseif ($rub === 2) {
	echo $rub.' рубля';
} else {
	echo $rub. ' рубл...';
}
/*
 * в этих схемах if - обазательно
 * elseif и else - не обязательно
 */

//Разберем на примере авторизации на сайте:
$login = 'inpost';
$pass = 'test';
if($login == 'inpost') {
	echo 'Логин совпал'; //условие верно
	} elseif($pass == 'test') {
	echo 'пароль совпал'; // условие верно
} else {
	echo 'Ни логин ни пароль не совпали'; // условие не верно
}

//второй вариант: тоже только на оборот, со знаком не равенства:
$login = 'inpost';
$pass = 'test';
if($login != 'inpost') {
	echo 'Логин не совпал'; //условие не верно
} elseif($pass != 'test') {
	echo 'пароль не совпал'; // условие не верно
} else {
	echo 'Логин и пароль совпали'; // условие не верно
}
// третий вариант:
$login = 'inpost';
$pass = 'test';
if($login == 'inpost') {
	if($pass == 'test') {
		echo 'Вы авторизированы';
	}
	else {
		echo 'Пароль введен не верно';
	}
} else {
	echo 'Логин введен не верно';
}

3-3
//Сравнение цифровых значений:
$num1 = 10;
$num2 = 5;
if($num1 != $num2) {
	echo 'не равно';
}

3-4
// Правило №4: работаем переменными из-вне только тогда, когда они существуют.

3-5 // isset — Определяет, была ли установлена переменная значением, отличным от null
//Определяет, была ли установлена переменная значением отличным от null.
//Если переменная была удалена с помощью unset(), то она больше не считается установленной.
$x = 1;
$y = 2;

if (isset($z)) { //переменная isset проверяет есть ли переменная и только если она есть, то выполняется этот блок
	echo 'Переменная существует';
} else {
	echo 'Переменная не существует';
}

3-6 /*Работаем с формой в PHP:
разберем на примере авторизации на сайте: */?>
<form action="" method="post" class="content">
	<input name="login" placeholder="Введите логин"><br>
	<input name="password" placeholder="Введите пароль"><br>
	<input type="submit" value="Отправить">
</form>

<?php
//$_POST['login'];
//$_POST[['password'];
if(isset($_POST['login'], $_POST['password'])) {
	echo 'Форма была отправлена<br>';
}
//первый вариант:
if ($_POST['login'] == 'inpost') { // логин мы задаем заранее
	if($_POST['password'] == '123') { // пароль мы задаем заранее
		echo 'Вы ввели логин и пароль правильно, вы авторизированы<br>';
	}
}
//второй вариант - сокращаем два условия через && - обозначает "и":
if ($_POST['login'] == 'inpost' && $_POST['password'] == '123') {
	echo 'Вы ввели логин и пароль правильно<br>';
}

//третий вариант через || - обозначает "или":
if ($_POST['login'] == 'inpost' || $_POST['password'] == '123') {
	echo 'Вы ввели логин или пароль правильно<br>';
}

// четвертый вариант, когда достпен 1 вариант логина и два варианта пароля "123" или "234":
if ($_POST['login'] == 'inpost' && ($_POST['password'] == '123' || $_POST['password'] == '234')) {
	echo 'Вы ввели логин и пароль правильно<br>';
}
/* Эти блоки потом можно вставить в шапку сайта перед <a><Авторизация/a> и заменить на приветствие "Здравствуйте inpost"
 * Если логин и пароль верны, то пользователя по привествует, если нет, то перейдет к ссылке/кнопке "Авторизация"
 */

3-7
// Правило №5 Мы не используем exit на сайте, кроме как ОТЛАДКА КОДА;

3-8
//Функция empty -
$x = 1; //0 или пустая строчка - это false, 1, любой текст и далее true
if(empty($x)) {
	echo 'Переменная НЕ СУЩЕСТВУЕТ или она ПУСТАЯ';
}
if(!empty($x)) { // ! перед функцией означает, что будет выпоняться обратная функция
	echo 'Переменная и существует и она НЕ пустая';
}

3-9
//PHP supports the following data types: / PHP поддерживает следующие типы данных:
//String - строка
//Integer - Целое число
//Float (floating point numbers - also called double) - числа с плавающей запятой, также называемые двойными
//Boolean - логический
//Array - Множество / массивы
//Object - Объект
//NULL - нулевой
//Resource - ресурс

/*
 * Строка — это последовательность символов, например «Hello world!».
Строка может быть любым текстом в кавычках. Вы можете использовать одинарные или двойные кавычки
 */

/*
 * Целочисленный тип данных — это недесятичное число от -2 147 483 648 до 2 147 483 647.
Правила для целых чисел:
Целое число должно иметь хотя бы одну цифру
Целое число не должно иметь десятичной точки
Целое число может быть как положительным, так и отрицательным
Целые числа могут быть указаны в: десятичной (по основанию 10), шестнадцатеричной (по основанию 16), восьмеричной
(по основанию 8) или двоичной (по основанию 2) нотации.
 */

/*
 * Float - Поплавок (число с плавающей запятой) — это число с десятичной точкой или число в экспоненциальной форме.
 */

/*
 * Булево значение PHP
Логическое значение представляет два возможных состояния: TRUE или FALSE. Логические значения часто используются
в условном тестировании.
 */
/*
 * PHP-массив
Массив хранит несколько значений в одной переменной.
 */

/*
 * PHP-объект
Классы и объекты — два основных аспекта объектно-ориентированного программирования.
Класс — это шаблон для объектов, а объект — это экземпляр класса.
Когда создаются отдельные объекты, они наследуют все свойства и поведение класса, но каждый объект будет иметь
разные значения свойств.
Предположим, у нас есть класс Car. Автомобиль может иметь такие свойства, как модель, цвет и т. д. Мы можем определить
такие переменные, как $model, $color и т. д., чтобы хранить значения этих свойств.
При создании отдельных объектов (Volvo, BMW, Toyota и т. д.) они наследуют все свойства и поведение класса, но каждый
объект будет иметь разные значения свойств.
Если вы создадите функцию __construct(), PHP будет автоматически вызывать эту функцию при создании объекта из класса.
 */

/*
 * НУЛЕВОЕ значение PHP
Null — это особый тип данных, который может иметь только одно значение: NULL.
Переменная типа данных NULL — это переменная, которой не присвоено значение.
Совет: Если переменная создается без значения, ей автоматически присваивается значение NULL.
Переменные также можно очистить, установив значение NULL
 */

//Урок 4: Массивы
/*План:
*Массивы
*Элементы массива
*CRUD массивов и элементов массива
 *
 * Словарь:
 * Массивы (array) - тип данных, позволяющий группировать переменные.
 * Элемент массива (element) - одна переменная в массиве
 * Ключ (key) - имя элемента массива (имя переменной, по аналогии)
 * Индексный ключ (index) - порядковый номер (int)
 * Ассоциативный ключ (assoc) - текстовое имя (string)
 * Значение (value) - содержание элемента массива
 */

4-1
//МАССИВ
//СОСТАВ МАССИВА: КЛЮЧ => ЗНАЧЕНИЕ, (при этом ЗНАЧЕНИЕ обязательно, а КЛЮЧ НЕТ)
// переменная => значение
//разберем на примере массива - оценки учеников:
{
	$vasya = 5; //ключ = значение (key = value)
	$petya = 4;
	$nastya = 2;
}
// каждая переменная (ключ) в массиве называется: элемент массива
//пишем этот же пример на php:
$users = [
	'vasya' => 5, //переменные выделяем '_' вместо $,так же используем запятую в конце строки, вместо точки с запятой
	'petya' => 4,
	'nastya' => 2,
];
echo '<pre>'; //задаем для красивого вывода - в столбик
//var_dump($users); - выводим данные на экран раньше мы так учили, но это функция отладки, пока отключим
// для вывода на экран лучше использовать print_r
print_r($users); // так и вид лучше

//массив в массиве пример:
$elements = [
	'russia' => [
		'Saint peterbuerg',
		'Moscow',
	],
	'Ukraine' => [
		'Kiev',
		'Sumy',
		'Hlukhiv',
	]
];
echo '<pre>'; // это сейчас пишем, чтобы посмотреть как будет выглядеть при разработке
print_r($elements); //а в реальном коде уже не используем

4-2 //Как дополнить массив?
$country = [
	'Russia',
	'Ukraine',
];
$country[] = 'Israel'; // вот так дополняем массив
// еще пример - наш массив с оценками в школе:
$users = [
	'vasya' => 5,
	'petya' => 4,
	'nastya' => 2,
];
// 1) можем добавить ученика:
$users ['dima'] = 4;
print_r($users); // на экране мы уже увидим [dima] => 4 внутри массива с остальными.
// 2) можем перезаписать данные:
$users ['nastya'] = 3; // Так как 'nastya' уже есть в массиве, то 2 перезапишется на 3
// 3) можем всем поднять на один бал оценки:
++$users['nastya']; // так только Насте
// чтобы поднять всем оценки - нужно использовать циклы (будем изучать в следующем уроке)

//Числовой массив [не задается] называется - индексный.
//А когда ключ имеет [имя] - ассоциативный.

4-3 //чтобы удалить переменную используется следеющая команда (пишется после массива):
unset($elements);

//чтобы удалить определенную строчку с массива пишем:
unset($users ['vasya']); // удаляем имя 'vasya' из массива
unset($country [1]); // или порядковый номер записи (отсчет начинается с нуля)

4-4 // вывод переменной:
echo ($users ['petya'] * $users ['nastya']); // Петя 4 * Настя  2 получим вывод на экран "10"

//вывод из вложенных массивов:
echo $elements ['russia'][1]; //выведется 'Moscow'

// еще один вариант через временный файл?
$tmp = 'russia';
echo $elements [$tmp][1];

4-5 // implode — Объединение массивов в строку:
$country = [
	'Russia',
	'Ukraine',
	'Israel',
];
$countries = implode (  ', ', $country); //implode — Объединяет элементы массива в строку
/*добавляем в html полученную переменную:
* <p> Мы работаем со странами: <?=$countries;?>.</p>
* на экран выдаст текст "Мы работаем со странами: Russia, Ukraine, Israel."*/


4-6 // explode — Разбивает строку с помощью разделителя:
$tags = 'php mysql array variable';
$tags_array = explode(' ', $tags); //преобразовываем набор слов в массив
echo '<pre>';
print_r($tags_array); // выдает на экран массивом эти данные
?>
<?php
Урок 9: Начинаем изучать PHP
/*План:
Как устроен сервер
Переменные
Математические действия
Вывод переменных
Операторы и управляющие конструкции*/

9.1 /*Трассировка пути к сайту:
запуск/виконати/відкрити пишем:*/
tracert phpforum.ru
//так через просомтр пинга можно увидеть где на каком компе в цепочке есть задержка
//Решение с проблемными серверами в пути - прокси-сервер - обход проблемного сервера
//Об этом нужно сообщеть админам и хостинг провайдер заменяет путь

9.2
//server-side: PHP, Mysql
//client-side: HTML, JS

9.3 //Операторы сравнения: if, else

// 10-й урок Урок 10: Практикуемся с версткой

10-1
// новая функция: switch
/*
 * Оператор switch похож на ряд операторов IF с одинаковым условием. Во многих случаях вам может понадобиться сравнивать
* одну и ту же переменную (или выражение) с множеством различных значений и выполнять различные участки кода в
* зависимости от того, какое значение принимает эта переменная (или выражение). Это именно тот случай, для которого
* удобен оператор switch.
 */
switch($path) {
	case 'main': //условия
		//сюда прописываем действия (echo или любое другое)
		break;
	case 'payment': //условия
		break; //действия
	default: // - пишем, если ниодно действие не совпало
		$page = 'main';
}
//сокращенный вариант:
switch($page) {
	case 'main': case 'payment': //условия
		//сюда прописываем действия (echo или любое другое)
		break;
	default: // - пишем, если ниодно действие не совпало
		$page = 'main';
}

// пишем такую же конструкцию через if:
if($page == 'main') {
	//действия
} elseif($page == 'payment') {
	//действия
} else { // - пишем, если ниодно действие не совпало
	$page = 'main';
}
// эту конструкцию тоже можем сократить:
if($page == 'main' || $page == 'payment') {
	//действия
} else { // - пишем, если ниодно действие не совпало
	$page = 'main';
}
// расшифровка: если переменная $page не является 'main' или 'payment', то мы ее сделаем 'main'

10-2
// include - эта функция включает и выполняет указанный файл (указывает какой файл нужно запустить и какие
// переменные оттуда вытянуть или может все содержимое страницы подгрузить с того файла в наш)
vars.php // отсюда берем информацию
<?php
$color = 'зелёное';
$fruit = 'яблоко';
?>

test.php
<?php
echo "Одно $color $fruit"; // Одно
include 'vars.php'; // сюда подключаем
echo "Одно $color $fruit"; // Одно зелёное яблоко
?>

<?php
// 11-й урок массивы и циклы

11-1 // Массивы
$country = array();
$country [] = 'Chaos name 1';
$country [] = 'Chaos name 2';
$country [] = 'Chaos name 3';
$country [] = 'Chaos name 4';

echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран
unset($country[2]); // удаляем из массива 2 строчку
// (отсчет идет с 0, поэтому реально это 3-я строчка 'Chaos name 3)
echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран, предыдущая информация не стирается
$country [] = 'Chaos name 5'; // добавляем новую строчку
echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран, предыдущая информация не стирается
// как видим новая строчка не заняла место 2-й удаленной, а стала 4-й. Каждая новая, не учитывает удаленные,
// а присваивает номера дальше

//Вывод из массива данных на экран:
$var = 'Произвольный текст';
$array = array (
	'key'=>'value',
	'key2'=>'value2',
	'key3'=>'value3',
	'names'=>array('Вася', 'Петя', 'Илона', 'Даша'),
);
echo '<pre>'.print_r($array,1).'</pre>'; // это команда для просмотра структуры массива
echo $array['names'][1]; // На экран вывелся 'Петя'
//кроме print_r есть еще одна функция: var_damp - она отличается от предыдущей тем, что указывает
// дополнительно типы данных и (длину строки) - более профессиональный, но менее удобный.
echo '<pre>';
var_dump($array);
echo '</pre>';

11-2 /* Циклы
 1. while
 3. do-while
 3. for
 4. foreach (для массивов)
 */

11-2-1 //Какой цикл быстрее и почему?
while //- перебирает блок кода до тех пор, пока заданное условие истинно. Циклический просмотр блока кода до тех пор,
// пока выполняется заданное условие. Для этого лучше while.
	//Все эти циклы используют мало ресурсов, поэтому мы не замети проблему с ними.
do...while //- проходит через блок кода один раз, а затем повторяет цикл до тех пор, пока заданное условие истинно
for // - перебирает блок кода указанное количество раз. Используется для счетчика, сделать какое-то определенное
// количество раз определенное действие. Для данного случая будет быстрее for.
foreach //- перебирает блок кода для каждого элемента массива. Используется для обхода массива! Он быстрее всего
// обходит массив.


11-2-2 /* Сравнение циклов через решение одной и той же задачи:
	Условие - нужно вывести на экран следующее:
	The number is: 1
	The number is: 2
	The number is: 3
	The number is: 4
	The number is: 5 */

//с помощью while:
$x = 1;
while($x <= 5) {
	echo "The number is: $x <br>";
	$x++;
}

// с помощью do... while:
$x = 1;
do {
	echo "The number is: $x <br>";
	$x++;
} while ($x <= 5);

//с помощью for:
for ($x = 1; $x <= 5; $x++) {
	echo "The number is: $x <br>";
}

//с помощью foreach:
$numbers = array("The number is: 1", "The number is: 2", "The number is: 3",
	"The number is: 4", "The number is: 5");
foreach ($numbers as $x) {
	echo "$x <br>";
}
//верхний пример foreach можно написать через функцию:
function num($numbers = array("1", "2", "3", "4", "5")) {
	foreach ($numbers as $x) {
		echo "The number is: $x<br>";
	}
}
num ();

11-2-3a // while - принцип написания похож на if
//Если нужно производить выполнение операторов цикла в PHP скрипте только при выполнении определённого условия,
// то в PHP используется цикл while
//Синтаксис цикла while в PHP
while(условие)
{
	Операторы цикла через ;
     }
//  "=" - это не равно, а базовый оператор присвоения, устанавливает значение
//"==" - это уже равно, "===" - тождественно равно (переменные равны и имеют тот же тип)
$x = 1;
echo $x.'Текст до цикла<br>'; // выведется: '1Текст до цикла'
while($x == 1 || $x == 2 || $x == 3) {
	echo 'Произвольный текст';
	$x = $x + 1; // увеличиваем переменную на 1 вплоть до 4
	//можно так же сократить это же выражение:
	// ++$x;
	echo $x.'<br>'; // выведется: 'Произвольный текст2', и так далее до 'Произвольный текст4'
}
echo 'Текст после цикла'.$x; // выведется последняя строчка: Текст после цикла4

//Операторы инкремента и декремента
//++$a	Префиксный инкремент	Увеличивает $a на единицу, затем возвращает значение $a.
//$a++	Постфиксный инкремент	Возвращает значение $a, затем увеличивает $a на единицу.
//--$a	Префиксный декремент	Уменьшает $a на единицу, затем возвращает значение $a.
//$a--	Постфиксный декремент	Возвращает значение $a, затем уменьшает $a на единицу.


//второй вариант:
$x = 1;
echo 'Текст до цикла<br>';
while($x < 10) {
	echo $x.'Произвольный текст<br>'; // выведется 9 раз
	++$x;
} echo 'Текст после цикла'.$x;

// тот же второй вариант, только уже в html в виде таблицы:
$x = 1;
echo '<table border=1"><br>';
while($x < 10) {
	echo '<td>';
	echo $x.') Произвольный текст<br>'; // выведется 9 раз
	++$x;
} echo '</td>';


//Использование цикла while более корректно для поиска корней уравнения, потому что мы изначально не знаем, в каком
// диапазоне находится корень, а использование цикла for предполагает, что мы это знаем.
//Пример скрипта на PHP с использованием цикла while. Скрипт ищет решение уравнения x²-20x+100=0
    $y = 100;
    $i = 0;
    while($y != 0) {
		$i = $i + 1;
		$y = $i * $i - 20 * $i + 100;
	}
   echo "Решение уравнения {$i}"; //Решение уравнения 10

// Рассмотрим дальше на примере одной и той же таблицы, на html и с помощью циклов:
/* тут два ряда в таблице, в каждом из которых 3 ячейки
 	<table border="1" cellpadding="5">
		<tr>
			<td>1:1</td>
			<td>1:2</td>
			<td>1:3</td>
		</tr>
		<tr>
			<td>2:1</td>
			<td>2:2</td>
			<td>2:3</td>
		</tr>
	</table>
 */

// второй вариант той же таблицы:
$i = 1; // указывает с какого числа начинается отсчет
echo '
	<table border="1" cellpadding="5">
	<tr>';
while($i <= 3) { // повторяем ячейки 3 раза
	echo '<td>1:'.$i.'</td>'; // содержимое ячейки
	++$i; // увеличение переменной i на единицу
}
	echo '</tr>
		<tr>
			<td>2:1</td>
			<td>2:2</td>
			<td>2:3</td>
		</tr>
	</table>';

//третий вариант - мы так же можем использовать циклы в циклах:
// тут выводим на экран счет от 1 до 9 три раза с указанием порядкового номера цикла:
$i = 1; //начальные условия
$x = 1; //начальные условия
while($i <=3) { // количество циклов
	while($x < 10) { // цикл вывода цифр от 1 до 9
		echo $x; // вывод на экран цифры
		++$x; // следующее добавление +1 вплоть до 9
	}
	echo $i;
	++$i; // после прохождения цикла повышает $i на единицу: $i = 2
	$x = 1; // а $x сбрасывается до единицы: $x = 1, после чего цикл повторяется
	// пока не получим $i = 3, после чего цикл дойдет до конца и завершится
}
// вот что в итоге выведется на экран: 123456789112345678921234567893 (где 1,2,3 после 1-9 это $i)

//Пример ошибочного цикла:
$x = 10;
while($x < 10) {
	echo $x;
} // тут по результату ничего не ведет на экран, так как $x = 10 и не может быть < 10

11-2-3b // DO WHILE - аналогична while, только отличие, что в начале у нас в обязательном
// порядке первая интерация цикла, то есть первый вывод будет работать.
echo 'Перед циклом<br>';
$x = 1;
do { // do - что делать?
	echo $x.'<br>'; // выводится
	++$x;
} while ($x < 10); // обратить внимание мы местами поменяли действия с условием
echo 'После цикла';
//мы тут делаем определенное действие, пока выполняется условие
//первая проверка цикла проходит теперь не в начале цикла, как было при while,
//а после первого выполнения, то есть первая часть do выполнится всегда, даже если условие
// не удовлетворяет
1:23:40 / 1:57:27

11-2-3c //FOR
echo 'Перед циклом';
for($x = 1; $x <10; ++$x) {
	echo $x.'<br>';
}
echo 'После цикла';

// цикл в цикле
echo 'Перед циклом'; // приблизительно так нужно будет сделать домашку.
for($x = 1; $x <= 5; ++$x) {
	for($y = 1; $y <= 10; ++$y) {
		echo $x.':'.$y.'<br>';
	}
}
echo 'После цикла';

11-2-3d //FOREACH - используется для перебора массивов
$names = array('', 'Вася', 'Петя', 'Илона', 'Даша'); // наш исходный массив
echo '<pre>'.print_r($names,1).'</pre>'; // просмотр исходного массива, в коде не нужно писать - это для себя
//$k - ключ (сокращение от key), $v - значение переменной (сокращенное от value)
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo 'Квартира = '.$k.', Владелец = '.$v.'<br>';
}

//второй вариант (массив тот же):
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $v.', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//третий вариант (меняем только способ вывода, но резельтат будет как в варианте два):
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $names[$k].', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//Четвертый вариант - самый короткий без создания ключей (результат аналогичный второму):
echo 'В нашем доме живут: <br>';
foreach($names as $v) { // ключ в этом способе не создаем, только значение передаем, зато быстрее так обрабатывается
	echo $v.', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//Пятый вариант - перебор массива (ключ и значение задаем прямо в массиве):
$names = array('Name1'=>'Вася', 'Name2'=>'Петя', 'Name3'=>'Илона', 'Name4'=>'Даша'); // Name - ключ, Вася - значение
echo '<pre>'.print_r($names,1).'</pre>'; // просмотр исходного массива, в коде не нужно писать - это для себя
//$k - ключ, $v - значение переменной
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $k.'=  '.$v.'</br>';
} //получим:
//В нашем доме живут:
//Name1= Вася
//Name2= Петя
//Name3= Илона
//Name4= Даша

11-2-4 // У всех четырех циклов есть специальные функции: break и continue;
// break - обрывает цикл;
$names = array('Вася', 'Петя', 'Илона', 'Даша');
echo '<pre>'.print_r($names,1).'</pre>';
foreach($names as $k=>$v) {
	if ($v == 'Илона') { // если цикл дошел в массиве до "Илона", то
		break; // то цикл останавливается
	} echo $v.', '; // на экран выведется только "Вася, Петя,"
}

// continue - заканчивает данную итерацию цикла;
$names = array('Вася', 'Петя', 'Илона', 'Даша');
echo '<pre>'.print_r($names,1).'</pre>';
foreach($names as $k=>$v) {
	if ($v == 'Илона') { // если цикл дошел в массиве до "Илона", то
		continue; // то цикл оборвется и "Илона" не выведется
	} echo $v.', '; // на экран выведется только "Вася, Петя, Даша,"
}


 Урок 12: //Домен и хостинг
//Хостинг
//Домен
//DNS
//Сайт hostinger.ru
//FTP-клиент Far
//FTP-клиент FileZilla
//Настройки сервера: phpinfo() - функция для просмотра версии php, программ, IP и прочего на сервере.
// Через этот сайт можно получить уязвимости сайта, поэтому после проверки удаляем со страницы


Урок 13: //Пользовательские функции
/*PHP имеет более 1000 встроенных функций, кроме того, вы можете создавать свои собственные пользовательские функции.
Функция — это блок операторов, который можно многократно использовать в программе.
Функция не будет выполняться автоматически при загрузке страницы.
Функция будет выполнена вызовом функции.*/

13-1 //Считаем количество элементов в массиве:
// допустим нам в одном коде нужно посчитать количество жильцов и стран в массивах, похожие действия
$array = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис',
);
$count = 0; // создание переменной, откуда начинается счетчик
//Подсчеты - счетчик жильцов
foreach($array as $v) {
	++$count; //count — Подсчитывает количество элементов массива
}
//вывод
echo 'В нашем доме живут ('.$count.') ';

foreach($array as $v) { //вывод массива на экран + добавление счетчика жльцов
	echo $v.', ';
} // получим на экране: "В нашем доме живут (5) Петя, Ульяна, Даша, Маша, Денис,"

//считаем количество стран в массиве:
$country = array(
	'Украина', 'Польша', 'Франция',
);
$count = 0;
foreach($country as $v) {
	++$count;
} echo 'Стран в массиве= ('.$count.') ';

/* Бывают коды очень большой длинны 1000+ строк и в нем может быть некоторый участок кода,
 * который будет повторяться в некоторых местах как в примере выше - подсчет жильцов и стран
 * в этом случае на помощь приходит функция. Они аналогичны с изученными инклюдами:
 * include 'text.php' - подставляем участок кода в определенный файл
 */
//Функция count:
$count = count ($array);
$count = count ($country);

//Еще одна особенность - нам не обязательно результат помещать в какую-то переменную, мы можем вызвать
//функцию прямо внутри кода:
$array = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
echo 'В нашем доме живут ('.count($array).'):';
foreach($array as $v) {
	echo $v.', ';
} // получим вывод: "В нашем доме живут (6):Петя, Ульяна, Даша, Маша, Денис, Степан,"


13-2 //Вызов (запуск) функции:
//Запомнить: страница php - это программа, а функция - это подпрограмма
//func (); - у разных функций свои названия
//Создание функции:
function count2 () { // называем count2, так как count уже было, а повторять нельзя
	// тут пишем тот код, который должна выполнять функция
	echo 'Произвольный текст из функции<br>';
} //дальше мы эту функцию вызываем:
echo 'Текст до функции<br>';
count2(); // подставится "Произвольный текст из функции"
count2(); // подставится "Произвольный текст из функции"
count2(); // подставится "Произвольный текст из функции"
echo 'Текст после функции';

/* у функции есть некоторые особености - переменные, котрые мы создаем за пределами функции - не существует внутрии функции
 * если перед function count2 строчкой выше прописать $var1 = 'text'; то эта переменная никак не повлияет на функцию.
 * с другой стороны если переменную новую разместить внутри функции, то она не будет выполняться вне функции
 * разберем на примере предыдущей функции:
 */
$var1 = 'text1';
function count2 () {
	//echo $var1; //ошибка
	$var2 = 'text2 ';
	echo $var2;
	echo 'Произвольный текст из функции<br>';
}
//echo $var2; //ошибка
echo 'Текст до функции<br>';
count2(); // подставится "text2 Произвольный текст из функции"
count2(); //
count2(); //
echo 'Текст после функции';
/*
 * Фцнкции полностью независимы. Хоть они и находятся в одном месте, все равно они друг друга не видят.
 * Функция должна быть независимой и всегда работать так как надо. Переменные с однаковым названием (если так получилось)
 * выполняются отдельно и не зависят друг от друга. Переменные внутри функции не видны за пределами функции. И те
 * что за пределами функции не видны внутри функции.
 */


13-3 //как передать переменную из-вне функции внутрь функции? Рассмотрим на примере $var1, для этого размещаем ее
// внутри круглых скобок (в коментах очередность действий выполнения):
$var1 = 'Степан'; // 1-е - задаем переменную
function count2 ($t1, $t2, $t3) { // 3-е отправляем на выполнение функции уже не $var1, а значение переменной $t1
	echo $t1.'<br>'.$t2.'<br>'.$t3.'<br>'; //4-е действие - выводим на экран
}
echo 'Текст до функции<br>';
count2($var1, 'Пантера', 2022, 2023); // 2-е переносим в этот код ($var1) кроме того прописываем новые, не извне
//count2(); // тут пришлось закоментить, потому что выдает ошибку
echo 'Текст после функции';
//2023 не выведется, так как в функции function count2 не введено переменную $t4 и в эхо ее тоже нет.
//если в функции убрать $t3 - выдаст ошибку, так как в функции передавать больше значений можно, меньше нельзя.


13-4  // разбираем что еще можно делать с функцией:
function hard ($num1, $num2) { //в круглых скобках передается аргумет функции. Вы можете добавить столько аргументов,
	// сколько хотите, просто разделите их запятой. Аргумент подобен переменной.
	$sum = ($num1*5+$num2*10)/2 - 1;
	$sum = 'Результаты подсчетов: '.$sum;
	echo $sum;
}
//затем в произвольном месте, не обязательно рядом, можно даже через 100-200 строк, потом вызываем нашу функцию:
hard(5,3);
// и смотрим результат: "Результаты подсчетов: 26.5" - расчет произведен.


13-5 // Улучшаем эту же функцию добавбляя новые условия выполнения через IF и ELSE:
function hard ($num1, $num2) {
	$sum = ($num1*5+$num2*10)/2 - 1;
	if ($sum <20) {
		$sum = 'Результаты подсчетов: '.$sum;
		echo $sum;
	} else {
		echo 'Слишком большое число у переменной (результат больше 20)';
	}
}
hard(1,3);
echo '<br>';
hard(30,40);


13-6 //О выводе на экран:
/*
 * Принято так, что функция не должна содержать вывод на экран, то есть echo не должно быть в функциях
 * Функции должны получать какие-то данные и возвращать какие-то данные. А заходим ли мы вывести какие-то
 * данные на экран мы должны уже сами решать.
 * Теперь как это происходит - напишем эту же функцию, только без вывода информации на экран:
 */
function hard ($num1, $num2) {
	$sum = ($num1*6+$num2*10)/2 - 1;
	if ($sum <20) {
		$sum = 'Результаты подсчетов: '.$sum;
		return $sum; // меняем echo на return
	} else {
		return 'Слишком большое число у переменной (результат больше 20)'; // меняем echo на return
	}
}
$temp = hard(1,1); // Результаты подсчетов: 7
echo $temp;


13-7 // сами пишем функцию, которая должна считать:
$names = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
function count2 ($names) {
	$count = 0; // теперь мы должны переменную $count посчитать
	foreach($names as $v) { // между ")" и "{" нельзя ставить ";" - сейчас поставил и потом искал пол часа ошибку!
		++$count;
	}
	return $count; // 6
}
echo count2 ($names); //6


13-8 // Обычно это все выводится проще, благодаря встроенным функциям:
$names = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
$count = count ($names);
echo 'итого '.$count.' имён'; // echo "итого .$count. имён"  - так тоже можно писать
// "итого 6 имён"


13-9 // разберем более сложные функции на примере задания из домашки (создать таблицу и окрасить ячейки в разные цвета):
function makeTable ($x,$y) { //здесь можно проставить цифры, но все равно если мы внизц в "echo makeTable (5,3);"
	// зададим другие цифры, то приоритет к исполнению функции отдастся цифрам из "echo makeTable (5,3);"
	$text = '';
	$text .= '<table>';
	for($i=1; $i<=$y; ++$i) {
		$text .='<tr>';
		for($i2=1; $i2<=$x; ++$i2) {
			$color = 'white'; // цвет всех ячеек
			if($i == 2 && $i2 == 3) {
				$color = 'red'; // ячейка 2:3 будет красная
			} elseif ($i == 2 && $i2 == 4) {
				$color = 'green'; // ячейка 2:4 будет зеленая
			} elseif ($i == 3) {
				$color = 'blue'; // третья строка будет синяя
			}
			$text .= '<td style="background-color:'.$color.';">'.$i.':'.$i2.'</td>';
		}
		$text .='</tr>';
	}
	$text .= '</table>';
	return $text; // return работает по аналогии с break - завершает выполнение текущей функции
	//return может возвращать только одну переменную!!! Если записать две через запятую, то выдаст ошибку.
	// но есть лазейка - можно вернуть несколько - массивом.
}
echo makeTable (5,3); // задаем количество столбцов и строк


13-10// Функция count
//count — Подсчитывает количество элементов массива или Countable объекте
count(Countable|array $value, int $mode = COUNT_NORMAL): int
//Подсчитывает все элементы в массиве, если используется массив. Если используется объект, который реализует
//интерфейс Countable, функция возвращает результат выполнения метода Countable::count().


13-11 //Функция preg_match
//preg_match — Выполняет проверку на соответствие регулярному выражению
preg_match(
    string $pattern,
    string $subject,
    array &$matches = null,
    int $flags = 0,
    int $offset = 0
): int|false
// Ищет в заданном тексте subject совпадения с шаблоном pattern.

13-12 // Функция по регистрации пользователя и проверки условий (это не регистрация, а просто пример функции):
function addToDB ($login, $password) {
	// Процедура добавления пользователя в общую Базу Данных
}
function reg ($login, $password) {
	if ($login == 'Vasya') { // Если логин 'inpost' совпадет с логином в базе 'Vasya', то
		return false; //в регистрации отказано
	}
	addToDB ($login, $password);
		return true; // регистрация прошла, добавили в базу
}
if (reg('Vasya', '123')) {
	echo 'Вы успешно зарегистрировались, поздравляем!';
} else {
	echo 'Такой логин уже есть в базе данных, вы не зарегистрировались!';
}


13-13-1 //Функция по вызову текста:
function textMake ($text) {
	$text = 'Разные '.$text.' и буквы'; // эта строчка привязывает переменную извне функции к функции
	return $text;
}
$text = 'слова'; // этот блок с переменными можно разместить и перед функциями, разницы нет
$text = textMake($text); // вызов переменной текст - тут можно в левой части вместо $text можно заменить на другую переменную
echo $text; // вывод переменной текст на экран
// вывод на экран: "Разные слова и буквы"

13-13-2 //Предыдущую же функцию можно сократить благодаря значку и: "&" перед переменой в функции - "склеивание переменных":
function textMake (&$text) {
	$text = 'Разные '.$text.' и буквы'; // убрали "	return $text;"
}
$text = 'слова';
textMake($text); // убрали переменную в левой части строки
echo $text;

13-14 /* Домашнее задание:
 * Сделать калькулятор. 3 входящих параметра:
 1. Первое число, 2. Второе число, 3. Действие (плюс, минус, умножить, поделить).
 * По примеру: function calc($num1,$num2,$action)
  * 4. Если $action не задан, то по умолчанию должно складывать переменные.
 */

 14 // Урок 14: Методы передачи данных GET и POST, работа с формами

 14-1 /* Формы - это блочные элементы, наподобие div, внутри которіх содержатся формы. Форм может быть несколько
на странице (пример: поле авторизации и поле регистрации). Формы сами по себе независимые.
*Атрибуты, которые есть у нас в форме:
1) action - указание файла, для отработки, этот атрибут указывать нужно всегда. Этот файл создаем заранее. Если мы
 хотим сделать отправку и обработку страницы на одной странице, а это лучший вариант для одностраничного сайта, то нам
 достаточно поле названия файла оставить пустым:
<form action="">
2) method - метод отправки переменных $_POST или $_GET: method="post" или method="get".
 $_POST и $_GET - это суперглобальные переменные, которые приходят из формы. Данные переменные
 пишутся таким синтаксисом.
 GET и POST - это наши два массива. Изначально они созданы пустыми. Это тожде самое, что если бы мы писали
 $_GET = array(); - так создаются пустые массивы
 Если мы передаем данные методом GET и POST, то эти массивы наполняются.
3) intime -
	*/

	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
	?>

<form action="" method="get">
	GET	<input type="text" name="login"> <!--слово GET перед input отображает название поля ввода-->
	<input type="text" name="password">
	<input type="submit" name="submit" value="submit">
</form>
<!--можно сделать вообще две формы для каждого массива отдельно:-->
<form action="" method="post">
	POST	<input type="text" name="login"> <!--слово POST перед input отображает название поля ввода-->
	<input type="text" name="password">
	<input type="submit" name="submit" value="submit">
</form>

<?php
/* после этого на экран выведется:
GET:
Array
(
    [login] => roman.nik
    [password] => 1321
    [submit] => submit
)
POST:
Array
(
    [login] => inpost
    [password] => 3231321
    [submit] => submit
)/
Напомню, что [login] и [password] - это ключ переменной, а inpost и 3231321 - это уже значение переменной
*/

14-2  // Разберем еще пример - авторизация на сайте:
echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
?>

<form action="" method="post">
	<input type="hidden" name="hide" value="скрытое значение">
	<div>Заполните логин:<input type="text" name="login"></div>
	<div>Заполните пароль:<input type="password" name="pass"></div>
	<div style="padding:15px">
		Пол: <br> <!--тег <label> используется для придания интерактивности тексту - можно включить кнопку нажатием
		 на текст "Мужчина"	так же label работает и с checlbox-->
		<label>Мужчина <input type="radio" name="gender" value="Мужчина"></label> |
		<!--в радио мы используем одинаковый тип и имя-->
		<label>Женщина <input type="radio" name="gender" value="Женщина"></label>
		<!--здесь value - это то что выведется текст в массив-->
	</div>
	<div style="padding:15px">
		Любимый напиток: <br> <!--так же label работает и с checkbox-->
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
		<!--в отличие от радио в чекбоксе при отправке данных выведется только последняя отмеченная запись.
		Чтобы этого избежать необходимо задать разные имена name (like 1, like2, ...) или записать в массив like []-
		создастся новый массив внутри массива $_POST
		Передачу данных в мссив возможна и в остальных местах, но в чекбоксе они обязательны-->
	</div>
	<div><input type="submit" name="submit" value="Отправить данные" style="border-style:hidden; border-radius:10px;
	background-color:#90ff90"></div>
</form>
<!--type ="button" в формах не используется, в основном в через JS делается.
тип = hidden - используется для указания кому отпарвляем остальные вводимые поля
name - это наш ключ переменной.
value - содержание значения данного поля
после каждой отправки данных страница перегружается и наново записываются данные в массив $_POST-->

<?php
14-3 //сокращенная форма работы с суперглобальной переменной и записью в массив:
echo '<p>Ваш логин: '.@$_POST['login'].'</p>'; // @ - этот значек убирает сообщения об ошибках.
?>
<form action="" method="post">
	<div>Заполните логин:<input type="text" name="login"></div>
	<div>Заполните пароль:<input type="password" name="pass"></div>
	<div><input type="submit" name="submit" value="Отправить данные"></div>
</form>

<?php
14-4 // Сокращенная форма для checkbox
echo '<p> Мы любим: '; //здесь как в примере 14-3 не получится одной строчкой сделать
foreach($_POST['like'] as $v) { // придется использовать foreach
	echo $v.','; // указываем выводить через запятую: "Мы любим: Чай,Молоко,"
}
/* освещим память - эту же функцию можно было бы написать и на основе того, что уже раньше учили:
$like = ''; // пустые ковычки - это пустота
foreach($_POST['like'] as $v) { // foreach используем для наполнения $like
	$like .=$v.','; // ".=" это мы переменную дописываем
}
echo '<p>Мы любим: '.$like.'</p>';
 */
?>
<form action="" method="post">
	<div style="padding:15px">
		Любимый напиток: <br>
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
	</div>
	<div><input type="submit" name="submit" value="Отправить данные"></div>
</form>

<?php
14-5 // Для проверки была ли отправлена информация после нажатия на кнопку в примере 14-2 на экран выводилось:
//"[submit] => Отправить данные"
// можно так же проконролировать отправку с помощью  функции isset:
	if(isset($_POST['submit'])) {
		echo 'Форма отправлена';
	}
// проверяем передались ли конкретніе данные, чтобы мы с ними работали

14-6 // Проверка для checkbox через isset:
if(isset($_POST['submit'])) {
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';

	$like = '';
	if(isset($_POST['like'])) {
		foreach($_POST['like'] as $v) {
			$like .= $v.',';
		}
		echo '<p>Мы любим: '.$like.'</p>';
	}
}

14-7 // Чтобы защитить от взломов сайты нужна проверка авторизации с базой
if(isset($_POST['login'], $_POST['pass'])) { // эта часть не даст войти без заполнения форм
		//в связи с этим блок ниже не будет выполняться
	echo $_POST['login'];
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
}
14-8 /*Безопасность: любая ошибка - это потенциальная угроза взлома. Хакеры используют ошибки для взлома.
 Никогда нельзя доверять входящим данным. Если мы хотим сделать наш скрипт, который будет
 работать непосрадственно с логином и паролем, то мы должны проверить - были ли передан логин и пароль!
 Нужно ловить не нажатие кнопки, а ловим существование логина и пароля! Тогда мы сможем его вывести и
 поработать с конкретным логином и паролем.
 Главное правило - если мы работаем с логином - мы должны проверять существование логина,
 если с паролем, то существование пароля. И так со всеми данными.*/

//	При этом если нам нужны какие-то значения по умолчанию, допустим мы передаем логин и пароль, а остальные
//	разделы формы пользователь не заполнил, то можно сделать так:
	if(isset($_POST['like'])) {
		echo 'Человек любит'.$_POST['like'][0];
	} else {
		echo 'Человек ничего не любит'; // выведется на экран, если ничего не отметил в чекбоксе.
	}

14-9 // Безопасность: Любые переменные и данные которые мы сами заполняем - безопасные, напрмер:
$x = 10;
	echo $x;
/* А данные, которые запоняются из формы - суперглобальные $_POST и $_GET вот их заполняет клиент, их и нужно проверять.
Если данные переданы правильно, то выполнять какие-то действия, а если неправильно переданы, то нужно вернуть его
обратно на нашу форму.*/

14-10  //полный текст кода с проверкой авторизации:
if(isset($_POST['login'], $_POST['pass'])) {
	echo $_POST['login'];
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
	if(isset($_POST['like'])) {
		echo 'Человек любит'.$_POST['like'][0];
	} else {
		echo 'Человек ничего не любит';
	} echo "Вы успешно зарегистрировались";
} else {// если регистрация не прошла, то выполняется блок кода расположеного ниже - скобка открылась
?>
<h1>Форма</h1>
<form action="" method="post">
	<input type="hidden" name="hide" value="скрытое значение">
	<div>Заполните логин:<input type="text" name="login" value=""></div>
	<div>Заполните пароль:<input type="password" name="pass" value=""></div>
	<div style="padding:15px">
		Пол: <br>
		<label>Мужчина <input type="radio" name="gender" value="Мужчина"></label> |
		<label>Женщина <input type="radio" name="gender" value="Женщина"></label>
	</div>
	<div style="padding:15px">
		Любимый напиток: <br>
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
	</div>
	<div><input type="submit" name="submit" value="Отправить данные" style="border-style:hidden; border-radius:10px;
	background-color:#90ff90"></div>
</form>
<?php } ?><!-- скобка закрылась-->
<!--Лайфхак: Вставка большого кода html в php:
для того, чтобы вывести большой код html нам не обязательно писать echo '' (где внутри кавычек писать html код на
много строчек). Достаточно закрыть php и дальше писать html, а в конце открыть php и закончили наше условие,
как в примере выше <?php } ?> -->

<?php
14-12 Различия между $_GET и $_POST - работа с ними полностью аналогична, нужно только указывать так же
 метод принятия в форме <form action="" method="post">. Абсолютно аналогичное действие, за исключением маленьких
 деталей.
 POST - это наши скрытые данные, засекреченные, когда мы данные отправляем на нашу страничку они отправляются,
 но мы их не видим куда отправились, то есть нигде не отображаются в нашем браузере. То есть наш массив передается
 в скрытом типе. Еще у POST можно передавать картинки.
 GET - метод передачи данных через адресную строку. При отправке методом GET мы получаем очень длинную адресную строку:
  /testphp1.ua/index.php?hide=скрытое+значение&login=132123&pass=1231231&gender=Женщина&like%5B%5D=Чай&submit=Отправить+данные
 - это строчка состоящая из ключей=значение, ... (+ это пробел)
  POST в адресной строке наши данные НЕ передает!
 Еще отличия:
 1) Методом GET нельзя передавать файлы,
 2) GET - ограничен по длине (нельзя передвать большие тексты - длинна поддержки зависит от браузера) -
 в последнее время эта проблема ушла с развитием браузеров.
 3) GET - виден на экране, в том числе и пароль, который в форме скрыт звездочками!
 4) Из плюслов: GET хорош при передаче ссылок из поисковых запросов:
 https://www.google.com/search?q=%D1%87%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+php&rlz=1C1SQJL_ruUA888UA888&oq=%D1%87%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+php&aqs=chrome..69i57j0i512l6j69i61.4942j0j1&sourceid=chrome&ie=UTF-8
 это ссылка из гугля запроса "что такое php".
5) GET - используется для навигации (использование ЧПУ, для SEO раскрутки)


14-13 // Разбор домашки к уроку 13 и задание к 14 уроку:
function calc($num1, $num2, $action='plus') {

}
/*Домашка сделать форму:
1) два поля для ввода данных
2) 4 радио для + - * /
3) сделать кнопку "отправить"
4) вывести число (ответ) без разницы где вверху или сбоку: 5+10 = 15 (отобразить входящие данные, саму формулу и результат).
5) не забывать пользоваться проверкой isset входящих данных, чтобы существовало значение первое и значение второе
if(isset($_POST['num1'], $_POST['num2'])) {..} нужно ввести значение 1 и 2 и отправить в нашу форму*/



Урок 15: //Улучшаем качество кода, include+GET, Суперглобальные массивы
/*План:
Ошибки домашек
Создаем навигацию include + GET
Изучаем область видимости переменных
Константы
$_REQUEST, $_SERVER, $GLOBALS
Самостоятельно изучаем пакет функций*/

15-1  //Навигация с GET - разбираем домашку №15:
$_GET = 'index.php?page=contacts'// переменная GET - это то что у нас в адрессной строке+?page=какая-нибудь страничка
$_GET['page'] = 'contacts'; // это говорит, о том, что мы можем спокойно передавать данные, используя навигацию,
// используя наши теги ссылок.


if(isset($_GET['page'])){ //если страница существует
//echo '<h1>'.$_GET['page'].'</h1>';
} else { //если нет, то создастся
$_GET['page'] = 'index';
}
?>
<div id="header">
	Навигация:
	<a href="15.php?page=main">Главная</a> |
	<a href="15.php?page=history">Наша история</a> |
	<a href="15.php?page=contacts">Контакты</a> |
	<a href="15.php?page=aboutus">О себе</a>
</div>
<div id="content">
	<?php include $_GET['page'].'.php';?> <!-- '.php' нужно обязательно указывать-->
</div>
<div id="footer">
	Тут пишем копирайты.
</div>

<?php
15-2 // Обычные функции с обычными переменными:
$x=5; //если х=5, то выведется на экран 10, если другая цифра - то ошибку выдаст. В javascript это рабьотает
// по другому и функция выполнится
if($x==5) { /* если функция соотвествует условию, то функция создастся, если нет, то не создастся */
function test($x) {
echo ($x*2);
 }
}
test($x); // получим на экране "10"

// а вот другой пример - внутри функции и вне - одна и та же переменная:
$x=5; //задали, но внутрь функции она не попадет
function test($x) { //внутри функции переменная останется внутри функции
	$x=10;
}
test($x) // а на экран выведется "5"

15-3 // Суперглобальные фукнции - в отличие от предыдущего примера, где переменные
//выполняются только внутри функции или только вне суперглобальные действуют везде.
//мы можем задавать так же переменные:
$x=5; // - локальные переменные
echo $x; //если только это оставить, то выведется "5"

unset($x); //почемуто не очистила предыдущую переменную :)))
$x=7;

$x=10;
echo $x; //в этом случае уже "510"

//Мы так же можем создать константу с помощью define - это такая переменная, которая пишется без знака $ и которая
// не может быть исправлена дальше по коду.
define("CON", "Привет, мир!"); // мы создали функцию в глобальной области видимости
echo CON; //пишем без ковычек!
function test() {
echo CON; // интересно передастся ли константа внутрь функции?
}
test();// да вывелось на экран: "Привет, мир!Привет, мир!"
//данная константа видна и за пределами функции и внутри функции!

//Когда использовать константы? Например для счетчика - указать, что на странице прилюбых раскаладах будет
// выводиться только 12 новостей:
define ('NEWSONPAGE', 12);
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>';//выводим новости 12 раз.
}
//если появится задача сделать 3 блока по 12 новостей, то просто копируем цикл for (3 строчки последние)
// еще два раза и всё.
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>';//второй блок
}
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>'; //третий блок
}
15-4 /*Кроме констант есть и другие способы вывода в глобальную область - глобальные переменные:
	1) $_GET;
	2) $_POST - эти переменные и так видны внутри функции и их не обязательно туда
 передавать, но по канонам програмисты считают что функции создаются для того,
 чтобы туда можно было передать какие-то значения и вернуть какие-то значения:*/
 functio test() {
	 echo $_POST['x'];
	 echo $_POST['y'];
	 echo $_POST['z'];
} test ();
 /* 3) $_FILES - сюда будет попадать все, что содежится в <input type="file"/>
 Разберем на примере одновременного использования всех трёх:*/
$_GET['page'];
$_POST['login'];
$_FILES['file'];
?>
<form method="post" action="" name="page">
	<input type="text" name="login">
	<input type="file" name="file">
</form>
<?php
/*  4) $_REQUEST - дубль от $_GET, $_POST - усложним задачу - у нас два запроса
GET и POSt с именем'page' */
$_GET['page'];
$_POST['page'];
$_POST['login'];
$_FILES['file'];

$_REQUEST = array(
	'page' <- $_GET // page пападет из GET
	'login' <- $_POST //login из POST
);
/* но в наших занятиях $_REQUEST использовать не будем, потому что работая
в наших скриптах мы должны делать полностью "прозрачной" нашу работу, так
чтобы это было очевидно - что за переменная, откуда пришла и что делает */

/*  5) $_COOKIE;
    6) $_SESSION; - работу куки и сессии мы разберем на отдельном уроке.
	7) $_ENV; - не будем вообще разбирать.
	8) $_SERVER;
	9) $_GLOBALS; - сегодня рассматривать не будем
расмотрим $_SERVER: */
echo '<pre>'.print_r($_SERVER,1).'</pre>'; // получаем полную информацию
// о сервере. Данную переменную в коде осталять нельзя, чтобы не отдать хакерам наш
// сайт. Так же нельзя показывать хакерам phpinfo();
//но есть и полезные фишки - можно блокировать айпи:
if($_SERVER['REMOTE_ADDR'] == '127.1.1.17') {
	echo 'Извините вам нет доступа';
}
//или наоборот запретить доступ не с нужного айпи:
if($_SERVER['REMOTE_ADDR'] != '127.1.1.17') { //настройка чтобы только у вас был доступ к серверу
	exit; //остановка скрипта
}

15-5 //Домашняя работа №15:
/*Завершить верстку макета и сделать рабочую навигацию с использованием include + GET. Сделать copyrights по виду:
2013 или 2011-2013 используя константу и функцию date().
Добавить в навигации еще один пункт меню "Админ панель или админ" и данную навигацию выводить только для пользователей
определенного IP. Кроме того внутри страницы main сделать проверку: if($_SERVER['REMOTE_ADDR'] != '127.1.1.17') ...
нужно заблокировать определенный IP адресс и выводить ссылку, то мы через эхо выводим ссылку на нашу страничку админки,
 если не совпадает, то на админку ссылку не выводим.
Так же самостоятельно изучить пакет проверок на php.net: isset, empty, is_array, is_bool, is_double, is_float, is_int,
 is_integer, is_null, is_numeric, is_real, is_string.
Приведение к типу: int, string, array, float.
*/
$var = 10;
$var = (int)$var;
$var = (string)$var;
// в домашке сделать тесты для себя:
$var = '1текст1';
echo (int)$var;
//еще протестировать:
$var = '1111';
$var = 'текст';
$var = 'текст2221';
$var = '1441текст';
$var = array ('пиво');
$var = (int)$var;
echo $var;

/* Еще выучить: Функции: gettype, count, include, include_once, require, require_once, rand, date */


Урок 16: //Фильтрация данных, $_COOKIE, $_SESSION

/*План:
Фильтрация данных
Безопасность при include
filter_var для адресов и email
int, float - для чисел
in_array для определённых множественных вариантов
$_COOKIE: Чтение, создание, редактирование и удаление
$_SESSION: Чтение, создание, редактирование и удаление*/

16-1 // Вывод ошибок
// Можно отключить в настройках: error_reporting(-1) поменять на ноль;
//Второй вариант отключение определенных ошибок - добавление знака @ - в то место, где может быть выведена ошибка
if (isset ($var)) echo $var; //иногда вместо такой записи пишут вот такую:
echo @$var; //если переменная будет, то она выведется, если нет, то вывод ошибок будет проглушон.

//Скрипт вывода ошибок: error_reporting(-1) можно в одном коде открывать и закрывать (меняя -1 на 0) по нескольку раз
// по мере необходимости.

//Обычно лезть настройки сервера нам никто не дает, поэтому для конкретного сайта в корне сайта создается файл:
//.htacess - для каждого сайта создается отдлельный файл!

//Разберем ошибки на примере домашки. В домашке у нас было так (? - это тернарный оператор):
$_GET['page'] = (isset($_GET['page']) ? $_GET['page'] : 'main');
include $_GET['page'].'.php';
//если не правильно будет указан файл или не найден, то воявится ощибка:
//"Warning: include(main.tpl): Failed to open stream: No such file or directory in..."

16-2 // Первое нам нужно не допустить возможности перехода по папкам и файлам через GET запрос - через редактирование
// url страницы, когда через точки и наклонную черту получают доступ к файлам, например:
test.ua/index.php?page=(сюда дальше хакер редактирует запрос и доходит до папок и файлов:)../../../inpost.zz.mu/index

16-3//46:20 Еще один вид хакерских атак - include-inject - позволяет подгружать файлы из соседних папок, которые есть
// в наличии, но подключать не нужно
// Второй вид инъекции: include-inject + upload-inject (сокращенно upload-inj)
// в файл картинки дописывается скрипт <?php echo $var; ? >, после чего при подключении этого файла через include
// запускается этот скрипт. Причем если подключить эту картинку через стандартный html: <img scr="file.jpg">,
// то скрипт не запустится.

16-4 //Когда мы делаем сайт, то он должен отвечать таким требованиям:
//1. Работает
//2. Безопасен
//3. Не имеет ошибок

16-5 // Приведение к типу - int, float - защита наших данных от передачи посторонних параметров.
//Для того чтобы в форму регистрации в поле ввода возраста вместо цифр не вписали что-то другое используется
// приведение к типу:
$_GET['id'] = (int)$_GET['id']; //id - это номер нашей записи, в дальнейшем мы поработаем с ним
//получается неважно какие данные получаем через адресную строку, в переменную мы получим уже обработанные,
// в нашем случае чистые числа

//Допустим для банковской системы, где имеем дело с передачей денег, то тут используем float:
$_GET['maney'] = (float)$_GET['money'] // тут даже если напишут в поле 5551515.145<php aendws... - все равно
// в переменную получим чистое число без мусора '5551515.145'

16-6 // Следующее нужно проверить точно ли нам передали нужные значения?
//Если мы подразумеваем, что через адресную строку 'page' мы можем передавать только 'main', то мы пишем:
if($_GET['page'] != 'main') { //если 'page' не равна 'main'
	exit(); // то мы обрываем наш скрипт
}
//То есть кто-то пытался через адресную строку ввести те значения, которые не допустимы на нашем сайте, и у него
// теперь это не выйдет.

16-7 //Существует третий вид проверок - встроенные функции в php
//Для того, чтобы работать с конкретной страницей, нам нужно быть уверенными, что были переданы какие-то конкретные
// параметры
if(isset($_POST['email'])) { //точно ли передан email?
	if(!empty($_POST['email'])) {// проверка - а не пустой ли email
	// обработка данных - заносим в базу данных или еще какое действие делаем
	}
}
//Бывают сложные проверки - действительно ли email ввели правильно? Есть ли @, name, domain, в домене точка должне
// быть .com например, ... Для этого используют встроенную функцию filter_var

//Что нам возвращает isset: true или false - существует или не существует переменная
// filter_var работает точно так же возвращет true или false.
// Если email внесен правильно, то true, если не парвильно, то false
// у этой функции есть набор фильтров: https://www.php.net/manual/ru/filter.filters.php
//как это все работает:
if(isset($_POST['email']) && filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) { //делаем проверку если у нас
	// существует переменная $_POST['email'] и (&&) filter_var(название функции), то есть проходит валидацию переменная
// $_POST['email'], после чего указываем как мы будем фильтровать - проверим на email -  FILTER_VALIDATE_EMAIL -
// стандартная настройка из ссылки выше
	echo 'Все ок!'; //если все проверки положительные выведется эта строка
}
Код проверка почты из моего проекта, удалил, за ненадобностью, но он рабочий:
if(!empty($_POST['email'])) {
    if(!filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) {
    $errorForm['emailError'] = "Почтовый адресс введен не верно!";
    }
}

?>
<form action="" method="post">
	<input type="text" name="email">
	<input type="submit">
</form>
<?php
//чаще всего функция filter_var используется для проверки адресной строки и email

16-7-1 Проверка логина на допустимые символы (код из моего проекта тоже):
if(!empty($_POST['login'])) {
    if (!preg_match("/^[a-zA-Z]*$/", $_POST['login'])) {
    $errorForm['loginError'] = "В логине допускаются только латинские буквы";
    }
}

16-8 // Не проще ли проверки такие делать через Java Script?
//JS делает на стороне клиента и если клиент захочет, то он не будет делать такую проверку, а php
// делает эту проверку на сервере, то есть данные уже пришли и клиент не сможет подделать данные

16-9 // Область допустимых значений - выводим три варианта допустимой страницы:
if($_GET['page'] == 'main' || $_GET['page'] == 'contacts' || $_GET['page'] == 'aboutus') {
	echo 'все хорошо!';
} else {
	exit ('Вы ввели недопустимые значения'); // завершаем через exit;
}
//если так делать, то проблемы с 'include-inject' отпадут, то есть в адресную строку не напишут какой-нибудь бардак
// и не смогут подключить сторонний файл, из-за того что мы заранее делаем проверку и определяем какое значение верное.
// Если хотя бы одно из этих значений верно, то мы работаем со скриптом. В противном случае мы можем его вырубить
// через 'exit '

//Данная запись она работает, но она длинная и не совсем красивая, лучше вариант через создание массива:
$allowed = ['main', 'contacts', 'aboutus', 'game1', 'program1'];
if(!in_array($_GET['page'], $allowed)) { // подключаем проверку из массива через отрицание(!)
exit ('Вы ввели недопустимые значения');
}

//Проверка возраста + проверка наличия самой переменной:
$sex = array ('man', 'girl');
if(isset($_GET['sex']) && in_array($_GET['sex'], $sex)) { //проверили наличие самой переменной и сравнили данные
	// с данными из массива
	//обработка анкеты
} else {
	$_SERVER['REMOTE_ADDR']; //узнаем с какого IP нас пытались взломать, обычно ломают пользователи сайта,
// поэтому через базу можно найти этого пользователя, по сессии, по кукам - это потом разберем.
	exit(); //запрос пытались подделать
}
?>
<!-- Html обычно в таком виде:-->
<select name="sex">
	<option value="man"> man</option>
	<option value="girl">girl</option>
</select>

<!--но мы его переделываем в такой: -->
<select name="sex">
	<?php foreach($sex as $v) { ?>
	<option value="<?php echo $v; ?>"><?php echo $v; ?></option>
	<?php } ?>
</select>

<?php
16-10 // Сессии и куки - что это такое?
//PHP так устроен, что он не хранит данные из переменных и при обновлении страницы или когда код считается до самого
// конца переменная очистится. Если нам нужно удержать/запомнить какие-то данные исользуются сессии и куки -
// они привязываются к определенному пользователю - это не общие переменные, которые существуют между страницами.
//База данных взаимодействует с каждым отдельным пользователем и позволяет пользователям выводить конкретные данные.
// Базы данных будем изучать позже.
//Куки и сессии - это для конкретного пользователя переменные, а БД - это переменные доступные для всех.

// Куки и сессии - это созданные файлы в виде баз данных, в которых содержится набор переменных, это обычные наши
// массивы, аналогичные с $_GET, $_POST, $_SERVER

//$_COOKIE - находятся у клиента (к/к)
//$_SESSION - хранится на сервере (с/с)

//Клиент может править куки как он захочет, поэтому этим данным не стоит доверять. Так как куки хранятся у клиента,
// то в них нельзя размещат важную информацию. Содержимое куки можно прочитать и изучить пароли и другие вещи.
//Если сессии - это безопасно, то зачем тогда куки?
// У сессий есть стандартное понятие - очистка брошеннх сессий. Обычная сессия 22-23 мин(стандартные настройки сервера),
// если на протяжении этого времени сессия небыла исправлена, изменена, страничку на сайте не коткрывал, не обрабатывал,
// к ней не делали запросов, то сессия конкретного пользователя "умирает"
//Время жизни куки наоборот будет столько, сколько мы хотим
// Кроме того так как сессия хранится на сервере, то это дополнительная нагрузка, дополнительные данные, которые будут
// захламлять наш сервер. Если пользователей мало, то и сессии будут весить очень мало

//Без куков покупки которые мы переместили в интернет магазине в карзину, но не оплатили через 22 минуты, исчезли бы
// так как сессия разорвалась. С помощью куков мы можем продлить хранение данных о покупках на пол года или год и
// клиент через время сможет продолжить работу с магазином и купить товар.

16-11// Как подклюбчить сессию?
//Для подключения пишем в начале скрипта:
error_reporting(-1);
ini_set('display_errors', 'on');
header('Content-Type: text/html; charset=utf-8');
session_start(); // вот тут стартует сессия

/* Если сессии не включить, то мы не сможем работать с $_SESSION, а именно:
1. Добавлять данные
2. Читать данные
3. Редактировать данные
4. Удалять данные
*/

//Добавление данных:
$_SESSION['name'] = 'login';
//Для вывода логина на экран:
echo $_SESION['name']; // эти данные может подтянуться даже на другой странице, отличной ото той, где этот
// логин вводился. При переходах по страницам логин будет виден (если включено).
//Удаляются данные через функцию unset. Разберем пример:
echo '<pre>'; //для наглядности просмотр в столбик массива
print_r($_SESSION); //тут еще показывает наш логин
unset($_SESSION['name']); //удаляем из файла
print_r($_SESSION); //после обновления страницы - уже нет

//для очистки всей нашей сессии, чтобы ее не существовало, мы пишем:
session unset;
session_destroy();

16-12 // Куки
echo '<pre>';
echo 'SESSION: ';
print_r($_SESSION);
echo 'COOKIE: ';
print_r($_COOKIE);

$_SESION['name'] = 'inpost'; //эта строка должна была перенести логин того кто открыл сессию, но почему-то
// не вывело - вместо этого пишет в куки инфо про phpstorm

//в куках мы увидим:
//[Phpstorm-34e77593] => ab538db4-0e52-42d1-ab31-b8ebe378b55b
//[PHPSESSID] => 88ec249b378b1e21aa5eb57680853ec4 // - это идентификатор, название файла сессии,
// которая принадлежит конкретному человеку. Этот идентификатор создается автоматически и содержится в куках.
// Но тут появляется момент уязвимости - вирус ворует идентификатор сессии из куков в системе клиента и после этого
// имеют доступ к сессиям на сервере. Подделывая куки злоумышленник может попасть на сайт. Чтобы хакеры не воровали
// нашу информацию время сессии ограничивают до 22 минут.

//Куки хранятся в разных браузерах у разных местах:
// C:\Users\Ваше имя пользователя\AppData\Local\Microsoft\Windows\INetCookies (win10)
//C: \ Users \ user \ AppData \ Local \ Google \ Chrome \ User Data \ Default (Chrome)
//C: \ Users \ user \ AppData \ Roaming \ Mozilla \ Firefox \ Профили (Mozilla)
// C: \ Users \ user \ AppData \ Local \ Packages \ Microsoft.MicrosoftEdge_8wekyb3d8bbwe \ AC \ MicrosoftEdge \
// Cookies (MS Edge)

//Добавлять данные, редактировать и удалять - можем только в период отправки заголовков,
// а читать данные - можно везде.
//Период заголовков будет существовать до первого echo в коде. Поэтому можем получить ошибку,
// если используем echo перед header('Content-Type: text/html; charset=utf-8') и session_start();

16-13 //Как создаются, редактируютися и удаляются куки?
//Создаем куки:
setcookie('name1', 'Roman', time()+60*60*24*30*12, '/');
// эта функция имеет 4 параметра: 1)ключ, 2)переменная, 3) время жизни куки (если ничего не указать, то быдет считать,
// что куки живут только сейчас, для увеличения времени после скобок добавляем + время в секундах,
// 4)'/'(ставится, чтобы кук работали по всему сайту).

//Редактируем куки:
setcookie('name1', 'NEW_MESS', time()+60*60*24*30*12, '/'); //кука умрет на стороне клиента
//путем замены имени
//Клиент не имеет достиупа к серверу, сервер не имеет доступа к клиенту

//Можно еще менять куки через переменную, но такой способ обычно не используется:
setcookie('name4', 'NEW_MESS', time()+60*60*24*30*12, '/'); // меняет у клиента
$_COOKIE['name4'] = 'AAAA'; //заменяет на сервере

//как убить куку:
setcookie('name4', 'NEW_MESS', time()-60, '/'); //ставим отрицательное время, что убивает куку у пользователя.

//Редактировать, добавлять и удялять куки (не сессии, а именно куки) можно до вывода информации на экран.
// Сессии можно в любой момент.

16-14 //Домашняя работа
/*
1-я домашка обязательна, 2 и 3 по жаланию.
1-я - на понимании куков и filter_var
2-я - на сессии и rand ()
3-я - на функции readdir и if-dir
*/


16-15// Домашнее задание №1 Форму для авторизации и выход (1:10:00 / 1:45:45)

/*https://youtu.be/xxTMusbYpIk?t=4200
Делается достаточно просто, простая форма на ввод логина, пароли и email. Далее проверяем сначало на то,
что заполнили поля, и email заполнили верно! После авторизации - запоминать ключ в куках. Выводить на экране.
Для email: filter_var. Последнее поле меню: ВЫХОД!
Сделать простую форму авторизации. В прошлом уроке было выводить меню для определенных айпи адресов.
Теперь добавить возможность по айпи либо для тех у кого прописан ключ, а ключ мы будем через форму авторизации:
логин, пароль, емеил, войти. Если логин и пароль ввели правильно, то мы создадим куку с именем:*/
$_COOKIE['access'] = 1; //значит выводи меню ADMIN, то есть своего рода авторизация.
/*Если куки не существует, то мы проверяем айпи адресс. Если айпиадресс проходит выводим ADMIN, если айпи адресс
не подходит, то мы не выводим айпи вообще
Задача простая - проверить форму, поработать с filter_var и поработать с куками. И добавим еще выход из кук,
выход из админки меню ВЫХОД! Эта кнопка должна убить $_COOKIE['access'] через отрицательное число, то есть будет
отдельно созданная страничка на которую человек перейдет и кук убьется.
Нужно учесть только что куки можно создавать только до вывода любой информации на экран, поэтому нажатие, всю
обоработку данных, ее нужно делать в самом начале, нижний блок из кнопок обработки мы помещаем в index.php
в верхний блок, до вывода html.*/
if (isset($_POST['submit_auth'])) {
	//
}
if (isset ($_GET[exit])) {
	// передается через index.php?page=main&exit=1 так мы сделаем выход
}
16-16// Домашнее задание №2 Битва алкоголиков (https://youtu.be/xxTMusbYpIk?t=4558)
/*Мини-игра, цель которой показать, что алкоголизм - это плохо. Мы создаём страничку main.tpl под игру.
Создаются 2 персонажа, у обоих по  10хп (2 сессионных переменных), создаётся форма, где пользователь вводит число
от 1 до 3 и отправляет запрос на сервер. На сервере запустить rand(1,3), и если значение человека со значением
случайным совпадает, то снимаются ХП с персонажа человека (клиента), если не совпадают - с серверного персонажа.
Отнимать надо от 1 до 4хп, случайным образом). То есть вероятность 33%, что отнимутся у клиента, и 66%, что
у серверного персонажа.
В момент, когда у одного из персонажей ХП становится 0 и ниже,- перебрасывать на другую страницу при помощи
переадресации (header) на страницу gameover.php, и выводить текст, победил ли игрок, или система.

Цели игры: разобраться в сессиях и переадресациях. Попробовать на практике изученную самостоятельно функцию rand();*/
if(!isset($_SESSION['client'])){//если клиента не существует, то создаем ниже
$_SESSION['client'] = 10;
$_SESSION['server'] = 10;
}
/*далее через форму мы вводим число от 1 до 3, если число не совпало с rand(1,3), то мы выиграли у компьютера
отнимая от 1 до 4 хп
После победы происходит перенос на новую страничку, для этого используем функцию:*/
header("Location: index.php?page=game1over&action=lose"); //функция переадресации на новую страницу
/*Еще с header("Location...") используется exit;*/


16-17// Домашнее задание №3 Файловый менеджер
/*Простая файловая система на подобии norton-comander, far, FileZilla с упрощенной версией.
Её путь будет: program.php .
Необходимо:
1) вывести каталог папок и файлов для данной директории, используя scandir('.'). Перед названием выводить иконку папки,
 или иконку файла соответственно. Проверку делать на: if(is_dir()) - else.
2) Папки сделать кликабельными, через ссылку передавать второй аргумент - путь к файлу по примеру:
<a href="/program.php&link=echo (isset($link) ? $link.'/'.$v :$v);">имя папки</a> .
Данный путь будет содержаться в массиве после использования функции scandir.
3) По переходу по ссылке будет передаваться $_GET['link'], который необходимо будет подставить в функцию scandir
для того, чтобы отобразить файлы и папки внутри конкретной директории.
4) Таким образом мы сможем воссоздать файловую систему и передвигаться по директориям и поддиректориям.

Цели программы: изучить новые функции + цикл с массивом и множества аргументов для $_GET.*/
1:22:41 / 1:45:45
scandir('.') //анализирует данную папку
scandir('./1')//то анализируем папку '1'
//в файловой системе идем только вглубь, назад возвращаться не нужно.

Урок 17: Ядро, структура сайта, MVC
/*План:
	Архитектура сайта
	Ядро
	Структура сайта
	MVC
	Шаблоны*/

17-1-1 //Настройка файла index.php
error_reporting(-1);
ini_set('display_errors', 'on');
header('Content-Type: text/html; charset=utf-8');
session_start();

//конфиг сайта
include_once './config.php';
include_once './libs/default.php';
include_once './variables.php'; //- для работы с нашими переменными

//роутер - распределение между страницами, что мы будем подключать:
include '/modules/'.$_GET['module'].'/'.$_GET['page'].'.php';
include '/skins/'.SKIN.'/index.tpl'; //главную страницу подключаем (используем переменную SKIN из config.php)
//в index.tpl (это тут все от <!DOCTYPE html> до </html>)- подключаем в html код в раздел

17-1-2 //index.tpl
?>
<title><?= echo @$title; ?></title> <!-- для вывода разного содержания для разных страниц с помощью контроллера
будем доставать эти данные из базы данных-->
<body>
<?php
include $_GET['module'].'/'.$_GET['page'].'.tpl';
?>
</body>

<?php
17-2-1 //страница с конфигурациями: config.php:
//задаем настройки сайта (всего сайта, а не страницы) через константы:
define('CREATED', 2013);
define('SKIN', 'default'); //шаблон - default
//define('NEWSONPAGE', 12); //12 новостей на странице
//подключаем базу данных:
define('DBLOGIN', 'inpost');
define('DBPASS', '123');
define('ADMINLOGIN', 'roman');
define('ADMINPASS', '123123');
//здесь будем хранить: соединения с базами данных, адресс нашего сайта и прочее

17-2-1 // страница variables.php
//задаем допустимые названия страниц, чтобы защититься от взлома:
$allowed = ('main', 'contacts', 'aboutus', 'game1', 'program1');

if(!isset($_GET['module'])) {
$_GET['module'] = 'static'; //папка "modules/static/" c файлами: main.tpl и .tpl, main.tpl и .tpl,...
} elseif (!in_array($_GET['module'], $allowed)) {
// подключаем проверку из массива через отрицание(!)
header ("Location: /index.php?module=404"); //вывод информации, что страница отсутствует
exit ();
}
if (!isset($_GET['page'])) {
$_GET['page'] = 'main';
}

17-3 // страница с конфигурациями: .htaccess
AddDefaultCharset UTF-8
php_flag display_errors ON

17-4 // библиотеки/ модули: папка modules
//в нее добавляем все классы, функции, пагинатор (навигация по страницам - внизу экрана 1, 2, ...898), аплоадер
// картинок - все делаем отдельными файлами с понятным названием

17-5 //папка с функциями: libs в ней создаем файл default.php - здесь будем записывать стандартные функции, которые
// будут использоваться везде, на всем сайте.

//для примера разберем функцию, которая будет выводить на экран массив - для мониторинга нескольких массивов
function wtf($array, $stop=false) {
	echo'<pre>'.print_r($array,1).'</pre>';
	if(!$stop) {
		exit();
	}
}
//вызов функции:
wtf($array,1);
wtf($array2,1);
wtf($array3); //тут 1 не прописали, значит false и функция остановилась

17-6 //MVC - Models (набор функций, базовое ядро) View (Вид, Представление) Controllers (Обработка данных) -
// размещать их нужно в разных файлах.
//За вывод информации отвечает верстальщик и СЕОшник, он определяет что где и как выводить, а Controllers -
// это уже часть программиста

//Controllers: отсутствует вывод на экран!

//Models: в 99% случаев не выводим на экран информацию через echo!
// используем return 'переменная или значения' возвращаем в контроллер и редко когда в представление

//View: весь вывод информации на экран + частичное php (echo $var; циклы, htmlspecialchars, приведение к типам -
// echo(int)$var;)

//1-й вариант разделения:
include $_GET['page'].'_controllers.php'; // 'news_controller.php'
include $_GET['page'].'_view.php'; //'news.view.php'
//2-й вариант разделения:
include $_GET['page'].'.php';
include $_GET['page'].'.tpl'; // tpl - изобрели для верстки
//3-й вариант разделения - реже всего используется:
include $_GET['page'].'.php'; //'news.php'
include $_GET['page'].'.html'; // 'news.html'

//4-й вариант - мы будем использовать его - это 2-й вариант + разбивать по папкам:
include '/modules/'.$_GET['page'].'.php';
include '/modules/'.$_GET['page'].'.tpl';

//примеры модулей:
//all_news.php - показать все новости
//view_news.php - просмотр одной новости в расширенном виде с комментариями пользователей сайта
//search_news.php - поиск по новостям

//но более понятно будет если называть по другому - первая часть - общая, дальше различия:
//news_all.php
//news_view.php
//news_search.php
//voting_all.php
//voting_once.php
//voting_last.php

//если на сайте планируется очень много модулей, то тогда лучше группировать их по отдельным папкам:
//news/all.php
//news/view.php
//news/search.php
//voting/all.php
//voting/once.php
//voting/last.php

//Примеры подразделов в папке модули: news, static, voting

17-7 // skins и подпапка default - папка с шаблонами: index.tpl - в него перенести весь html код с index.php.
include '/skins/default/index.tpl'; // это записать в index.php
//И такую же запись продублировать в body файла index.tpl

17-8-1 //404.php - создаем для ошибок отдельную папку 'modules/errors'( потом можно сюда добавить ошибки 403 и 500)
header("HTTP/1.1 404 Not Found");

17-8-2 // 404.tpl- создаем для ошибок отдельную папку 'skins/errors'
"Данная страница отсутствует!"


Урок 18: //База Данных MySQL. Основы
/*	План:
	Как всё устроено
	Создание БД
	Создание пользователя
	localhost
	Создание таблиц
	Частичная настройка и оптимизация таблиц*/
//https://youtu.be/a_DoWa7B6w8?t=1409/

18-1 База данных - это массив, который хранится, выдается между страницами и эти данные общие для всех, каждый
может получить доступ к этим данным. В отличии от сессии и кук. Потому что куки содержатся у клиента на
компьютере, сессии содержатся на сервере, но при этом другие пользователи к ним не имеют доступа без
определенного идентификатора, который знают только куки, которые содержатся у пользователя на компьютере.

База данных содержит огромное количество функций, основное назначение которых:
чтение, добавление, редактирование, удаление

18-2 // phpMyAdmin
доступен по ссылке: http://localhost/openserver/phpmyadmin/index.php
пароль и логин: root

Создаем базу данных во вкладке - "База данных". Задаем кодировку UTF-8: 'utf8_unicode_ci'. Жмем кнопку "создать"

Подключаем определенных людей к этой базе данных с указанием логина и пароля (авторизация). Для этог вкладка
"Учетные записи пользователей" => кнопка "Добавить пользователя".
 Затем заполняем форму:
	"Имя пользователя",
	"Имя хоста" - выбираем локальный, так как база у нас на компьютере.
	"Пароль:"
	добавляем ему все привелегии - в графе  Данные, Структура и Администрирование
	ограничения не ставим
	выбираем базу данных с которой будет работать этот пользователь
	добавляем пользователя

Возвращаемся в базу данных, проверяем привилегии и видим там нового пользователя

Если база не появляется сразу после создания - жмем вверху слева зеленую стрелку "Обновить панель навигации"

Обычно база данных делается одна на весь сайт

18-3 //config.php - в этом файле добавляем константу:
define('DB_NAME', 'main'); //main - это имя базы данной, которую создали в phpMyAdmin
define('DB_LOGIN', 'test'); //логин админа
define('DB_PASS', '1111'); //пароль админа
define('DB_LOCAL', 'localhost'); // расположение базы ("Хост")

18-4 Создание базы данных на хостинге (удаленном сервере)
Через панель выбираем наш сайт / Дополнительно / Базы данных MySQL /Создаем базу данных
В этом случае в файле config.php ставим параметр расположения ни localhost, а адресс базы нашего сайта
Затем через панель хостинга переходим уже в phpMyAdmin и попадаем в полную аналогию нашего локального phpMyAdmin

18-5 // Создаем таблицу и указываем ее значения
вводим имя, например "comments" и количество полей

тип таблиц выбираем : MyISAM или InnoDB
сравнение - кодировка выбираем utf8_unicode_ci

18-6 //Заполняем поля таблицы:

18-6-1 // Имя - в подсказке выбираем "id", "login"/"name", "data", "age", "text" и тд
Уникальность пользователей.
Чтобы отделять одинаковые сообщения одни от других в ID пользователя добавить счетчик просмотров и тогда в базе
не будет полностью одинаковых записей. Для этого в настройках в разделе в первой строчке там где прописываем
Имя пишем "id" дальше в колонке "Индекс" выбираем "PRIMARY"

18-6-2 //Тип выбираем для "id" выбираем "INT", для "name" - "TEXT", для "text" - "TEXT", для "date" - "DATE".
Есть еще более расширенные варианты числовых данных, даты и прочего. Например для чисел - от выбора типа зависит
байтовый размер типа (чем больше прежполагается будет база, тем больше нужно выбирать тип):
	TINYINT - 1 байт (числа базы от 0 до 256 ограничение, количество строчек, если выбрали этит топ для 'id')
	SMALLINT - 2 байт
	MIDIUMINT - 4 байт
	INT - 8 байт - если не знаете, что выбрать выбирайте INT.
	BIGINT - 16 байт
	чем больше байт, тем больше чисел она поддерживает, но и настолько медленнее будет сама база
	например, для поля "age" нам хватит 'TINYINT', так как до 256лет никто не доживет

для имени "name" нужно выбирать тип "VARCHAR" и указываем длинну "255" в следующей вкладке

18-6-3 //Длина/Значения - пока не будем разбирать, оставляем пустым

18-6-4 //Значения по умолчанию:
тут можно задать например если выбрали тип DATE в вкладке "по умолчанию" выбрать "как определено" и прописать
вручную формат даты и времени: "2013-01-01 12:12:12". Или с помощью "как определено" можно прописать логин
по умолчанию от которого будет писаться коментарий, если не выбран другой, например "guest"

18-6-5 // Сравнение - это наша кодировка, задаем если нужно задать кодировку отличную от предыдущих настроек.


18-6-6 // A_I:  Атрибут AUTO_INCREMENT может использоваться для генерации уникального идентификатора для новых строк.
Если отметить этот параметр в строчке 'id' и в вкладке "Индекс" выбрать "PRIMARY", то 'id' у каждой следующей
записи комментариев будет увеличиваться на единицу.

18-6-7 // После того как мы нажали кнопку "Создать" эту новую базу мы сможем увидеть слева.

18-6-8 // если нужно для эксперимента что-то вставить в новую базу, то переходим в вкладку "Вставить":
//'id' не заполняем

18-7// Домашка
Сделать БД: "Пользователи" - туда внести "имя", "возраст/год рождения", "дата создания своего аккаунта", логин,
пароль, краткую информацию о себе. Лучше всего посмотреть по разным сайтам какие поля заполняюься при регистрации.
для пароля выбираем тип "text" , для пароля - "varchar" или "text"
Создать Базу Данных, пользователя и 3 таблицы: comments, users, news. Сохранить структуру таблиц в формате .sql .
 Кроме этого создать 1 word-файл, в котором написать маленькое описание трёх таблиц, то есть что значат конкретные
 поля. По примеру: `age` - возраст зарегистрированного пользователя. `text` - сообщение комментария и т.д.
Дополнение к уроку:
Для возраста мы указываем `age` типа TINYINT, содержание: 1 или 0 .

Если таблица называется `users`, то поле мы называем `login`, в общей связке мы получим: `users`.`login`.
Ошибкой будет назвать поле `user_login`, в таком случае мы получим `users`.`user_login`, то есть тавтология -
повторение дважды слова `user`.
В свою очередь мы будем применять имена из двух слов `user_login` тогда, когда таблица не связана будет прямо
с пользователями, допустим это у нас таблица `news`, и мы указываем имя пользователя, который написал данную
новость: `news`.`user_login`.


Урок 19: Запросы select, insert, update, delete
/*План:
Разбираем структуру PMA
Создаем, редактируем и удаляем таблицы
Изучаем 4 главных команды: INSERT, UPDATE, DELETE, SELECT*/

19-1 //Разработка модуля
Есть задача: создание пользователя (регистрация пользователя).
1. Смотрим конкурентов, создаем схему и по этой схеме создаем нужную таблицу/таблицы в БД
2. Функционал по регистрации:
	- регистрация;
	- авторизация;
	- востановление пароля;
	- выход из системы;
	- кабинет пользователя;
3. В нашей сайте в папке modules и папке skins создаем папку cab. В кабинете (папка cab)
создам страничку с регистрацией registration.tpl и registration.php.
4. В файле variables.php добавляем в исключения в $allowed надпись 'cab'
5. Путь к файлу: index.php?module=cab&page=registration
6. Создаем логику приложения - структуру таблички. В PhpMyAdmin воздаем новую базу 'users':
	6.1 'id' - Тип (INT), Индекс(PRIMARY), A_I(галочку ставим)
	6.2 'login' - Тип (VARCHAR), Длинна 100 (максимум 255)
	6.3 'password' - Тип (VARCHAR), Длинна 100
	6.4 'email' - Тип (VARCHAR), Длинна 100
Тип таблицы - InnoDB, Сравнение (кодировка): utf8_unicode_ci
Создаем таблицу.
7. Вносим первые записи через PhpMyAdmin вкладка "Вставить": заполняем поля ('id' не заполняем!)
login, password, email, ok/вперед
8. Слева в меню переходим к выбору нашей таблицы (PhpMyAdmin):
	8.1 Обзор - выводится вся наша табличка. Тут мы можем делать:
		- Изменить
		- Копировать
		- Удялять записи
	8.2 Структура
		- редактирование полей таблицы
		- удаление
		- добавить поле в таблицу (в конец/начало/после 'id')
		- информация о таблице (размер и т.д.)
	8.3 SQL - тут указаны SQL-запрос(ы) к таблице users.users
	8.4 Поиск - обычно не используется
	8.5 Вставить - разбирали выше (для экспериментов создано)
	8.6 Экспорт - Экспорт строк из таблицы "users" - бэкап нашей базы данных:
		- выбираем обычный, сохранение таблицы - структура и данные, остальное по умолчанию.
	8.7 Импорт - в таблицу "users" - бекап данных (востановление)
	8.8 Привилегии - Пользователи с правами доступа к "users.users"
	8.9 Операции:
		-параметры таблицы - редактирование (тут полезное коментарии добавить можно и сменить
		AUTO_INCREMENT - прописать 10000 - тогда id будет начинаеться не с 1, а 10001)
		- обслуживание таблицы (пока это не будем разбирать)
		-Удалить данные или таблицу
	8.10 Триггеры (пока не нужно)

19-2 //Команды для работы с БД (вкладка SQL):
1. Добавить данные - INSERT INTO:
		- добавляются по одной записи в нашу табличку;
		- имена таблиц и ячеек указываем (ключи) с `обратным апострофом` (буква Ё в рус раскладке),
		а 'значения' (с обычным - буква Э в рус раскладке);
	1.1 Разберем синтаксис для единичной вставки (можно писать в столбик):
			INSERT INTO
			`таблица` (`users`)
			SET
			//`ключ1` = 'значение1', `ключ2` = 'значение2', `ключ3` = 'значение3' (в конце запятая не ставится),
			//например:
			`login` = 'Salex',
			`password` = 'qwerty',
			`email` = 'salex@gmail.com'
		Жмем "ОК" и каждую новую запись так же добавляем
	1.2 Синтаксис для вставки в php:
			mysqli_query ("INSERT INTO `users` SET
			`login` = `Salex`,
			`password` = 'qwerty',
			`email` = 'salex@gmail.com',
			`age` = 22");
	(цифры можно без кавычек, слова в кавычках)
	1.3 Синтаксис для множественной вставки:
	INSERT INTO `users`(`id`, `login`, `password`, `email`) VALUES ('[value-1]','[value-2]','[value-3]','[value-4]')

2. Отредактировать данные - UPDATE
	2.1  Условие WHERE - ссылка, указание на конкретные записи. WHERE используется при UPDATE,
	DELETE, SELECT, кроме вставки.
	WHERE 'key' = 'value' //например: WHERE `id` = 4;
	WHERE `age` >= 18 AND `login` = 'inpost'; //аналог php: if ($age>=18 && $login=='inpost')
	WHERE `age` >= 18 OR `login` = 'inpost'; //аналог php: if ($age>=18 || $login=='inpost')
	2.2 Меняем запись `id` = 4
	UPDATE `users` SET
	`login` = 'Петя', //то что хотим изменить
	`email` = 'petya@mail.ua', //то что хотим изменить
	WHERE `id` = 4 // где меняем
	//нужно быть внимателным - без WHERE может поменяться у всех пользователей
	2.3 Математические операции:
	UPDATE `users` SET
	`age` = `age`+ 2 //добавит к возрасту 2 года
	WHERE `id` = 4 //если не указать WHERE всем пользователям добавит + 2 года

3. Удалить данные - DELETE FROM
	Если в DELETE FROM не прописать условие WHERE, то удалятся все записи.
	3.1 Как удалить пользователя 'Salex':
	DELERE FROM `users` WHERE `login` = 'Salex'
	// Равенство: если в php пишем ==, то в MySQL = это важно!
	//так как в php одно = это присваивание, в MySQL = это равно, а присвоение это @=
	// не равно в MySQL пишется != или <>
	3.2 Удаление по шаблону:
	DELETE FROM `users` WHERE `id` = 10001 AND `age` > 100 AND `email` = '121212@mail.ru'
	Удаление нескольких записей по шаблону:
	DELETE FROM `users` WHERE `age` > 20 //удалит все записи у кого возраст больше 20.
	//если таких записей с `age` > 20 не будет, то ничего не удалит и ошибку не высветит
	// а если ошибиться в названии ключа, например 'agadadadfa' > 20, то выдаст ошибку.
	Любой запрос можно проверить через панель MySQL и убедиться, что у вас все грамотно написано.
	Можно задавать диапазон:
	DELETE FROM `users` WHERE `age` >= 20 AND `age` <=30 //удалит всех от 20 до 30 лет
	3.3 Востановить удаленные записи очень сложно. Можно через бекап, если вы заранее делали "экспорт".
	3.4 Удаление с форума сообщения №34454:
	DELETE FROM `table` WHERE `id` = $_GET['mess']
	<a href="index.php?mess=34454"
	//без WHERE удялятся все записи с форума
	3.4 Для удаления записей с пустым полем нужно писать:
	WHERE `id` = '' //удялятся пустые записи и записи с '0'
	WHERE `id` = //выдаст ошибку
	3.5 Лимит удалений - LIMIT:
	DELETE FROM `users` LIMIT 2 //удалит 2 записи - используется для удаления по частям

4. Выбрать данные - SELECT:
	4.1 Примеры выбора:
	SELECT `login`, `password` FROM `users` //выберет пользователей, которые указали логин и пароль
	SELECT * FROM `users` //выберет всех пользователей - это обязательный минимум полей
	SELECT * FROM `users` WHERE `age` < 23 //выберет все данные с возрастом до 23 лет.
	SELECT * FROM `users` WHERE `age` != 23 //выбор пользователей чей возраст не равен 23 года.
	SELECT * FROM `users` WHERE `age` <> 23 //тоже самое, только это более правильно так писать в БД
	SELECT * FROM `users` WHERE `login` = 'inpost' //выберет пользователя 'inpost'
	//Пример поиска по сайту новостей (новости в базе данных хранятся):
	SELECT * FROM `news` WHERE `category` = 'economy' //отсортирует только новости про экномику
	SELECT * FROM `news` WHERE `id` = '56887' //найдет новость 56887
	4.2 Сортировка - ORDER BY:
	SELECT * FROM `users` ORDER BY `id` ASC //сортировка по 'id' по возрастанию
	//ASC (по возрастанию - 1, 2, 3, 4) DESC (по убыванию 4, 3, 2, 1)
	4.3 Двойная сортировка
	//если после сортировки у нас выдало несколько пользователей с одинаковым возрастом, то можно
	// дополнительно просортировать еще и по 'id', для этого через запятую добавляем:
	SELECT * FROM `users` ORDER BY `age` ASC, `id` ASC
	//Сортировка пользователей по возрасту = 20 лет и затем по 'id':
	SELECT * FROM `users` WHERE `age` = 20 ORDER BY `id` ASC
	//Это можно использовать для выода последних новостей по экономике на главную страничку
	// или для вывода на экран сначала последних комментариев, потом более старых
	4.4 Ограничение количества вывода - LIMIT сколько всего:
	SELECT * FROM `news` WHERE `category` = 'economy' ORDER BY `id` DESC LIMIT 10
	//выведет на страничку 10 последних новостей по экономике
	4.5 Указание к количеству вывода - LIMIT начало, сколько всего:
	// делается через запятую, где первое число - это порядковый номер записи начиная с нуля
	// с которой начинаем вывод, а второе - это количество выводимых записей
	SELECT * FROM `users` WHERE `age` = 20 ORDER BY `id` ASC LIMIT 1, 2
	//вывести начиная со второй (1-я это ноль) и две записи
	//Пример по выборке комментариев для странички сайта:
	SELECT * FROM `comments` LIMIT 0, 5 // выберется 5 коментариев начиная с 0-го
	SELECT * FROM `comments` LIMIT 5, 5 // вывод следующих 5 комметариев и т.д.
	// после этого в чате добавляем 1 страничка, 2-я и т.д. - получился пагинатор,
	// постраничная навигация:
	$limit = 10;
	$_GET['page'] = 1; //если 'page' = 1, то выведется страница 1 (с 0 по 10 записи)
	(($_GET['page'] - 1) * $limit) = 0 // первая страница начинается с 0, так как для 1 страницы $limit=0
	//для вывода второй страницы:
	$_GET['page'] = 2;
	(($_GET['page'] - 1) * $limit) = 10 // так как $limit=10
	//для третей страницы:
	$_GET['page'] = 3;
	(($_GET['page'] - 1) * $limit) = 20 // так как $limit=20
	$count = ($_GET['page']-1)*$limit; //счетчик
	LIMIT $count, $limit
	Страница 1: 0,10
	Страница 2: 10,10
	Страница 3: 20,10
	Страница 4: 30,10
 	//итого скрипт пагинатора:
	$limit = 10;
	$count = ($_GET['page']-1)*$limit; //счетчик
	LIMIT $count, $limit
	4.6 //Подсчет количества через SQL запрос в PHP
	С помощью команды COUNT можно подсчитать количество строк в выборке.
	Давайте, например, подсчитаем всех юзеров в таблице:
	$query = "SELECT COUNT(*) FROM users"; //php
	А теперь подсчитаем всех, у кого зарплата равна 900:
	$query = "SELECT COUNT(*) FROM users WHERE salary=900"; //php

19-3 //Подитожим предудущие знания по командам для работы с БД (вкладка SQL):
	1. Добавить данные - "INSERT INTO"
	2. Отредактировать данные - "UPDATE" + WHERE
	3. Удалить данные - "DELETE FROM" + WHERE + LIMIT
	4. Выбрать данные - "SELECT" + WHERE + ORDER BY + LIMIT

19-4 //Продолжим начатое в начале урока - этапы разработки модуля:
Есть задача: создание пользователя (регистрация пользователя).
1. Создаем модуль и странички.
2. Смотрим конкурентов, создаем схему и по этой схеме создаем нужную таблицу/таблицы в БД
3. Наполнять модуль: создать HTML-таблицу + PHP-обработку для взаимодействия с БД (этот пункт изучим
на следующем уроке)
4. Тестирование работы модуля

19-5 //Домашняя работа:
Создать 13 пользователей в таблице `users`. Составить группу запросов:
1. Добавить пользователя:
	1) Петрович
	2) Yamamoto, возраст 10 лет
	3) inpost, возраст 2 года, пароль 123, email inpost@list.ru
	4) Добавить 10 произвольных пользователей с разными данными в возрасте от 18 до 40 лет
2. Отредактировать пользователя:
	1) Yamamoto => возраст исправить на 9 лет
3. Удалить данные:
	1) Удалить Петровича
4. Выбрать данные:
	1) Выбрать всех пользователей в возрасте от 20 до 25 лет и отсортировать по позрасту DESC (в обратном порядке)
	2) Выбрать пользователя inpost
	3) Выбрать 4 пользователей.

Эту домашку сохранить в php файле в таком виде:
	1.1 INSERT INTO ...
	1.2 ....


Урок 20: Форма и работа PHP с MySQL
/*План:
mysqli функции
Создаем формы на HTML
Обработка форм
Добавление данных в MySQL*/

20.1 Освежим память - 3 вида хранения данных:
	1) $var (переменные - в основном в пределах страницы или скрипта);
	2) $_SESSION (храним логины), $_COOKIE(тоже можно хранить логин, а так же поисковые запросы,
	карзину товаров, языковую раскладку сайта и тд);
	3) База данных (MySQL) (коментарии, страницы, товары, пользователи)

20.2 Работа с БД:
	1) Открытие соединения;
	2) Выполнение запроса: INSERT, UPDATE, DELETE, SELECT
	3) Закрыть соединение (выполняется автоматически с последней строчкой нашего файлика, иногда нужно
	ручное закрытие соединения, но об этом позже поговорим);

20.3 Соединение с БД - на странице index.php в разделе роутер:
mysqli_connect('HOST', 'NAME', 'PASSWORD', 'БазаДанных'); //типовое подключение
//у нас в проекте мы использовали константы в файле config.php:
define('DB_LOCAL', 'test');
define('DB_LOGIN', 'test');
define('DB_PASS', 'test');
define('DB_NAME', 'main');
//подключаем согласно наших данных:
mysqli_connect('DB_LOCAL', 'DB_LOGIN', 'DB_PASS', 'DB_NAME');
//Если сменится пользователь или расположение сайта не нужно лезть в скрипты - меняем
// в файле config.php

20.4 Указываем кодировку для передачи данных (добавляем в index.php):
//Во время присоединения БД мы получаем идентификатор БД:
$link = mysqli_connect('DB_LOCAL', 'DB_LOGIN', 'DB_PASS', 'DB_NAME');
В переменной $link будет содержаться не сама база данных, а просто ссылка и через эту ссылку будет
отправляться запрос У этой ссылки есть идентификатор соединения.
Если БД несколько, то создаем несколько ссылок на БД($link1, $link2, $link3, ...).
mysqli_set_charset($link,'utf8'); //Набор символов, который необходимо установить.

20.5 Запросы в базу данных через php:
$query = "INSERT INTO 'table' SET `key` = 'value'"; //Добавить данные в БД.
$query = 'SELECT * FROM users'; //Выбрать из БД
//Отправим этот запрос через команду mysqli_query:
mysqli_query ($link, $query);

20.6 Перехват ошибок запросов к БД
Если при внесении в БД мы допустим ошибку, то она не выведется на экран. Такая особенность БД. Например:
$res = mysqli_query ($link, "SELECT * FROM `zzz`"); //вместо `users` указали неправильное название `zzz`
var_damp($res); // выведет bool(false), потому что произошла ошибка - если нет ошибок функция возвращает true
Перехват ошибки простой - вместо var_damp($res) пишем:
if($res === false) {
	echo 'Тут была ошибка: '.mysqli_error($link);
	exit();
}

Второй вариант через die (более короткий):
$res = mysqli_query ($link, "SELECT * FROM `zzz`") or die('Тут была ошибка: '.mysqli_error($link));
Рекомендуется все запросы к БД выводить одним из этих способов.

20.7 Экранирование символов:
если хотим постиавить одинарную кавычку в коде нужно использовать экранирование (\) - обратная черта:
echo '<h1>Te'xt</h1>' - без экранирования кавычка считает закрытие кода посреди текста,
echo '<h1>Te\'xt</h1>' - так правильно (при выводе на экран \ не будет виден)

Чтобы вписать двойыне кавычки при использовании html в php и JavaScript, тоже придется использовать
экранирование:
echo "<div style = \"text-decoration:underline;\" >";
\ ставится влотную к символу, который хотим экранировать.

Для БД тоже используется экранирование:
`login` = 'Sau Pau\'lo', //в базу внестся как 'Sau Pau'lo'

В MySQLi есть команда для автоматического экранирования введенной информации:
`login` = '".mysqli_real_escape_string($link, $login)."', //с помощью этой команды нам удастся
// сохранить БД от поломки через использование экранируемых символов при регистрации логина.
`login` = '".mysqli_real_escape_string($link, "Sau P'aulo")."' '//в базу внестся как 'Sau Pau'lo'

Экранируемые символы: NUL (ASCII 0), \n, \r, \, ', ", и Control-Z. '

Там где кавычки не используем (числовые данные), то нужно использовать преобразование к типу:
`age` = .(int)$age; //тоже защита

20.8 Регистрация пользователя на сайте: // index.php?module=cab&page=registration
20.8.1 registrathion.tpl:?>
<div style="padding:100px;">
	<?php echo if(!isset($_SESSION['regok'])) { ?>
	<form action="" method="post">
		<table>
			<tr>
				<td width="90">Логин *</td>
				<td><input type="text" name="login"
						   value="<?php echo @htmlspecialchars($_POST['login']); ?>"></td>
				<td><?php if (isset($errors['login'])) {echo $errors['login'];} ?></td>
			</tr>
			<tr>
				<td>Пароль *</td>
				<td><input type="password" name="password"
						   value="<?php echo @htmlspecialchars($_POST['password']); ?>"></td>
				<td><?php @echo $errors['password']; ?></td> <!--короткая запись с глушилкой ошибок-->
			</tr>
			<tr>
				<td>E-mail *</td>
				<td><input type="email" name="email"
						   value="<?php echo @htmlspecialchars($_POST['email']); ?>"></td>
				<td><?php if (isset($errors['email'])) {echo $errors['email'];} ?></td>
			</tr>
			<tr>
				<td>Возраст</td>
				<td><input type="text" name="age"></td>
				<td></td>
			</tr>
		</table>
		<p style="font-size:10px;">* - поле обязательное для заполнения</p>
		<input type="submit" name="sending" value="Зарегистрироваться">
	</form>
	<?php } else { unset($_SESSION['regok']); ?>
	<div>Вы успешно зарегистрировались на сайте!</div>
	<?php } ?>
</div>
<?php
20.8.2 //Вносим логику в registrathion.php:
//обработка регистрации:
if(isset($_POST['login'], $_POST['email'], $_POST['password'])) {
	$errors = array ();
	if(empty($_POST['login'])) {
		$errors['login'] = 'Вы не заполнили логин';
	}
	if(empty($_POST['password'])) {
		$errors['password'] = 'Вы не заполнили пароль';
	}
	if(empty($_POST['email']) || !filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) {
		$errors['email'] = 'Вы не заполнили email';
	}
	if(!count($errors)) {
		mysqli_query($link, "
		INSERT INTO `users` SET
		`login` = '".mysqli_real_escape_string($link, $_POST['login'])."',
		`password` = '".mysqli_real_escape_string($link, $_POST['password'])."',
		`email` = '".mysqli_real_escape_string($link, $_POST['email'])."',
		`age` = ".(int)$_POST['age']."
		") or exit(mysqli_error($link)); //вывод ошибок БД
	$_SESSION['regok'] = 'OK';
	header("Location: /index.php?module=cab&page=registration");
	exit();
	//выполняем какие-то действия
	}
}

20.8.3 Чтобы данные из полей при неверном введении не вводить заново то в input добавляем следующее:
value="<?php echo @$_POST['login']; ?>">

20.8.4 XSS-inj - хакерский взлом логина(уязвимость полей форм):
если ввести в поле логин надпись te<">text<b>text   "- в таком случае за края формы вылезет текст:
texttext''> - значения из переменной $_POST будут выводиться на страницу.
Чтобы этого не происходило добавляем в параметр value функцию htmlspecialchars:
value="<?php echo @htmlspecialchars($_POST['login']); ?>"> //функция экранирует, подменяет одни символы другими
С помощью этой функции мы не запрещаем использовать определенные символы, но они уже не ломают нам систему.

20.8.5 Очистка данных: если человек успешно внес данные и получил надпись об успешной регистрации, нажмет F5
(обновит страницу), то эта запись повторно внесется в БД и создаст дубликат.
Для этого нужно сделать после регистрации переадресацию на другую страницу (можно и на эту же)

20.9 Домашняя работа:
Очень простое задание, по аналогии сделать страницу на подобии отзывов и туда добавить форму добавления
комментариев. В свою очередь так же сделать обработку входящих данных. Кроме этого для textarea изучить
функцию на PHP: nl2br.
Необходимо делать вместе с домашкой к 21-ому уроку.

 Дополнение к домашке: Создать безопасную форму регистрации пользователя и вывод всех зарегистрированных
пользователей.  Не должно быть SQL-inj или XSS-inj. Перечень тестовых логинов без кавычек: "<b>inpost</b>",
"O'Henr''y", "Vo&quot;va", "Правда 1%", "ОбычныйUserId#1","x&*5!@#$%^*&?"," \ \ YE / / ","%%%%","\\","////".


Урок 21: Выборка из БД и вывод на экран
/*План:
PHP + MySQLi + SELECT*/

21.1 Вывод массива на экран по элементно:
Расмотрим БД в виде массива c подмассивами:
$users = array(
		1 => array (
				'id' => 4,
				'login' => 'inpost',
				'password' => '123',
				'email' => '123@mail.ru',
				'age' => 27,
		),
		2 => array (
				'id' => 5,
				'login' => 'Vasya',
				'password' => '234',
				'email' => 'vasya3@mail.ru',
				'age' => 20,
		),
		3 => array (
				'id' => 10,
				'login' => 'Petya',
				'password' => 'qweqr',
				'email' => 'petya@mail.ru',
				'age' => 17,
		),
		4 => array (
				'id' => 77,
				'login' => 'Masha',
				'password' => '1111',
				'email' => '1111@mail.ru',
				'age' => 18,
		),
		5 => array (
				'id' => 150,
				'login' => 'Dasha',
				'password' => '0000',
				'email' => 'dasha@mail.ru',
				'age' => 18,
		),
);
//Воспользуемся нашей функцией wtf из папки libs
wtf($users); // выведется наш массив в виде 5 элементов
//переберем массив циклом foreach, где $k = это наши ключи (1, 2, 3, 4, 5), $v = array (...) - массив
//Сейчас попробуем распечатать каждый из этих массивов ($k):
foreach($users as $k=>$v) {
    echo '<div>Запись №'.$k.'<br>';
    echo '<div>Идентификатор пользователя №'.$v['id'].'<br>';
    echo 'Имя пользователя: '.$v['login'].';<br>
        Его возраст:'.$v['age'];
    //wtf($v, 1); //1 передаем, чтобы скрип не остановился.
    echo '</div>';
}
exit();

21.2 Вытягиваем данные из БД - mysqli_fetch_assoc:
//Сделаем выборку одной записи из таблицы users:
$res = mysqli_query($link, "SELECT * FROM `users` ORDER BY `id` LIMIT 1") or exit(mysqli_error());
$row = mysqli_fetch_assoc($res); //достаем из таблицы выбранную запись, помещает результат из $res в $row.
//wtf($row); //проверочный ввывод на экран через функцию
echo $row['login']; // напишет "Петя"
exit();

21.3 Получаем количество строк в наборе результатов - mysqli_num_rows:
//Обращение к БД, которые выводят пустой результат, для этого осуществляем
//поиск учетных записей с возратом пользователя больше 100 лет:
$res = mysqli_query($link, "SELECT * FROM `users` WHERE `age` > 100") or exit(mysqli_error());
echo mysqli_num_rows($res); //0 - функция подсчета количества выбранных выводов из таблицы

//Проверка циклом вместо echo:
$res = mysqli_query($link, "SELECT * FROM `users` ORDER BY `id` LIMIT 10") or exit(mysqli_error());
if(mysqli_num_rows($res)){ //если больше нуля (true)
	echo 'Всего'.mysqli_num_rows($res).' записей<br>';
	while ($row = mysqli_fetch_assoc($res)) {// перебираем циклом все значения
		echo '<div>Сушествует пользователей: '.htmlspecialchars($row['login']).'</div>';
		//div добавляем чтобы каждый результат отображался с новой строчки
	} // как только дойдем до 11 записи (у нас лимит 10 стоит) итерация завершится - 10 раз выведем все 10
	// пользователей
} else {
	echo 'Нет записей по данному запросу';
}
exit();

//Вывод списка всех пользователей на сайте:
$res = mysqli_query($link, "SELECT * FROM `users` ORDER BY `id`") or exit(mysqli_error());
if(mysqli_num_rows($res)){
	echo 'Всего у нас на сайте'.mysqli_num_rows($res).' пользователей зарегистрировано<br>
	А именно: <ul>
	';
	$i = 0;
	while ($row = mysqli_fetch_assoc($res)) {
		//if(++$i == 10) { //можно и так писать переменную через условие
		echo '<li>'.(int)++$i.'. '.htmlspecialchars($row['login']).'</li>';
		//++$i; - Переменная увеличивается на 1
		//$i++ - Запоминается старое и новое значение до окончания действия, и в конце увеличивается!
	}
	echo '</ul>';
} else {
		echo 'Нет записей по данному запросу';
}
exit();

Урок 22: Редактирование и удаление данных. 1 Модуль CMS
/*План:
PHP + MySQLi + UPDATE + DELETE
Изучаем создание полноценного модуля в админке по добавлению, редактированию и удалению информации на сайте*/

22.1 CMS - это система управления сайтом/данными
Основные функции:
1) Вывод на экран
2) ДОбавление
3) Редактирование
4) Удаление
 Вывод/просмотр доступен обычным пользователям, а остльные три - админам из админки.

phpMyAdmin - это тоже CMS, но для разработчиков.
Для модераторов права нужно урезать, чтобы не удаляли пользователей или не меняли даты сообщений и прочее.
Поэтому админка для модераторов с другим функционалом.
Обычным пользователем/жураналистам тожде можно дать доступ, но с еще более урезанным функционалом.

22.2 Ограничение доступа к странице
Мы раньше учили в 16 уроке авторизацию. Блокировка доступа через куки:
if(!isset($_COOKIE['access'])) {
exit();
}

22.3 Блок новостей:
22.3.1 Создаем папки и файлы main.**
./modules/news/main.php // контроллер - обработка
./skins/default/news/main.tpl //вид - вывод на экран

Самый главный файл на сайте - то main, при таком условии мы попадем на main:
indes.php?module=news

22.3.2 Создаем таблицу в базе данных под новости:
id - INT -PRIMARY
date - DATETIME
title - TEXT
cat - VARCHAR - 255 //категория
text - TEXT
description - TEXT  //краткое описание для главной страницы - превью
meta_title - TEXT //для SEO
meta_keywords - TEXT // ключевые слова для SEO
meta_description - TEXT //для SEO
status - //0 - не ободрено, 1 одобрено для вывода на сайте
Таблица: InnoDB
сравнение: utf8_unicode_ci

22.3.3 main.php: (00:29:57)
Создаем запрос:
$news = mysqli_query($link, "
	SELECT *
	FROM `news`
	ORDER BY `id` DESC
");

22.3.4 main.tpl (00:31:55)
//Выводим названия новостей циклом:
<div style="padding-top:20px; padding-bottom:20px">
<p> Все существующие новости </p>
<?php while($row = mysqli_fetch_assoc($news)) { ?>
<div>
	<div><b><?php echo $row['title']; ?></b> <!--вывод заглавия-->
		<span style="color:#5c636a; font-size:10px;"><?php echo $row['date'] ?></span><!-- и даты, серым-->
    </div>
</div>
<?php } ?>
</div>

Добавление новости у нас будет по кнопке:
<a href="/index.php?module=news&page=add">Добавить новую новость</a>  <!--у меня в проекте вместо page будет action-->

<?php
22.3.5 Создаем в папке 'news' файлы add.php(в модуле) и add.tpl(в статике)

22.3.5.1 add.tpl: //?module=news&page=add
?>
<div>
	<form action="" method="post">
		<input type="text" name="" value="">
			<div>
				Заголовок новости *: <input type="text" name="title"> <!--проверяем на ошибку вывода заголовка
				из позапрошлого урока, доделать самому-->
			</div>
			<div>
				Категория новости: <input type="text" name="cat">
			</div>
			<div>
				Описание новости:
				<textarea name="description"></textarea> <!--name соотвествует разделу в БД-->
			</div>
			<div>
				Полный текст новости:
				<textarea name="text"></textarea> <!--name соотвествует разделу в БД-->
			</div>
		<input type="submit" name="add" value="Добавить новость">

	</form>
</div>
<?php
22.3.5.2 add.php: //Делаем проверку на существование постов и пишем наш код обработки:
Функция trim() - обрезает строку, удяляя лишние пробелы в начале и конце строки, в скобках после переменной можно
по желанию указать какие еще символы мы хотим удалить.
Есть три варианта использования trim():
1) у условии if
2) прогнать $_POST через trim() с помощью цикла foreach
3) внутри функции mysqli_query
Выбирается один из этих способов:
if(isset($_POST['add'], $_POST['title'], $_POST['text']=trim($_POST['text']), $_POST['cat'], $_POST['description'])) {
	//echo 'Форма нормально отправилась'; //проверка - если все значения поста правильно записаны, то выведется
	//exit(); //если все норм то стираем и пишем дальше
		foreach($_POST as $k=>$v) {
		$_POST[$k] = mysqli_real_escape_string(trim($v)); //двумя функциями сразу пост прошлись
	// так мы все значения $_POST[''] обрезаем и не нужно каждое отдельно
	//если тут использовали mysqli_real_escape_string, то ниже можно не использовать, но Стас советует использовать
// в mysqli_query, а не в цикле, чтобы видеть применили мы mysqli_real_escape_string или нет и случайно не пропустили
		}
	mysqli_query($link, "
		INSERT INTO `news` SET
		//запрос можно стилизировать пробелами:
		//trim можно и сюда вставить:
		`cat` 		  = '".mysqli_real_escape_string($link, trim($_POST['cat']))."',
		`title` 	  = '".mysqli_real_escape_string($link, trim($_POST['title']))."',
		`text` 		  = '".mysqli_real_escape_string($link, trim($_POST['text']))."',
		`description` = '".mysqli_real_escape_string($link, trim($_POST['description']))."',
		`date`        = NOW() //ставит сегодняшнюю дату аналог настроке в MySQLi
	") or exit(mysqli_error());
	$_SESSION['info'] = 'Запись была добавлена'; //уведомление пользователя, что его новость была добавлена
	header('Location: /index.php?module=news'); //переадресацию на главную страничку на main
	exit();
}

22.3.5.2.1 Этот цикл проверки можно вынести в variables.php, чтобы ее  каждый раз не писать:
if(isset($_POST) && count($_POST)) {
	foreach($_POST as $k=>$v) {
	$_POST[$k] = mysqli_real_escape_string(trim($v));
}

Функция mysqli_real_escape_string() - экранирует кавычки и слеши.
Входящие параметры: 1.ССылка на коннект, 2. Переменная, которую необходимо экранировать
Выходящие параметры: экранный текст

22.3.5.3 main.php: (00:48:25)
//делаем проверку если сессия
if(isset($_SESSION['info'])) {
	$info = $_SESSION['info']; //передаем содержимое сессии в переменную инфо
	unset($_SESSION['info']); //удаляем сессию за ненужностью.
}

22.3.5.4 main.tpl:
if (isset($info)) { ?> //вывело, что запись была добавлена и сделало переадресацию
	<h1><?php echo $info; ?></h1>
<?php } ?>

<?php
22.3.5.5 Теперь добавление новостей уже должно работать. Делаем проверку. Модуль добавления новостей готов.
Осталось сделать модуль удалению и модуль редактирования новостей.

22.4 Удаление записей (1:20:00)
22.4.1 main.php:
//Первый вариант удаления через цикл foreach после нажатия кнопки($_POST['delete']):
if (isset($_POST['delete'])){
//wtf($_POST['ids']); первоначальная проверка, что попадает в $_POST['ids'] - этот вариант не самый оптимальный
//так как если отмеченно 3 checkbox, то в БД будет отправлено 3 запроса на удаление последовательно
	foreach($_POST['ids'] as $k=>$v) {
		mysqli_query($link,"
		DELETE FROM `news`
		WHERE `id` = ".(int)$v."
	");
	}
}
//Второй вариант - отправка запроса на удаление одним запросом:
// Функция implode говорит, что мы по определенному символу, у нас запятая, объединяем массив и на выходе
// получаем обычную строку. Вместо ',' можно использовать '</tr><tr>',чтобы получить колонки
if (isset($_POST['delete'])){
		//циклом прогоняем массив, чтобы привести его к типу число (int):
		foreach($_POST['ids'] as $k=>$v) {
		$_POST['ids'][$k]
		= (int)$v;
		}
		//wtf($_POST['ids'],1); //выведет на экран массив
		$ids = implode(',', $_POST['ids']);
		//wtf($ids); // выведет на экран 3, 2, 1
		mysqli_query($link,"
			DELETE FROM `news`
			WHERE `id` IN ".$ids."
		") or exit(mysqli_error());
}
//Каждый отмеченый checkbox добавляет цифры в массив:
//$_POST['ids'] = array(3,2,1);

if(isset($_GET['action']) && $_GET['action']=='delete'){
	mysqli_query($link,"
		DELETE FROM `news`
		WHERE `id` = ".(int)$_GET['id']."
	") or exit(mysqli_error());
	$_SESSION['info'] = 'Новости были удалены';
	header("Location: /index.php?module=news");
	exit();
}


22.4.2 main.tpl - теперь будет выглядеть так: ?>
<div>
	<?php if (isset($info)) { ?>
		<h1><?php echo $info; ?></h1>
    <?php } ?>

<a href="/index.php?module=news&page=add">ДОБАВИТЬ НОВУЮ НОВОСТЬ</a>
<br>
Все существующие новости:
	<form action="" method="post">
		<?php while(?row=mysqli_fetch_assoc($news)) { ?>
			<div>
				<div><input type="checkbox" name="ids[]" value="<?php echo $row['id']; ?>">
					<a href="/index.php?module=news&action=delete&id=<?php echo $row['id']; ?> ">УДАЛИТЬ</a>
                    <!--action - это действие делете, перехват события-->
					<b><?php echo $row['title']; ?></b>
					<span><?php echo $row['date']; ?></span>
				</div>
			</div>
			<hr>
		<?php } ?>
		<input type="submit" name="delete" value="Удалить отмеченные записи">
	</form>
</div>

<?php
22.4.3 variables.php
//временно закомментим - в последующих уроках ее немного изменим
//обработка трима сделать в add.php
/*if(isset($_POST) && count($_POST)) {
    foreach ($_POST as $k => $v) {
        $_POST[$k] = trim($v);
    }
}*/

22.5 Редактирование новостей (01:44:03)
22.5.1 main.tpl (добавим строчку радактирования новости)
<div>
<?php if (isset($info)) { ?>
<h1><?php echo $info; ?></h1>
<?php } ?>

<a href="/index.php?module=news&page=add">ДОБАВИТЬ НОВУЮ НОВОСТЬ</a>
<br>
Все существующие новости:
<form action="" method="post">
    <?php while(?row=mysqli_fetch_assoc($news)) { ?>
	<div>
		<div><input type="checkbox" name="ids[]" value="<?php echo $row['id']; ?>">
			<a href="/index.php?module=news&page=edit&id=<?php echo $row['id']; ?>">ОТРЕДАКТИРОВАТЬ</a>
			<a href="/index.php?module=news&action=delete&id=<?php echo $row['id']; ?> ">УДАЛИТЬ</a>
			<b><?php echo $row['title']; ?></b>
			<span><?php echo $row['date']; ?></span>
		</div>
	</div>
<hr>
    <?php } ?>
	<input type="submit" name="delete" value="Удалить отмеченные записи">
</form>
</div>

<?php
22.5.2 edit.php
if(isset($_POST['ok'], $_POST['title'], $_POST['text'], $_POST['cat'], $_POST['description'])) {
	foreach($_POST as $k=>$v) {
		$_POST[$k] = mysqli_real_escape_string(trim($v));
	}
	mysqli_query($link, "
		UPDATE INTO `news` SET
		//запрос можно стилизировать пробелами:
		//trim можно и сюда вставить:
		`cat` 		  = '".mysqli_real_escape_string($link, trim($_POST['cat']))."',
		`title` 	  = '".mysqli_real_escape_string($link, trim($_POST['title']))."',
		`text` 		  = '".mysqli_real_escape_string($link, trim($_POST['text']))."',
		`description` = '".mysqli_real_escape_string($link, trim($_POST['description']))."',
		`date`        = NOW() //если эту строчку убрать, то дата сменится на дату при редактировании
		WHERE `id` = ".(int)$_GET['id']."
	") or exit(mysqli_error());
$_SESSION['info'] = 'Запись была изменена';
header('Location: /index.php?module=news');
exit();
}

$news = mysqli_query($link,"
	SELECT *
	FROM `news`
	WHERE 	`id` = ".(int)$_GET['id']."
	Limit 1
	") or exit(mysqli_error());

if(!mysqli_num_rows($news)) {
	$_SESSION['info'] = 'Данной новости не существует!';
	header("Location: /index.php?module=news&page=news");
	exit();
}

$row = mysqli_fetch_assoc($news);
//wtf($row); //видим нашу новости в виде массива

if(isset($_POST['title'])) {
	$row['title'] = $_POST['title'];
}

22.5.3 edit.tpl  (01:55:34)
Тут у нас будет форма точно такая же как в add.tpl , только нужно добавить чтобы редактируемая новости подставилась
в поля формы, чтобы было что редактировать ?>
<div>
	<form action="" method="post">
		<input type="text" name="" value="">
		<div>
			Заголовок новости *: <input type="text" name="title" value="<?php echo htmlspecialchars($row['title']); ?>">
		</div>
		<div>
			Категория новости: <input type="text" name="cat" value="<?php echo htmlspecialchars($row['cat']); ?>">
		</div>
		<div>
			Описание новости:
			<textarea name="description"><?php echo htmlspecialchars($row['description']); ?></textarea>
		</div>
		<div>
			Полный текст новости:
			<textarea name="text"><?php echo htmlspecialchars($row['text']); ?></textarea>
		</div>
		<input type="submit" name="ok" value="Редактировать  новость">

	</form>
</div>

<?php
22.6 Домашняя работа
По такой же аналогии работают интернет магазины, где используется добавление, редактирование и удаление товаров.
В домашней работе сделать по аналогии с новостями управление товарами. Нам необходима простая категория, тоже самое
как выше указывали категорию, только сделать ее не через текст, не через инпут, а через <select>, то есть в <select>
(способ выбора) будет указано какие варианты можно выбрать (либо холодильники, либо телевизоры).
Нужно сделать раздел товары (goods)
Подсказка по <select> - чтобы запомнить предыдущий выбор option в селекте мы пишем:
<option selected="selected">
дальше через if проверяем если в $row находится наш выбор, то пишем селектед=селектед, если нет - не пишем.
Дальше по второму выбору если да, то все так же


Урок 23: Собственные функции, функция-оболочка, рекурсия
/*План:
mysqli оболочка
Пишем свои функции
Рекурсионный вызов функций
array_map*/

23.1 Функция в функции.
23.1.1 Функция распечатка:
function printR($var) {
    echo '<pre>';
    print_r($var);
    echo '</pre>';
}
$array = array(1,2,3);

//теперь используем ее:
printR($array);

23.1.2: (00:17:55) Функция работы с запросом и дебаг ошибок
для отображения правильного ошибок нужно:
Перед mysqli_connect прописать:
mysqli_report(MYSQLI_REPORT_OFF);
Начиная с PHP 8.1 работа немного изменилась, сейчас перехватить нельзя, сразу Fatal Error кидает без этой настройки.

(!) Итого файл 'db_config' уже должен выглядеть так:
mysqli_report(MYSQLI_REPORT_OFF);
$link = mysqli_connect(DB_HOST, DB_LOGIN, DB_PASS, DB_NAME);
mysqli_set_charset($link,'utf8');

//Пишем функцию оболочку для запроса:
$result = mysqli_query($link, "SELECT * FROM `comments`");
23.1.2.1 //функция
function q($link, $query) {
    //var_dump (mysqli_query($link, $query)); // посмотрим, что вернет функция
    return mysqli_query($link, $query);
    if($result === false) {
        echo 'Была ошибка';//дебаг
        exit(); //остановим код
    } else {
        return $result; // запрос составлен верно, то вернем на страницу $result
    }
}
//Используем ее:
$result = q($link, "SELECT * FROM `comments`");
//mysqli_query возвращает результат только в том случае, если запрос произошел без ошибок,
// если запрос произошел с ошибками - вернет false, то есть запрос небыл успешен:
var_dump($result);

В этой функции просто покажет сообщение об ошибке. Для того, чтобы знать из-за чего ошибка используем:
or exit(mysqli_error());

23.1.2.2 //измененная функция - улученный вывод сообщения об ошибке:
function q($link, $query) {
//var_dump (mysqli_query($link, $query)); // посмотрим, что вернет функция
    return mysqli_query($link, $query);
    if($result === false) {
        echo "Запрос: ".$query.'<br>'.mysqli_error($link);//дебаг(перехват ошибки)
        exit(); //остановим код
    } else {
        return $result; // запрос составлен верно, то вернем на страницу $result
    }
}
//С помощью этой функции мы избавимся от необходимости дописывать каждый раз проверку ошибок 'or exit(mysqli_error());'

23.1.2.3 //Записываем вывод ошибки в логи, а не на экран пользователя, уведомление на email:
function q($link, $query) {
    $result = mysqli_query($link, $query);
    if($result === false) {
        //$info = debug_backtrace();
        //wtf($info);//распечатка ошибки на экран
        $error = "query: ".$query."<br>\n".mysqli_error($link);//дебаг(перехват ошибки)
        //отправляем на почту письмо об ошибке (учить будем это в последующих уроках)
        //записываем ошибку в логи:
        file_put_contents('./logs/mysql.log', strip_tags($error)."\n\n", FILE_APPEND);
        echo $error;
        exit(); //остановим код
    } else {
        return $result; // запрос составлен верно, то вернем на страницу $result
    }
}
//У нашей функции один недочет - она не указывает на какой строчке была ошибка и в каком файле.
(00:43:04) //Для этого добавим в функцию новую функцию debug_backtrace();

23.1.2.4 Домашнее задание №1 - улучшить эту функцию (00:46:00)
Нужно сделать красивое оформление ошибок
Добавить вывод в сообщение об ошибке название файла и №строчки, остальное нам ненужно пока-что
Так же добавить дату создания ошибки - функция date("Y-m-d H:i:s");
Проверить добавляя в запросы лишние буквы

23.1.2.5 GLOBALS['']
Все переменные дублируются в глобальный массив GLOBALS[''], поэтому учитывая это можно еще сократить
нашу функцию:
//первый вариант:
function q($query) {
    $link = GLOBALS['link']; //делаем переменную $link видимой внутри функции
    $return = mysqli_query($link, $query);
//и так дальше - это часть кода - $link перенесли из условия внутрь функции

//второй вариант:
function q($query) {
    global $link; //получаем тот же эффект
    $return = mysqli_query($link, $query);
    //...

23.1.2.6 Добавить эту функцию в наш сайт в папку libs/default.php

23.1.2.7 Создаем mysql.log (00:53:50)
Функция записи ошибки в файл (00:57:12)
file_put_contents( //Пишет данные в файл
    './logs/mysql.log', //путь к файлу - адресс лога
    strip_tags($query).// содержание - функция удаляет теги HTML и PHP из строки (в нашем случае из запроса)
    "\n\n", // перенос строки
    FILE_APPEND); // дописывает новые логие, после предыдущих, без перезаписи

23.1.3 Функция myInclude: (01:01:45)
function myInclude() {
    if(file_exists()) {
        include ...
    } else {
        file_put_contents('./logs/mysql.log', strip_tags($error)."\n\n", FILE_APPEND);
        //отправка ошибки в файл
        exit();
    }
}

23.2 Новые Функции (01:13:27)
23.2.1 file_put_contents - Пишет данные в файл, достает контент из файла (мы изучили выше)
23.2.2 file_get_contents - Читает содержимое файла в строку, возвращает содержание файла (альтернатива,
из настроек только путь к файлу)

$var = file_get_contents('./logs/mysql.log'); //выведет на экран содержимое файла лога

23.2.3 file_exists('./logs/mysql.log'); // проверяет путь к файлу и возвращает true или false
if(file_exists('./logs/mysql.log')) {
    //делаем к нему запрос
}

23.2.4 trim(); - обрезает строку удаляя в начале и конце пробелы.

23.2.4.1 Нужно запомнить, что применении этой функции к массиву вложенному в массив, то эта функция только обрежет
только пробелы у массива первого уровня, а у второго нет.
Для этого нужно повторно использовать цикл foreach для вложенного в массив массива:
foreach($array as $k=>$v) {
    if(is_array($v)) {
        foreach($v as $k2 = $v2) {
            $array[$k][$k2] = trim($v2);
        }
    } else {
        echo $k.'=>'.$v.'<br>';
        $array[$k] = trim($v);
    }
}
wtf($array);
Такой принцип построения функции называется "рекурсия". //Из википедии: "Реку́рсия — определение, описание,
// изображение какого-либо объекта или процесса внутри самого этого объекта или процесса, то есть ситуация,
// когда объект является частью самого себя."

23.2.4.2 Функцию foreach для массива такого вида:
foreach($array as $k=>$v) {
    $array[$k] = trim($v);
}
Можно сократить используя стандартную функцию:
$array = array_map('trim', $array);
С функцией array_map можно вместо 'trim' применять и другие функции, напрмер 'cube' возведет все элементы массива в куб
Функция array_map - проганяет весь массив и обрабатывает какими-то действиями

23.2.4.3 Теперь создадим функцию с trim():
function trimAll($elem) {
    if(!is_array($elem)) { //если это не массив
        $elem = trim($elem); //то мы его обработаем тримом
    } else {
        $elem = array_map('trimAll', $elem); // делаем замыкание функции смой себя и каждый раз залазит глубже в массив
    }
    return $elem; //массив не будем трогать
}
//После прохождения выдает чистый массив без пробелов в начале и конце каждого значения массива

Пример использования:
$array = trimAll($array);

23.2.4.4 Домашнее задание №2
По этому принципу можно сделать функции, которые будут выполнять приведение к типу:
int, float, ...
делать обработку: mysqli_real_escape_string (для этой функции нужно будет применить global)
И еще htmlspecialchars (подсказка: 01:36:17 - тут и другие примеры функций):
function hsc($data) {
    if(is_array($data)) {
        $data = array_map('hsc', $data);
    } else {
        $data = htmlspecialchars ($data);
    }
    return $data;
}

23.2.4.5 Домашнее задание №3 (01:40:17)
Прочитать про следующие функции на php.net:
mb_stripos//Регистронезависимый поиск позиции первого вхождения одной строки в другую,
mb_strlen//Получает длину строки,
mb_strtolower//Приведение строки к нижнему регистру,
mb_strtoupper//Приведение строки к верхнему регистру,
str_replace//Заменяет все вхождения строки поиска на строку замены,
explode//Разбивает строку с помощью разделителя,
implode//Объединяет элементы массива в строку,
strip_tags//Удаляет теги HTML и PHP из строки

23.2.4.6 Добавить в файл .htaccess строчки:
AddDefaultCharset UTF-8
php_flag display_errors ON
php_value mbstring.internal_encoding UTF-8
php_flag magic_quotes_gpc off
php_flag magic_quotes_rubtime off
php_flag register_globals off


Урок 24: Классы, autoload, и класс отправки писем (2022-05-28)
/*План:
Классы
autoload
отправка писем
mail*/
//lesson24a (вступление по классам), lesson24b (основная часть)

24.1 Классы (24b 00:01:00)
Класс - это набор свойств и методов для реализации поставленной задачи.
Классы программисты создают один раз и потом ими всю жизнь пользуются на разных проектах/сайтах, меняя только
настройки (свойства класса).
Названия класса всегда начинается с Заглавной буквы, дальше верблюжий стиль.
Под каждый класс создается новый файл с именем класса: class_Mail.php
Классы имеют тип объект(object).
Классы сами по себе не являются ООП, но на них строится ООП.

24.1.0.1 Подключение класса:
include './libs/class_Mail.php'; //в main.tpl

24.1.0.2 Чтобы все классы не находились в памяти постоянно используется аутолоад (по мере
необходимости подгружает классы) - spl_autoload_register (до патча 8.0 использовался синтаксис
__autoload):
spl_autoload_register(function ($class) { //пишется в ядро - default.php
    include './libs/class_'.$class .'.php';
});

24.1.1 Шаблон:
class MyName1 {
    static $opacity = 100; // ПЕРЕМЕННЫЕ внутри класса называются - СВОЙСТВАМИ!
    static $size =30;
static function makeLine1 { //ФУНКЦИИ внутри класса называются - МЕТОДЫ!
        echo 'test'...
    }
static function makeLine2 {
    ...
    }
}
echo MyName1::$opasity; //класс ссылается на переменную - выведет 100.
echo MyName1::makeLine1(1, 5151); //класс ссылается на функцию класса

24.1.1.1 Оператор разрешения области видимости (::) (из php.net)
Оператор разрешения области видимости (также называемый "Paamayim Nekudotayim") или просто "двойное двоеточие"
- это лексема, позволяющая обращаться к статическим свойствам, константам и переопределённым свойствам или
методам класса.
При обращении к этим элементам извне класса, необходимо использовать имя этого класса.
Можно обратиться к классу с помощью переменной. Значение переменной не должно быть ключевым словом (например,
self, parent или static).
"Paamayim Nekudotayim" на первый взгляд может показаться странным словосочетанием для обозначения двойного двоеточия.
Однако, во время создания Zend Engine версии 0.5 (который входил в PHP3), команда Zend выбрала именно это обозначение.
Оно на самом деле означает "двойное двоеточие" - на иврите!


24.1.2 : Методы (Функции класса) делятся на 4 вида: (24b 00:06:50)
1) static (статические) - к ним мы можем ссылаться из любой точки кода. Статические функции и переменные
видны из других функций и классов, у них глобальная область видимости, так же как и у POST, GET,
сессий. На static ссылаемся через self::$var. Так как статические методы вызываются без создания экземпляра класса,
то псевдопеременная $this недоступна внутри статических методов. Доступ к статическим свойствам осуществляется
с помощью оператора разрешения области видимости (::), и к ним нельзя получить доступ через оператор объекта (->).
2) public (публичный) (24b 00:40:00) - можем менять значения и выводить значения.
На public ссылаемся через $this->var; (синтаксис отличается - внимание на $)
3) private - мы не можем менять переменные как в public, выдаст ошибку. Делается для того, чтобы с переменной мы
работали только внутри класса.
4) protected -

24.1.3.1 Класс на примере пагинатора (24b 00:10:17)
//1-й вариант для VIEW
class Paginator {
    static $howpage = 9; //количество страниц в пагинаторе для отображения
    static $shownumber = true; //количество страниц через котрые перепрыгнет при нажатии NEXT
    static $shownext = true; //отображение NEXT

    static function showPaginator() {
        echo '1,2,3,4';
    }
}
//Использование в tpl папка static:
Paginator::showPaginator();

//2-й вариант для контроллера
class Paginator {
    static $howpage = 9; //количество страниц в пагинаторе для отображения
    static $shownumber = true; //количество страниц через котрые перепрыгнет при нажатии NEXT
    static $shownext = true; //отображение NEXT

    static function showPaginator() {
        return '1,2,3,4'; //
    }
}
//Использование в php папка modules:
$pages = Paginator::showPaginator();

24.1.3.2 Использование одного класса пагинатора на разных страницах с разными настройками (24b 00:15:10)
В таком случае переназначаем свойство:
Paginator::$howpage = 5; //для это страницы будет вместо стандартных 9 выводиться 5 страниц
Paginator::$shownext = false; // для это страницы NEXT будет скрыто
$pages = Paginator::showPaginator();

еще можно внутри метода(функции) менять свойства:
static function showPaginator() {
    self::$shownext = false
}

24.2 Настройка нашего ядра через классы (24b 00:25:00)
24.2.1 config.php
У нас все настройки содержатся в константах - define ();
define('CREATED',2022);
define('SKIN','default');//это константа для смены скинов, если будет еще скины вдруг
define('ADMINLOGIN', 'Roman'); //и так далее

Но можно от этого избавиться использовав класс. Этот класс назовем ядро
class Core {
    static $CREATED    = 2022; //можно пробелами выравнивать в столбик, без табов!
    static $SKIN       = default;
    static $ADMINLOGIN = Roman;
    static $ADMINEMAIL = roma@gmail.com;
...
}
Получился псевдомассив, класс с набором переменных

Если в другом месте захотим сослаться на нашу переменную, то укажем:
echo Core::$SKIN;

24.2.2 'db_config.php' будет выглядеть так:
$link = mysqli_connect(Core::$DB_HOST, Core::$DB_LOGIN, Core::$DB_PASS,Core::$DB_NAME);

24.2.3 'index.php'
include '/skins/'.SKIN.'/index.tpl';
меняем на:
include '/skins/'.Core::$SKIN.'/index.tpl';

24.3 Экземпляры класса (24b 00:29:08)
Если у нас появляется необходимость использования в одном проекте один и тот же класс с разными настройками,
то на помощь придет создание экземпляров класса:
class Illustrator{
    public $radius = 10;
    public function makeGraphic() {
        echo $this->radius;
    }
    public function test() {
        $this->test(); //может ссылаться сам на себя, создавать рекурсию (в выпадающей полдсказке видно)
    }
 }
//Использование - если свойство public, то в экземплярах меняем через свойства:
$ill1 = new Illustrator;
//echo Illistrator::$radius; // синтаксис для статик (тут для сравнения)
echo $ill1->radius=33; // синтаксис для приват - выведет на экран 33, хотя по умолчанию стоит 10

$ill2 = new Illustrator;
echo $ill2->radius=5; // выведет на экран 5
//внутри каждого такого экземпляра будет содержаться полная копия класса и они будут сущенствовать независимо
//друг от друга

Стоит учесть, что экземпляр класса ($ill1, $ill2) пренадлежит не константе, это переменная, а область видимости
переменной закрытая, эти переменные внутри других функций уже не видны.

24.3.2 Смешение public и privat
Если у нас в классе свойство(переменная) приватное, а метод(функция) паблик, то синтаксис такой уже:
class Illustrator{
    privat $radius = 10; //внутри класса можем ссылаться, а за пределами нет
    public function makeGraphic() {
        $this->test(); //тут на приватную функцию можно ссылаться, так как в пределах класса.
        echo $this->radius;
    }
    public function changeRadius($radius) { //функция специально создана для изменения свойства $radius
    $this->radius = $radius; //
    }
    private function test() {

    }
}
//Использование тоже получает другой синтаксис:
$ill1->changeRadius(5); //меняем теперь через метод
$ill2->changeRadius(33);
//во второй функции класса изменений нет, поэтому пишем в таком синтексисе:
$ill1->makeGraphic();
$ill2->makeGraphic();

$ill1->test(); //это ошибка, так как метод (функция) приват, но мы можем ссылаться на нее к примеру внутри
//другой функции класса (в примере в makeGraphic)

Зачем переменные делают приватными? Иногда появляется потребность, чтобы не все переменные были доступны таким вот
образом. То же касается и приватных методов.
Правило(не всего поддерживают): абсолютно все свойства и все методы писать приватными, КРОМЕ тех, с которыми
наше приложение должно работать. Если какой-то метод внутри класса является вспомогательным, то он только приватным
должен быть.

24.3.3 Добавление свойств (перменных) внутри класса: (24b 00:55:00)
$test = new Illustrator;
$test->lala='Эксперимент';
var_dump($test);
//при выводе уже увидим, что к классу добавилась новая переменная

24.4 Создаем класс для почты(папка libs/class_Mail.php) (24b 01:31:10)
Сам PHP не рассылает письма, он создает файл в формате *.eml и этот файл копирует в папку sendmail.
Апач нам установил РНР, а вот отправщик писем sendmail.exe это отдельное приложение, которое собственно и должно
рассылать письма. Такая работа аналогична с работой с логами из предыдущего урока, когда мы какую-то информацию
помещаем в файл логов.

mail('кому', 'тема письма', 'текст письма');
mail('кому', 'тема письма', 'текст письма', $headers);

class Mail {
    static $subject = 'Вы зарегистрировались на нашем сайте'; //по умолчанию
    static $from = 'inpost@list.ru';
    static $to = 'inpost@list.ru';
    static $text = 'Шаблонное письмо';
    static $headers = '';

    static function testSend() {
        if(mail(self::$to, 'english words', 'english words')) {
            echo 'Письмо отправилось';
        } else {
            echo 'Письмо не отправилось';
        }
        exit();
    }
    static function send() {
        self::$subject = '=?utf-8?b?'. base64_encode(self::$subject) .'?=';//заголовок сообщения перекодированный
        // в base64, чтобы избежать проблем с кодировкой;
        self::$headers = "Content-type: text/html; charset=\"utf-8\"r\n";//тип письма и его кодировка, тип письма обычно
        // указывается html либо plain (текстовая версия);
        self::$headers .= "From: ".self::$from."\r\n"; //имя и e-mail отправителя;
        self::$headers .= "MIME-Version: 1.0\r\n"; //версия MIME-стандарта;
        self::$headers .= "Date: ".date('D, d M Y h:i:s O')."\r\n"; //дата отправки;
        self::$headers .= "Procedence: bulk\r\n";// этот заголовок необходим в случае массовой рассылки,
        // значение ставится bulk.

/*        if (mail(self::$to, self::$subject, self::$text, self::$headers)) { //проверка ушло ли письмо
            return true; // аналог - echo 'Письмо дошло';
        } else {
            return false; // аналог - echo 'Письмо не дошло';
        }*/
//можно записать короче:
    return mail(self::$to, self::$subject, self::$text, self::$headers);
    }
}
Использование класса:
Mail::$to = 'oleg@gmail.com';
Mail::$subject = 'Вы зарегистрировались'; //если в теме письма тот же текст, что и в свойствах, то можно не писать
Mail::$test = 'Ваш текст'
Mail::send();

Самая простая проверка отправилось ли письмо с помощью функции testSend().
Mail::testSend();

Если функция вернула true, то письмо отправлено, можно проверить в папке !sendmail в файле *.eml
Но если в файле *.eml запись есть, а получатель письмо не получил, то это может случиться по причинам:
    1) не настроена программа sendmail;
    2) хостер запретил отправку писем;
    3) проблема с заголовками.

Проверять почту желательнона gmail, тему и текст писать англ.буквами и проверить, чтобы не попало в спам.

Любой класс можно расширять. К классу отправки писем можно сделать рассылку нескольких писем, в таком случае
мы бы создавали массив и этот массив в цикле бы отправляли. Можно расширить, чтобы отправляло наше письмо
на разные почтовые ящики, через вызов в цикле подставляя каждый элемент цикла


Урок 25: Регистрация + Авторизация, установка прав доступа (2022-05-30)
/*План:
Регистрация
Hash
авторизация
подтверждение по email
права доступа*/

25.1 Регистрация(00:18:00)
Проверка на длинну логина:
if(empty($login)) {
    $errors['login'] = 'Вы не заполнили логин';
} elseif (mb_strlen($login) < 2) {
    $errors['login'] = 'Логин слишком короткий';
} elseif (mb_strlen($login) > 16) {
    $errors['login'] = 'Логин слишком длинный';
}
//то же и для пароля

Делаем проверку логина и email на уникальность: (01:31:16)
if (!count($errors)) {
        $res = q{"
            SELECT `id`
            FROM `users`
            WHERE `login` = '".mres($_POST['login'])."'
            LIMIT 1
        "};
    if(mysqli_num_rows($res)) { //функция - если такая запись существует
        $errors['login'] = 'Такой логин уже занят';
    }
}
// по аналогии и для почты

25.2 Hash пароли (00:26:30)
25.2.1 Hash пароли - это кодирование пароля по определенному алгоритму('MD5'), главной особенностью которой есть то,
что нельзя разобрать строку в обратном направлении. Длинна Hash всегда одинакова. Хеш содержит 128 бит (16 байт)
и обычно представляется как последовательность из 32 шестнадцатеричных цифр.
Несколько примеров хеша:
echo md5("md5"); // 1BC29B36F623BA82AAF6724FD3B16718
Пример MD5-хеша для «нулевой» строки:
echo md5("");// D41D8CD98F00B204E9800998ECF8427E

25.2.2 Пример применения
Регистрация:
$var = 'inpost'; //пароль при регистрации
$var = md5($var); //перекодируем в хещкод
//отправляем в БД

Логин зарегистрированного:
$var2 = 'inpost'; //пароль при авторизации
$vat2 = md5($var2); //перекодируем в хешкод
if ($var == $var2) {//хешкод совпадает
    //успешная авторизация
}

25.2.3 'Соль' - это произвольный текст
$salt = 'o4qi6kwj4eoi298347y892yokj';
$pass = 'inpost';
$pass = $salt.$pass.$salt;
$pass = md5($pass);
//Можно дополнительно еще раз прогнать через md5 результат:
$pass = md5(md5($pass).md5($salt2.md5(str_replace('AAA', '', $pass))));
В последнее время принято считать, что md5 не такое уже и безопасное, поэтому не рекомендуют его использовать
для шифрования паролей.

25.2.4 crypt() - функция шифрования, более продвинутая, чем md5.
function myHash ($var) {
    $salt = 'ABC';
    $salt2 = 'CBA';
    $var = crypt(md5($var.$salt), $salt2);
    return $var;
}

И когда мы пароль будем добавлять в БД мы его прогоним через функцию myHash
        q("
		INSERT INTO `users` SET
		`login`    = '".mres($login)."',
		`password` = '".myHash($password)."',
		`email`    = '".mres($email)."',
		`age`      = ".(int)$_POST['age']."
		");

25.3 Подтверждение по email (01:18:00)
После регистрации не стоит сразу авторизировать пользователя на сайте - нужно чтобы он подтвердил свой
email. Делается, чтобы боты от "фонаря" не писали почту.
В дальнейшем по проверенному email можно пользователю восстановить пароль.
Для того, чтобы удостовериться, что email принадлежит этому пользователю, мы сбрасываем на почту
просьбу подтвердить этот email
В БД мы так же создаем новое поле 'active' / тип TINYINT / длинна значения 1/
по умолчанию значение "0" /

Чтобы подтвердить пользователю, то мы должны создать еще один хеш. Второй хеш - это будет смесь
простой ссылки, по которой пользователь перейдет и будет означать, что определенный пользователь
подтвердил свой email.

$_SESSION['regok'] = 'OK';
Mail::$to = $_POST['email'];
Mail::$subject = 'Вы зарегистрировались на сайте';
Mail::$text = '...Если вы не регистрировались, то не отвечайте на данное письмо. Если это все-таки
вы регистрировались, то пройдите по ссылке для активации вашего аккаунта:
'.Core::$DOMAIN.'index.php?module=cab&page=activate&id='.$id.'&hash='.myHash($_POST['login'].$_POST['age']).'
';
header("Location: /index.php?module=auth&page=regin");
exit();

Где мы берем $id в запросе на активацию?
$id = mysqli_insert_id($link);

//Добавляем новое поле в БД и в функцию запроса к БД:
'hash' / VARCHAR / 255 / 'нет'
q("
		INSERT INTO `users` SET
		`login`    = '".mres($login)."',
		`password` = '".myHash($password)."',
		`email`    = '".mres($email)."',
		`age`      = ".(int)$_POST['age'].",
        `hash`     = ".myHash($_POST['login'].$_POST['age'])."``
		");

25.4 Активация (01:27:50)
25.4.1 activate.php (01:28:14)
В этой же папке создаем модуль активации - activate.php: (01:34:25)
Так как в почтовом письме hash передаем через параметр GET (в файле регистрации), поэтому
if(isset($_GET['hash'], $_GET['id'])) {
q("
        UPDATE `users` SET
       `active` = 1
		WHERE `id` = ".(int)$_GET['id']."
		    AND `hash` = '".mres($_GET['hash'])."'
    ");
$info = 'Вы активированы на сайте';
} else {
$info = 'Вы прошли по неверной ссылке';
}

25.4.2 activate.tpl
Cоздаем шаблон модуля активации activate.tpl: ?>
<div>
    <h1><?php echo $info; ?></h1>
</div>
<?php


25.5 Авторизация
После активации два пути:
1) пользователь вручную снова вводит свои регистрационные данные через отдельную форму
2) автоматическая авторизация после активации (2-й более преемлем)

25.5.1 authorization.php (01:37:30)
if (isset($_POST['login'], $_POST['pass'], $_POST['do_login'])) {
$res = q("
		SELECT *
		FROM `users`
		WHERE `login` = '".mres($_POST['login'])."'
			AND `password` = '".myHash($_POST['pass'])."'
			LIMIT 1
	");
if (mysqli_num_rows($res)) { //функция - если такая запись существует
    $_SESSION['user'] = mysqli_fetch_assoc($res);
} else {
    $error = 'Нет пользователя с таким логином и паролем';
}
}

25.5.2 authorization.tpl
<div style="padding: 100px;">
<?php if(isset($error)) {echo $error; ?>
    <form action="" method="post">
        Login: <input type="text" name="login"><br>
        Password: <input type="text" name="pass"><br>
        <input type="submit" name="submit" value="Вход">
    </form>
<?php } else {?>
    Позравляю, Вы авторизированы
<?php } ?>
</div>

<?php

25.5.3 Авторизация на куках и сессии (01:53:35)
Виды авторизации:
1) через адресную строку (старые форумы - неудобный)
2) через куки
Нам нужно сделать какую-то отметку, что пользователь зарегистрировался. Клиент должен серверу что-то скинуть, на
основании чего сервер даст ответ, что пользователь зарегистрирован (ок!).
Каким  образом клиент (компьютер пользователя) может запросить проверку у сервера?
Через GET, POST (старый вариант) и куки (самый простой).
В куках хранится не авторизация - в куках хранится идентификатор (ID сессии авторизации). Но этот ID сам по себе
ничего не значит без серверного ответа, то есть сервер должен убедиться, проверить эти данные в куках, что
действительно эти куки верные. После передачи кук на сервере мы должны проверить, что такая авторизация существует.
Если индентификатор существует, значит пользователь авторизирован.

Мы знаем, что в наших куках содержится ключ(идентификатор) сессии:
[PHPSESSID] => as60n31rkj7p1038tvo4de65aoltmr63 // идентификатор сессии => хеш
который говорит, что мы зарегистрированы и мы просим разрешения на вход на сайте, на что сервер должен ответить
авторизировать/впускать вас или нет.
Где хранить данные, что наш "билет" на вход действителен или не действителен? Значит мы эти данные должны хранить
на сервере.
У нас два варианта хранения этой информации:
1) в сессиях
2) сессия хранится в базе данных (особенно хорошо, когда БД хранится на других серверах, отличных от хостинга)

То что человеку можно, какие права у пользователя на данный момент - хранится в сессиях и эту обработку мы делаем
на сервере, поэтому хакер туда не сможет получить доступ и данные поламать. Мы делаем связку по [PHPSESSID]

Для проверки, что у нас хранится в куках создадим в корне файл temp.php:
echo '<pre>';
print_r($_COOKIE);
echo '</pre>';

Выведет на экран:
[PHPSESSID] => 3b7jde3t2rr28e1s3vnkrcjuquv52sue // идентификатор сессии => хеш


25.6 Права доступа (02:08:00)
В БД `users` добавим поле `access` / тип TINYINT /  длинна = 1 /по умолчанию  как определено = 0

25.6.1 Выход из сессий.
Добавляем папке "auth" файл exit.php и дубль exit.tpl (для отладки и проверки - выход из сессий):
session_unset();
session_destroy();
header('Location: /');
exit();
Далее для запуска файла дописываем в строке GET:
**/index.php?module=auth&page=exit
//После обновления странички temp.php там массив сессии будет пустой.

25.6.2 Создание доступа к странице (auth.php):
if (!isset($_SESSION['user']) || $_SESSION['user']['access'] != 1 {
    exit();
}

25.6.3 Блокировка пользователя (02:13:50)
Делается просто - высталяем в базе в строчке `active` = 2 или `access` = 5

25.6.4.1 allpages.php (02:15:15)
В файле index.php если остались какие скрипты переносим в отдельный файл, а тут оставляем только редиректы
Создаем для этого отдельный файл allpages.php и подключаем его в index.php
include './modules/allpages.php';
Сюда пишем функционал, который будет подключаться ко всем страницам:
if(isset($_SESSION['user'])) {
    $res = q("
            SELECT *
            FROM `users`
            WHERE `id` = ".$_SESSION['user']['id']."
            LIMIT 1
        ");
    $_SESSION['user'] = mysqli_fetch_assoc($res);
    if($_SESSION['user']['active'] !=1) { //0 - не активирован, 1 - активирован, 2- забанен.
        header("Location: index.php?module=auth&page=exit");
    exit();
    }
}

25.6.4.1 Проверка на авторизацию в скинах (*.tpl):
if(isset($_SESSION['user'])) {
    //форма авторизации
} else {
    //вам необходимо авторизироваться.
}

25.7. Домашнее задание: (02:18:55)
25.7.1. Сделать авто-авторизацию на сайте. То есть для тех, у кого стоит при обычной авторизации галочка, что необходимо
автоматически авторизировать пользователя при следующем посещении сайта. Подробности в записи.
Так как сессия после выхода умрет, то для того чтобы снова авторизироваться, нам необходимо где-то хранить
идентификатор о том, что мы должны авторизироваться. Для этого используют куки. Чтобы хакеры не подделали ID код
нужно использовать хешкод, для автоавторизации. То есть в куках мы будем хранить ID пользователя и HASH, этот
хеш мы будем хранить в БД. Хеш будем создавать микс из логина, пользователя и email:
ID = 10;
HASH = ID+LOGIN+EMAIL
Каждый раз когда пользователь хочет, чтобы его автоматически запомнили (ставит "галочку"), то мы будем в БД добавлять
хеш. Для всех это не делается, потому что если кто-то зальет вирус вашему клиенту, вирус сворует чужие куки и сможет
под чужим аккаунтом авторизироваться. Поэтому автоавторизация - это удобная вещь и абсолютно не безопасная для
посетителей. Это должно быть добровольно.
Спрашивать эту "галочку" должно при авторизации ($status = 'OK!';). Варианта два:
1) "Запомнить меня"
2) "Не запоминать"
После этого обычным UPDATE в БД прописываем новое значение в поле `hash` таблицы `users`
Этот hash мы сохраним одновременно и в куках (на странице авторизации) и в БД
А если кук не существует, делаем проверку:
} else {
    //проверять возможность на автоматическую авторизацию: myHash(ID+LOGIN+EMAIL)
}
Еще вариант разнообразия хеша - использовать функцию time():
hash = myHash(time() + ID);

Что такое автоматически авторизировать? Это значит, что мы должны создать переменную пользователя $_SESSION['user']
в БД $_SESSION['user'] = mysqli_fetch_assoc($res);
Но перед этим мы должны проверить точно ли такой хещ существует? А точно ли совпадает ID и хеш в БД?
Если такой хеш не существует, то его необходимо удалить.

Если хакер сможет своровать ID и хеш, то он сможет залогиниться и поэтому лучший вариант и в БД и в куках хранить
бонусом для сравнения: 1-й вариант - IP, 2-й вариант - браузер $_SERVER['HTTP_USER_AGENT'].
Но с IP есть проблема - он у большинства динамический и автоматическая авторизация не будет работать если человек
разлогинился. А HTTP_USER_AGENT можно подделать
IP и HTTP_USER_AGENT не нужно хранить в куках - это нужно хранить в БД
У кого может отсутствовать автоавторизация:
1) у незарегистрированных посетителей сайта
2) у тех, кто вышел (разлогинился)
3) у тех, кто не поставил галочку, чтобы его автоавторизировали
4) у тех кто захотел, чтобы его авторизировали, но не подошел IP или хеш или юзерагент, поэтому была удалена кука

У нас в итоге будет две куки - хеш и ID:
} elseif(isset($_COOKIE['autoauthhash'], $_COOKIE['autoauthid'])) {...

25.7.2. Комментарии только для авторизированных пользователей сделать (улучшить модуль комментирования на сайте).

25.7.3. Защитить модуль news от доступа пользователей, у которых нет прав смотреть данный раздел. Права есть в таблице
пользователей: access=5.


Урок 26: Работа над ядром: ЧПУ и оптимизация

26.1 ЧПУ, Mode Rewrite
ЧПУ - человекопонятный урл(адрес)
Замена нашего адреса:
test1.ua:8082/index.php?module=cab&page=regostration
на более понятный пользователю:
test1.ua:8082/cab/regostration

26.1.1 .htaccess
//Добавляем новый код:
RewriteEngine On
#Исключения, которые не обрабатываются ЧПУ:
RewriteCond %{REQUEST_URI} !^/admin
RewriteCond %{REQUEST_URI} !^/forum
RewriteCond %{REQUEST_URI} !^/ckeditor
#Стандартное поведение, что делать с папками и дирикториями:
RewriteCond %{REQUEST_URI} !-f
RewriteCond %{REQUEST_URI} !-d
#Автозамена:
RewriteRule ^(.*)$ index.php?route=$1 [L,QSA]

26.1.2 Проверка как выглядит адрессная строка:
26.1.2.1 в файле allpages.php первой строчкой пишем функцию:
wtf($_GET);

по запросу: http://testphpagro1.ua/index.php?module=news получаем
Array
(
    [route] => index.php
    [module] => news
    [page] => main
)

по запросу: http://testphpagro1.ua/index.php?module=game&page=game
Array
(
    [route] => index.php
    [module] => game
    [page] => game
)

http://testphpagro1.ua/index.php?page=services
Array
(
    [route] => index.php
    [page] => services
    [module] => static
)

26.1.2.2 Если такую же проверку сделать из variables.php, то вывод будет таким:
http://testphpagro1.ua/index.php?module=news
Array
(
    [route] => index.php
    [module] => news
)

http://testphpagro1.ua/index.php?page=services
Array
(
    [route] => index.php
    [page] => services
)

26.1.3.1 ЧПУ:(00:11:00)
//Если мы в адрессной строке вводим:
test.ua:8082/a/b/c
//Вот мы видим через wtf($_GET)
Array
    (
        [route] => a/b/c
    )
//то это означает:
$_GET['module'] = a
$_GET['page'] = b
$_GET['key1'] = c

26.1.3.2 В variables.php дописываем код в начале страницы: (00:10:00)
if(isset($_GET['route'])) {
$temp = explode('/', $_GET['route']); //функция разбивает строку в массив
//wtf($temp); если добавить к главной буквы http://testphpagro1.ua/a/b/c выведет ([0]=>a [1]=>b [2]=>c)
foreach ($temp as $k=>$v) {
    $_GET['key'.$k] = $v;
} //wtf($_GET); Array ( [route] => a/b/c [key0] => a [key1] => b  [key2] => c )
    unset($_GET['route']);// удаляем из массива [route] => a/b/c - он уже не нужен
wtf($_GET); получаем уже Array ( [key0] => a [key1] => b  [key2] => c )
}

26.1.3.3 Развиваем дальше этот же код (подгоняем ключи под наши стандарты сайта): (00:15:20)
if(isset($_GET['route'])) {
    $temp = explode('/', $_GET['route']);
    foreach ($temp as $k=>$v) {
        if($k ==0 ) {
            $_GET['module'] = $v;
        } elseif($k == 1) {
            if(!empty($v)) {
                $_GET['page'] = $v;
            }
        } else {
            $_GET['key'.($k-1)] = $v;
        }
    }
    unset($_GET['route']);
}

26.1.3.4 Использование ЧПУ
Если внести в строку ввода: test.ua:8082/auth/registration
получим массив:
Array([module]=>auth [page]=>registration)

Дальше в том же variables.php редирект:
header("Location: /index.php?module=errors&page=404");
приведем к новому виду:
header("Location: /errors/404");

Дополнительные проверки мы сделаем, когда изучим регулярные выражения

26.1.3.5 "Приколы ЧПУ" (00:18:00)
Чтобы наш ЧПУ работал без проблем нам нужно теперь еще добавить кое-что
Нам пришлось добавить проверку на пустые значения ключей, так как потом возникают проблемы если в конце строки
ввода поставить закрывающую косую черту /
Без него код считает строку как пустой файл:
(./modules/news/.php), а должно быть (./modules/news.php)
После добавления проверки на пустотувсе заработало:
if(!empty($v)) {...}

26.1.3.6 news/main.tpl
Далее правим ссылки в наших новостях, чтобы привести к новому виду
в main.tpl меняем ссылку:
href="/index.php?module=news&action=delete&id=(php код)"
на
href="/news/main?action=delete&id=(php код)" //внимание: знак & меняем на ?
//? означает, что мы к предыдущим двум стандартным параметрам добавляем еще один параметр
//получим вывод:
/news/main?action=delete&id=10
//Если мы хотим привести к такому виду:
/news/main/delete/10 //то последние два параметра будут key1 и key2
//и нужно уже будет писать так:
href="/news/main/delete/(php код)"

26.1.3.7 news/main.php (00:24:22)
//удаление новости:
if (isset($_POST['delete'])){
/*  foreach($_POST['ids'] as $k=>$v) {
    q("
        DELETE FROM `news`
        WHERE `id` = ".(int)$v."
	");
    }*/
    //измененный код из 26-го урока
    foreach ($_POST['ids'] as $k => $v) {
        $_POST['ids']['$k'] = (int)$v;
    }
    $ids = implode('/', $_POST['ids']);
        q("
            DELETE FROM `news`
            WHERE `id` IN (".$ids.")
        ");
    $_SESSION['info'] = 'Новости были удалены';
    header("Location: index.php?module=news");
    exit();
}

//if(isset($_GET['action']) && $_GET['action']=='delete'){
if(isset($_GET['key1'], $_GET['key2']) && $_GET['key1']=='delete'){
        q("
            DELETE FROM `news`
            //WHERE `id` = ".(int)$_GET['id']."
            WHERE `id` = ".(int)$_GET['key2']."
        ");
$_SESSION['info'] = 'Новость была удалена';
//header("Location: /index.php?module=news&page=main");
header("Location: /news");
exit();
}

26.1.3.8 ЧПУ - больше нужна поисковикам для раскрутки сайтов, для админки ЧПУ не нужна, так она не видна поисковикам.
Но об этом поговорим позже.

26.1.3.9 Если что-то не понятно как работает - разворачиваем массив через wtf($_GET);

26.1.3.10 Ошибка key2 (00:26:41)
test2.ua:8082/news/main/delete //Undefined index key2
Если мы используем внутри нашего сайта key2, но при этом его не передаем в адресной строке ошибка была в том,
что мы работаем с key2, но мы не проверили на ее наличие - проверяем все модули через isset:
if(isset($_GET['key1'], $_GET['key2']) && $_GET['key1']=='delete'){

26.2 Абсолютные и относительные ссылки (00:28:05)
Больше инфоррмации тут:
https://school-php.com/tricks/21/otnositelnyie-i-absolyutnyie-puti-v-html-i-php

26.2.1 Проблема картинок с нашим ЧПУ
Для начала в папку skins/default добавляем папки css, js и img. Перебрасываем их из корня
в конкретные скины. В дальнейшем это будет большим плюсом.

26.2.2 Пути к картинкам мы можем передавать тремя видами:
<img src="http://site.ru/skins/<?php echo Core::$SKIN; ?>/img/logo.png"> //это абсолютный путь
<img src="skins/default/img/logo.png">//относительный путь
<img src="/skins/<?php echo Core::$SKIN; ?>/img/logo.png">//относительно корня сайта - для простого переноса домена

В нащем проекте мы используем третий вариант - относительно корня сайта.

26.3 Динамические meta-данные, CSS, JS
26.3.1 Config.php (00:43:00)
Рассмотрим еще несколько свойств, которые нужно справить/добавить
static $JS = array();
static $CSS = array(); //пустой массив означает, что для всего сайта будут стандартные настройки из шапки index.tpl
static $META = array(
                    'title' => 'стандартный TITLE',
                    'description' => 'd',
                    'keywords' => 'k'
                    );

26.3.2 index.tpl
?>
<title><?php echo @$title; ?></title>
меняем на:
<title><?php echo hsc(Core::$META['title']); ?></title>
Обработано функцией для htmlspecialchars, так же меняем и остальные записи тут:
<meta name="description" content="<?php echo hsc(Core::$META['description']); ?>">
<meta name="keywords" content="<?php echo hsc(Core::$META['keywords']);?>">
<?php

26.3.3 Изменения для $META (00:47:25)
Важно! Теперь мы работаем над нашми модулями, мы создаем какие-то модули, у нас есть допустим новости.
В новостях мы что можем? Мы можем в main.php в начале дописать какое-то свое правило и это свое правило мы можем
писать непосредственно и с php понятное дело, мы можем из базы данных брать, мы можем генерировать специальные
метаданные. Если же мы метаданные какие-то не ввели, не уточнили, то берется из нашего ядра. В нашем ядре мы
прописали, что эти значения были по умолчанию.
Теперь если мы хотим этот параметр изменить, то мы пишем персональный title для конкретного определенного модуля,
то есть для новостей, к примеру, мы можем заменить старый параметр на новый:
Core::$META['title'] = 'Новый параметр';

Очень часто когда работаем с интернет магазинами 'description', 'title' и 'метаданные' - генерируются автоматически.
Для SEO нельзя дублировать 'description', 'title' и 'keywords', поэтому мы должны прописывать какие-то правила
для всего сайта(через allpages.php) или написать какие-то персональные правила для каждой конкретной странички.

Прописывая правила или вручную заполняя мы получим хороший... Мы могли бы так же метаданные хранить в БД и доставать
непосредственно в allpages.php:
$res = q ("
    SELECT *
    FROM `meta`
    WHERE '".mres($_GET['module'])."_".mres($_GET['page'])."'
    LIMIT 1
");
$row = mysqli_fetch_assoc($res); //достаем эти данные из $res
//теперь допишем эти данные в метамассив ядра
Core::$META['title'] = $row['title'];
Core::$META['description'] = $row['description'];
Core::$META['keywords'] = $row['keywords'];

//или более простой вариант:
Core::$META = $row;

Так мы сможем прописывать конкретные метаданные для конкретных страничек.

26.3.4 CSS, JS (00:54:00)
Если CSS подключить для корня ядра, то они будут доступны на всех страницах. Если нам нужна отдельный CSS стиль
для отдельной страницы, то мы используем специальные подключения. Если к приимеру нам в новостях нужен отдельный
стиль, то в main.php вверху страницы подключаем:
Core::$CSS[] = '<link type="text/css" rel="stylsheet" href="/css/news_style.css">';
Тоже и JS:
Core::$JS[] = 'Подключаем JS';

Для того чтобы он отобразился нам нужно упомянуть его в index.tpl (сразу подключения общего css):
<?php if(count(Core::$CSS)) {echo implode("\"n,Core::$CSS); } ?>
<?php if(count(Core::$JS)) {echo implode("\"n,Core::$JS); } ?>
"
Это значит, что если count вернет цифру ноль, то это событие не произойдет. Но при этом ноль не вернет в нашей новости,
потому что мы расширили там функционал. Благодаря этому новый CSS подключится толко на одной странице.

26.3.4 Почему нужны отдельные подключенния CSS, JS (00:57:05)
Есть популярная CMS JOOMLA, но у нее минус - JS подключается всегда в индексе для всех страниц. Итого если у нас есть
интернет-магазин и где-то в конкретном месте какой-то скрипт нужен только для данной страницы, то получается ситуация,
что чем больше использовалось скриптов, тем больше было нагромождение их. В итоге даже на тех страницах где JS не
нужен мы будем иметь все скрипты утяжеляя код. И чем больше проект, тем больше это становится проблемой.
Сейчас может этих проблем у JOOMLA нет, но раньше это было проблемой.

Много JS нужны при загрузке админки, которую обычный пользователь не увидит и ему не нужно подгружать эти скрипты.


26.4 ob_start обфусикация (01:05:00)
Функция ob_start() не дает обрабатывать сразу участок кода, а записывает его во временное хранилище, но вывод может
быть уже не на этой странице.
Функция ob_end_clean() закрывает запись во временное хранилище (буфер обмена)
Во временное хранилище может отправляться только вывод (echo, print_r), а к примеру header("Location: /") даже
если он размещен между этими функциями сработает.
Грубо говоря временное хранилище - это наша переменная.
Достаётся информация из нашей "переменной" (временного хранилища) при помощи функции ob_get_contents();

26.4.1 Пример использования (вывод текста):
ob_start();
    echo 'TEXT<br>';
    echo 'Text5<br>';
    $content = ob_get_contents(); //сюда записывается предыдущие две строчки

    echo 'TEXT3<br>';
    echo 'Text4<br>';
    $content2 = ob_get_contents(); //сюда записывается все, что выше этой функции - от начала ob_start();
ob_end_clean();

echo 'TEXT2'; //выведется раньше предыдущего блока, так как не попал в буфер обмена

echo '<br>'.$content2.'<br>'.$content; //вывод содержимого буфера обмена

26.4.2 Пример использования (перенос вывода сообщения об ошибке в другое место страницы)
Допустим у нас есть код, который выдаст ошибку, так как переменная не назначена:
if($var ==5) {
    echo 'text';
}

Теперь обернем это условие в функцию:
ob_start();
    if($var ==5) {
        echo 'text';
    }
    $content = ob_get_contents(); //запись об ошибке попадет в эту переменную
ob_end_clean();

echo '<div style="color:red">'.$content.'</div>';

26.4.3 ob_start() мы будем использовать для работы с контроллером, потому что он выполняется, обрабатывается еще до попадания на страницу.
В файле index.php в функцию помещаем наши инклюды и когда выдаст какое-то сообщение
не выведется выше index.tpl, а попадет в переменную:
ob_start();
include './modules/allpages.php';
include './modules/'.$_GET['module'].'/'.$_GET['page'].'.php';
$content = ob_get_contents();
ob_end_clean();
include './skins/'.Core::$SKIN.'/index.tpl';

Затем выводим эту переменную в одном из <div> в файле index.tpl:
<div id=content>
    <?php echo $content;
    include $_GET['module'].'/'.$_GET['page'].'.tpl';
    ?>
</div>
<?php
Но можно еще улучшить наш контролер и подключене include $_GET['module'].'/'.$_GET['page'].'.tpl'; пернести в index.php в блок функции ob_start(),
а в index.tpl оставим только наш вывод переменной: echo $content;
только добавляем к нему расположение от корня сайта:
// Роутер
ob_start();
include './modules/allpages.php';
include './modules/'.$_GET['module'].'/'.$_GET['page'].'.php';
include './skins/'.Core::$SKIN.'/'.$_GET['module'].'/'.$_GET['page'].'.tpl';
$content = ob_get_contents();
ob_end_clean();

include './skins/'.Core::$SKIN.'/index.tpl';


Урок 27: Создание админки, CMS (00:04:55)

27.1.1 Админка на техническом уровне называется CMS
CMS (англ. Content Management System) — это система управления контентом сайта. На профессиональном жаргоне
CMS ещё называют «движок сайта».
Управление подразумевает:
1) Создание данных (access = 2)
2) Редактирование данных (access = 2)
3) Отправка жалобы на контент (access = 2)
4) Сокрытие контента (access = 5)
3) Удаление данных (access = 5)

27.1.2 Фреймворки CMS - это наши модули (папка modules), которые имеют свои собственные библиотеки (папка libs)
На данный момент у нас на сайте есть фремворк, но отсутствует CMS. С CMS мы поработали, когда реализовали
в блоке новости - создание и редактирование новостей.

27.1.3 Назначение прав пользователям:
if(нажата кнопка && $_SESSION['user']['access'] == 2) {
    удаляем новость;
}

$res = q("запрос");
while($row = mysqli_fetch_assoc($res)) {
    echo 'Новость №'.$row['id'];
    if($_SESSION['user']['access'] == 2) {
        echo '<a>Удалить новость</a>';
    }
    echo $row['text'];
}
Кнопка 'Удалить' видна только тем, у кого есть права = 2

27.1.5 Хакеры могут удалять новости даже без кнопки удалить, просто прописав в адресной строке:
site.ua/index.php?action=delete&id=7
Вот поэтому и нужно выставлять права доступа к самому удалению, а не только скрывать кнопку "удалить"

27.2 Внешние и внутренние админки
27.2.1 Есть два варианта администрирования контента:
1) прямо на странице - скрыть, подредактировать или удалить контент
2) отдельный подсайт внутри нашего сайта, который является нашей админкой, со своим стилем, своими меню, навигацией
и расширенными функциями по управлению контентом на основном сайте.

27.2.2 Документация по админке (00:30:00)
Очень полезно где-то иметь небольшую документацию, где описывать работу модулей, которые мы создаем и описывать их
функционал. Это можно хранить на какой-то отдельной страничке. Собственно это касается не только CMS, к фреймворкам
так же можно хранить описание функционала. Описание функционала хорошо помагает тем, кто будет пользоваться нашей
админкой.
Для того, чтобы заказчику нравился ваш сайт, то по нему должна быть:
1) доступная документация;
2) человеко-понятный интерфейс.

27.3 Создаем админку
27.3.1 Создаем новые папки. (00:34:00)
Создаем в папке skins новую папку admin. Туда поместим index.tpl и какой-нибудь базовый модуль, с которым уже работали,
например новости. Создаем в ней же папки css. js. img. Для адинки будем делать отдельные стили css.
В папке modules создаем папку admin и в нее потом будем писать свои модули для работы. Создаем свой allpages.php
Чтобы этот шаблон подключался нам нужно подкорректировать ядро. Чтобы попасть в админку сайта стандартно после
названия сайта идет admin: agro2.ua/admin

27.3.2 Вносим изменения в variables.php (00:39:35)
//добавляем папку админки:
//ЧПУ
if(isset($_GET['route'])) {
    $temp = explode('/', $_GET['route']);
    //подключаем админку:
    if($temp[0] == 'admin') { //аналогично функции in_array($temp[0], array('admin', 'partners', 'advertisement', ...))
        Core::$SKIN = 'admin'; //заменяем папку default на admin
        Core::$CONT = 'modules/admin'; //заменяем папку modules на modules/admin
    unset($temp[0]); //удаляем за ненадобностью
}
//во второй части меняем переменные на счетчик $i:
    $i = 0;
    foreach ($temp as $k=>$v) {
        if($i == 0) {
            if(!empty($v)) {
                $_GET['module'] = $v;
            }
        } elseif($i == 1) {
            if(!empty($v)) {
            $_GET['page'] = $v;
        }
        } else {
            $_GET['key'.($k-1)] = $v;
        }
        ++$i;
    }
    unset($_GET['route']);
}

27.3.3 Вносим изменения в config.php (00:51:00)
//Добавляем:
static $CONT       = 'modules';

27.3.4 Вносим изменения в index.php
//Инклюды с путями через папку 'modules'
include './modules/allpages.php';
//меняем на:
include './'.Core::$CONT.'/allpages.php';
include './'.Core::$CONT.'/'.$_GET['module'].'/'.$_GET['page'].'.php';


27.4 Работа с новостями/товарами (01:05:00)
Основные возможности: //админка
1. Создавать /admin/news/create (create.php + create.tpl), т.е. /admin/$_GET['module']/$_GET['page']/
2. Редактировать //дальше по аналогии с созданием
3. Удалять
Дополнительные возможности: //доступно для всех пользователей
1. Вывод всех новостей
2. Страница конкретной новости, читать подробнее (WHERE `id` = $_GET['id'])

27.5 Домашняя работа (01:09:50):
1. Сделать нашу админку
2. Функционал новостей и товаров, который мы раньше делали поместить в админку
3. Проверить на защищенность от SQL инъекций
4. Оформить стиль админки (admin/index.tpl + css):
    1) поместить логотип слева вверху
    2) справа приветствие администратора, ссылка перехода на сайт
    3) навигацию (главная, товары, новости, отзывы, пользователи)
    4) контент из навигации, на примере пользователи "Список пользователей":
        а) название вкладки, кнопки: фильтр, сбросить фильтр, создлать пользователя, удалить пользователя
        б) панель вывода пользователей:
            *) название столбца (пустой - чекбокс, id, e-mail, login, age
            *)  дальше строчки с БД
    5) футер(Copyright@ronam.nikolaevich 2022, Документация)

27.6 Дополнение к уроку по админке (27b 00:00:30)
27.6.1 .htaccess:
удаляем: RewriteCond %{REQUEST_URI} !^/admin

27.6.2 variables.php
добавляем исключение, чтобы массив $allowed не обрабатывался в админке:
if(Core::$SKIN != 'admin') {
    $allowed = array('static',...
} else {
    if(!isset($_GET['module'])) {
        $_GET['module'] = 'static';
    }
}

или более лаконично:
if(Core::$SKIN != 'admin') {
    $allowed = array('static', 'auth', 'comments', 'contacts', 'errors', 'game', 'goods', 'news','partners',
    'services', 'voting');

if(!isset($_GET['module'])) {
    $_GET['module'] = 'static';
        } elseif(!in_array($_GET['module'],$allowed) && Core::$SKIN != 'admin') {
            header("Location: /errors/404");
        exit();
    }
}

27.6.3 Посмотреть как сделаны админки у imagecms.net, битрикс или аналогичных конкурентов

27.6.4 Вход а админку/авторизация (27b 00:07:30)
/admin/login
Название, логин, пароль, чекбокс "Запомнить", кнопка "Вход в систему", ссылка "Забыли пароль?"
//Минимум стиля.
Реализация - admin/static/main.php

27.6.5 Внешний вид админки (index.php и tpl)
//если пользователя нет в сессии (неавторизирован) или есть но нет прав - в index.tpl через права
//доступа скрываем страницу (навигацию, дивы и футер):
if(!isset($_SESSION['user']) || $_SESSION['user']['access'] != 5) {...

27.6.6 skins/admin/static/main.tpl - главная страница админки
сюда можно подключить страничку авторизации из шаблона default, где у нас эта авторизация уже есть:
if(!isset($_SESSION['user']) || $_SESSION['user']['access'] != 5) {
    include './skins/default/auth/login.tpl';
}

27.6.7 modules/admin/static/main.php
if(!isset($_SESSION['user']) || $_SESSION['user']['access'] != 5) {
    include './modules/auth/login.php';
}

27.6.8 modules/admin/allpages.php
Разграничиваем права, что если у нас прав нет и если гет модуль не= статик или ...:
if(!isset($_SESSION['user']) || $_SESSION['user']['access'] != 5) {
    if($_GET['module'] != 'static' || $_GET['page'] != 'main') {
        header("Location: /admin/static/main"); //переадресация на авторизацию
        exit();
    }
}
Можно изменить первую строчку, чтобы разделить функционал: если нет сессии вообще, то редирект
допустит пройти авторизацию, а если пользователь авторизонваный, но у него нет прав, то сразу
отправлять на главную страницу или выводить сообщение "у вас нет прав для этого".

27.6.9 variables.php
//Обрезаем пост - проверить потом как работает
if(isset($_POST)) {
    $_POST =trimAll($_POST);
}

