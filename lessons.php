<?php
// PHP с нуля - 1 урок - Основы языка и синтаксиса
1-1;
/*
* Если нам нужно, чтобы часть кода ниже команды перестала обрабатываться, то мы прописываем следующее:
* <?php exit; ?>
*/
1-2;
/*
* echo 'Hello World';
* echo - значит вывести на экран, 'это то что мы хотим вывести на экран', а ';' - это значит мы закончили команду.
*/
1-3;
/*
 * Правило №1 текст выводится в кавычках '', а цифры без кавычек.
 * Если цифры часть текста, то тоже в кавычках.
 * 		echo '<b>Hello World</b>';
 *		echo  321;
 */
1-4;
/*
 * Математические операции пишем в скобках:
 * echo (1+1);
 */
1-5;
/*
 * Можно в начале кода прописать переменные, а потом где-то в середине им пользоваться, например:
 * <?php $num=7;
 * $text = 'Hello World'
 <?php echo $text?>
*/
1-6;
/*
 * Правило програмирования №2:
 * PHP выполняется сверху вниз, слева на право!
 * Например: echo $text3; $text3 = 'Vasya'; - не правильно!
 * Правильно: $text3 = 'Vasya'; echo $text3;
 */
1-7;
/*
 * Правило №3 РНР код всегда выполняется с нуля, с нулевой строчки кода!
 * То есть если у клиента открылась страница, код считался, то он и будет отображаться
 * а если часть кода скрыть, то при повторном запросе /обновлении страницы  - выдаст ошибку по этому коду!
 */
1-8;
/*
 * РНР код можно сократить - вместо: <?php echo $title; ?>
 * можно записать: <?=$title;?> - это короткая запись по выводу команды
 */


// PHP с нуля - 2 урок - работа сервера, переменные, типы данных
// Урок 2: Углубляемся в типы данных и переменные

2-1;
/*
 *После запроса от сервера к пользователю приходит только HTML, а РНР выполняется на стороне сервера и отправляет
 * сгенерированный HTML! Всего кода, что мы пишем на РНР - в браузере клиента его нет.
 * РНР - это серверный язык программирования, потому что он выполняется на сервере, где лежит сайт.
 */


2-2; // Чтобы положить информацию в файл пишем:
file_put_contents('1.txt', $text);
// достаем информацию из файла так:
$text = file_get_contents(filename:'1.txt');
echo $text;
//Но можно еще сократить вывод, одной строчкой:
echo file_get_contents('1.txt');


2-3; //Если два раза написать переменную, но каждый раз с разными значениями, то на экран пользователя выведется последння
 	$text = 'Hello World';
	$text ='Zimbabve'; //заменит значение переменной
//Но если перед знак присвоения поставить точку в последней пееременной, то выведутся оба текста вместе, например:
 	$text = 'Hello World';
	$text.=' Zimbabve'; //объединяется

//Следующий вариант - треться строчка затрет две предыдущие:
 	$text = 'Hello World';
	$text.=' Zimbabve';
	$text='Vasyan'; // выведется на экран только новое значение переменной - Vasyan

2-4; //Если у нас в HTML встречаются несколько переменных с одинаковым названием, то можно использовуать константы, например
$text = 'Вступительный урок'; /*эта запись не нужна теперь - для ознаколмления написана*/
define('TEXT', 'Вступительный урок'); /*define - константа, ТЕХТ большими буквами*/
/* <h1><?=TEXT; ?></h1>
 * помещаем константу в HTML
 * Константой мы утверждаем настройки, котрые не будем менять в коде.
 */

2-5; // Типы переменных:
$text = 'Произвольный текст'; // string - строка, текст
$num = 10; // int, integer - целые числа
$float = 1.2; //float - дробные, с плавающей запятой
$bool = true; // bool, boolean (true или false)

$result = $text + $num; //выдаст ошибку, так как разные типы переменных складывать нельзя!
echo $result;
$result = $text.$num.$float; //не выдаст ошибку, так как с точкой не складывает, а склеивает все подряд в одно слово
echo $result; //Произвольный текст101.2
$result = $text.' '.$num.' '.$float; // тоже не выдаст ошибку + поставит между значениями переменных пробелы
echo $result; //Произвольный текст 10 1.2

//Пример:
$num1 = 10;
$num2 = 15;
$calc_result = $num1 + $num2; // или $calcResult - тоже самое "Верблюжий стиль"
var_dump($calc_result); //вывод на экран результатов - int(25)

$calc_result = $num1 / $num2; // тоже , только с делением
var_dump($calc_result); // float(0.6666666666666666) -число с плавающей запятой

//Приведение к типам - пример:
$num1 = (string) $num1; // вместо числа задаем новую переменную - строка
var_dump($num1); // получим string(2) "10" - число превратили в текст, в скобках указано количество знаков, байт

$num1 = (bool) $num1; // еще вариант
var_dump($num1); // bool(true) - правда все кроме нуля, даже с минусом правда (true)

/*
 * Допускаются следующие приведения типов:
(int), (integer) - приведение к int - целые числа
(bool), (boolean) - приведение к bool - логический
(float), (double), (real) - приведение к float - дробные числа
(string) - приведение к string - строка
(array) - приведение к array - множество, массив
(object) - приведение к object - объект
(unset) - приведение к NULL  — удаляет переменную
 */


// PHP с нуля - 3 урок - Управляющие конструкции и операторы сравнения
// Урок 3: Управляющие конструкции и операторы сравнения

3-1;
/*
 * условия:
 * == равенство по значению - не путайте = и == в коде! В операторах сравнения не существует одного равно,
 * это обычное присвоение переменной значения. А значение присваивается ВСЕГДА. И это распространённая ошибка,
 * новички путают = и ==.
 * === равенство по значению и ТИПУ
 * != не равно
 * !== не равенство по значению или типу
 * < меньше
 * > больше
 * <= меньше или равно
 * >= больше или равно
 */
// Управляющие конструкции - if, elseif, else. Своимм словами:
// if (или так), elseif (или тоже так, но с другми условиями), else (или по другому совсем)
//Расмотрим на примере корзины добавления товара в интернет магазине: первый вариант:
$cart_count = 0;
if ($cart_count >0) { // если больше нуля
	echo 'В корзине '.$cart_count.' товаров';
	}
else { //если нет
	echo 'Нет товаров в корзине';
}

//второй вариант - меняем местами строчки:
$cart_count = '3';
if ($cart_count ==0) { // если да?
	echo 'Нет товаров в корзине';
}
else { //если нет
	echo 'В корзине '.$cart_count.' товаров';
}
 //третий вариант - с текстом:
$cart_count = 'Пиво';
if ($cart_count == 0) { // строка при переводе в число - превращается в ноль,
	// как вариант можно записать так: if ((int)$cart_count == 0)
	//ответ при == будет да, если  === то нет
	echo 'Да';
}
else { //если нет
	echo 'Нет';
}

// для уменьшения кода можно писать иногда без else :
$is_buy = 1;
if ($is_buy === (3-2)) // можно так же записать в виде:
	//if (true)
	echo 'Yes';

3-2;
//Разбор вариантов с окончанием слов в корзине
//0 рублей
//1 рубль
//2 рубля
//первый вариант:
$rub = 2;
if ($rub === 0) {
	echo $rub.' рублей';
} else {
	if ($rub === 1) {
		echo $rub.' рубль';
	} else {
		echo $rub.' рубля';
	}
}
//второй вариант - с использованием elseif - пишем когда нужен дополнительный вариант условия if:
$rub = 3;
if ($rub === 0) {
	echo $rub.' рублей';
} elseif ($rub === 1) {
	echo $rub.' рубль';
} elseif ($rub === 2) {
	echo $rub.' рубля';
} else {
	echo $rub. ' рубл...';
}
/*
 * в этих схемах if - обазательно
 * elseif и else - не обязательно
 */

//Разберем на примере авторизации на сайте:
$login = 'inpost';
$pass = 'test';
if($login == 'inpost') {
	echo 'Логин совпал'; //условие верно
	} elseif($pass == 'test') {
	echo 'пароль совпал'; // условие верно
} else {
	echo 'Ни логин ни пароль не совпали'; // условие не верно
}

//второй вариант: тоже только на оборот, со знаком не равенства:
$login = 'inpost';
$pass = 'test';
if($login != 'inpost') {
	echo 'Логин не совпал'; //условие не верно
} elseif($pass != 'test') {
	echo 'пароль не совпал'; // условие не верно
} else {
	echo 'Логин и пароль совпали'; // условие не верно
}
// третий вариант:
$login = 'inpost';
$pass = 'test';
if($login == 'inpost') {
	if($pass == 'test') {
		echo 'Вы авторизированы';
	}
	else {
		echo 'Пароль введен не верно';
	}
} else {
	echo 'Логин введен не верно';
}

3-3;
//Сравнение цифровых значений:
$num1 = 10;
$num2 = 5;
if($num1 != $num2) {
	echo 'не равно';
}

3-4;
// Правило №4: работаем переменными из-вне только тогда, когда они существуют.

3-5; // isset — Определяет, была ли установлена переменная значением, отличным от null
//Определяет, была ли установлена переменная значением отличным от null.
//Если переменная была удалена с помощью unset(), то она больше не считается установленной.
$x = 1;
$y = 2;

if (isset($z)) { //переменная isset проверяет есть ли переменная и только если она есть, то выполняется этот блок
	echo 'Переменная существует';
} else {
	echo 'Переменная не существует';
}

3-6 /*Работаем с формой в PHP:
разберем на примере авторизации на сайте: */?>
<form action="" method="post" class="content">
	<input name="login" placeholder="Введите логин"><br>
	<input name="password" placeholder="Введите пароль"><br>
	<input type="submit" value="Отправить">
</form>

<?php
//$_POST['login'];
//$_POST[['password'];
if(isset($_POST['login'], $_POST['password'])) {
	echo 'Форма была отправлена<br>';
}
//первый вариант:
if ($_POST['login'] == 'inpost') { // логин мы задаем заранее
	if($_POST['password'] == '123') { // пароль мы задаем заранее
		echo 'Вы ввели логин и пароль правильно, вы авторизированы<br>';
	}
}
//второй вариант - сокращаем два условия через && - обозначает "и":
if ($_POST['login'] == 'inpost' && $_POST['password'] == '123') {
	echo 'Вы ввели логин и пароль правильно<br>';
}

//третий вариант через || - обозначает "или":
if ($_POST['login'] == 'inpost' || $_POST['password'] == '123') {
	echo 'Вы ввели логин или пароль правильно<br>';
}

// четвертый вариант, когда достпен 1 вариант логина и два варианта пароля "123" или "234":
if ($_POST['login'] == 'inpost' && ($_POST['password'] == '123' || $_POST['password'] == '234')) {
	echo 'Вы ввели логин и пароль правильно<br>';
}
/* Эти блоки потом можно вставить в шапку сайта перед <a><Авторизация/a> и заменить на приветствие "Здравствуйте inpost"
 * Если логин и пароль верны, то пользователя по привествует, если нет, то перейдет к ссылке/кнопке "Авторизация"
 */

3-7;
// Правило №5 Мы не используем exit на сайте, кроме как ОТЛАДКА КОДА;

3-8;
//Функция empty -
$x = 1; //0 или пустая строчка - это false, 1, любой текст и далее true
if(empty($x)) {
	echo 'Переменная НЕ СУЩЕСТВУЕТ или она ПУСТАЯ';
}
if(!empty($x)) { // ! перед функцией означает, что будет выпоняться обратная функция
	echo 'Переменная и существует и она НЕ пустая';
}

3-9;
//PHP supports the following data types: / PHP поддерживает следующие типы данных:
//String - строка
//Integer - Целое число
//Float (floating point numbers - also called double) - числа с плавающей запятой, также называемые двойными
//Boolean - логический
//Array - Множество / массивы
//Object - Объект
//NULL - нулевой
//Resource - ресурс

/*
 * Строка — это последовательность символов, например «Hello world!».
Строка может быть любым текстом в кавычках. Вы можете использовать одинарные или двойные кавычки
 */

/*
 * Целочисленный тип данных — это недесятичное число от -2 147 483 648 до 2 147 483 647.
Правила для целых чисел:
Целое число должно иметь хотя бы одну цифру
Целое число не должно иметь десятичной точки
Целое число может быть как положительным, так и отрицательным
Целые числа могут быть указаны в: десятичной (по основанию 10), шестнадцатеричной (по основанию 16), восьмеричной
(по основанию 8) или двоичной (по основанию 2) нотации.
 */

/*
 * Float - Поплавок (число с плавающей запятой) — это число с десятичной точкой или число в экспоненциальной форме.
 */

/*
 * Булево значение PHP
Логическое значение представляет два возможных состояния: TRUE или FALSE. Логические значения часто используются
в условном тестировании.
 */
/*
 * PHP-массив
Массив хранит несколько значений в одной переменной.
 */

/*
 * PHP-объект
Классы и объекты — два основных аспекта объектно-ориентированного программирования.
Класс — это шаблон для объектов, а объект — это экземпляр класса.
Когда создаются отдельные объекты, они наследуют все свойства и поведение класса, но каждый объект будет иметь
разные значения свойств.
Предположим, у нас есть класс Car. Автомобиль может иметь такие свойства, как модель, цвет и т. д. Мы можем определить
такие переменные, как $model, $color и т. д., чтобы хранить значения этих свойств.
При создании отдельных объектов (Volvo, BMW, Toyota и т. д.) они наследуют все свойства и поведение класса, но каждый
объект будет иметь разные значения свойств.
Если вы создадите функцию __construct(), PHP будет автоматически вызывать эту функцию при создании объекта из класса.
 */

/*
 * НУЛЕВОЕ значение PHP
Null — это особый тип данных, который может иметь только одно значение: NULL.
Переменная типа данных NULL — это переменная, которой не присвоено значение.
Совет: Если переменная создается без значения, ей автоматически присваивается значение NULL.
Переменные также можно очистить, установив значение NULL
 */

//Урок 4: Массивы
/*План:
*Массивы
*Элементы массива
*CRUD массивов и элементов массива
 *
 * Словарь:
 * Массивы (array) - тип данных, позволяющий группировать переменные.
 * Элемент массива (element) - одна переменная в массиве
 * Ключ (key) - имя элемента массива (имя переменной, по аналогии)
 * Индексный ключ (index) - порядковый номер (int)
 * Ассоциативный ключ (assoc) - текстовое имя (string)
 * Значение (value) - содержание элемента массива
 */

4-1;
//МАССИВ
//СОСТАВ МАССИВА: КЛЮЧ => ЗНАЧЕНИЕ, (при этом ЗНАЧЕНИЕ обязательно, а КЛЮЧ НЕТ)
// переменная => значение
//разберем на примере массива - оценки учеников:
{
	$vasya = 5; //ключ = значение (key = value)
	$petya = 4;
	$nastya = 2;
}
// каждая переменная (ключ) в массиве называется: элемент массива
//пишем этот же пример на php:
$users = [
	'vasya' => 5, //переменные выделяем '_' вместо $,так же используем запятую в конце строки, вместо точки с запятой
	'petya' => 4,
	'nastya' => 2,
];
echo '<pre>'; //задаем для красивого вывода - в столбик
//var_dump($users); - выводим данные на экран раньше мы так учили, но это функция отладки, пока отключим
// для вывода на экран лучше использовать print_r
print_r($users); // так и вид лучше

//массив в массиве пример:
$elements = [
	'russia' => [
		'Saint peterbuerg',
		'Moscow',
	],
	'Ukraine' => [
		'Kiev',
		'Sumy',
		'Hlukhiv',
	]
];
echo '<pre>'; // это сейчас пишем, чтобы посмотреть как будет выглядеть при разработке
print_r($elements); //а в реальном коде уже не используем

4-2; //Как дополнить массив?
$country = [
	'Russia',
	'Ukraine',
];
$country[] = 'Israel'; // вот так дополняем массив
// еще пример - наш массив с оценками в школе:
$users = [
	'vasya' => 5,
	'petya' => 4,
	'nastya' => 2,
];
// 1) можем добавить ученика:
$users ['dima'] = 4;
print_r($users); // на экране мы уже увидим [dima] => 4 внутри массива с остальными.
// 2) можем перезаписать данные:
$users ['nastya'] = 3; // Так как 'nastya' уже есть в массиве, то 2 перезапишется на 3
// 3) можем всем поднять на один бал оценки:
++$users['nastya']; // так только Насте
// чтобы поднять всем оценки - нужно использовать циклы (будем изучать в следующем уроке)

//Числовой массив [не задается] называется - индексный.
//А когда ключ имеет [имя] - ассоциативный.

4-3; //чтобы удалить переменную используется следеющая команда (пишется после массива):
unset($elements);

//чтобы удалить определенную строчку с массива пишем:
unset($users ['vasya']); // удаляем имя 'vasya' из массива
unset($country [1]); // или порядковый номер записи (отсчет начинается с нуля)

4-4; // вывод переменной:
echo ($users ['petya'] * $users ['nastya']); // Петя 4 * Настя  2 получим вывод на экран "10"

//вывод из вложенных массивов:
echo $elements['russia'][1]; //выведется 'Moscow'

// еще один вариант через временный файл?
$tmp = 'russia';
echo $elements [$tmp][1];

4-5; // implode — Объединение массивов в строку:
$country = [
	'Russia',
	'Ukraine',
	'Israel',
];
$countries = implode (  ', ', $country); //implode — Объединяет элементы массива в строку
/*добавляем в html полученную переменную:
* <p> Мы работаем со странами: <?=$countries;?>.</p>
* на экран выдаст текст "Мы работаем со странами: Russia, Ukraine, Israel."*/


4-6; // explode — Разбивает строку с помощью разделителя:
$tags = 'php mysql array variable';
$tags_array = explode(' ', $tags); //преобразовываем набор слов в массив
echo '<pre>';
print_r($tags_array); // выдает на экран массивом эти данные
?>
<?php

Урок 9: Начинаем изучать РНР;
/*План:
Как устроен сервер
Переменные
Математические действия
Вывод переменных
Операторы и управляющие конструкции*/

9.1; /*Трассировка пути к сайту:
запуск/виконати/відкрити пишем:*/
tracert phpforum.ru
//так через просомтр пинга можно увидеть где на каком компе в цепочке есть задержка
//Решение с проблемными серверами в пути - прокси-сервер - обход проблемного сервера
//Об этом нужно сообщеть админам и хостинг провайдер заменяет путь

9.2;
//server-side: PHP, Mysql
//client-side: HTML, JS

9.3; //Операторы сравнения: if, else

// 10-й урок Урок 10: Практикуемся с версткой

10-1;
// новая функция: switch
/*
 * Оператор switch похож на ряд операторов IF с одинаковым условием. Во многих случаях вам может понадобиться сравнивать
* одну и ту же переменную (или выражение) с множеством различных значений и выполнять различные участки кода в
* зависимости от того, какое значение принимает эта переменная (или выражение). Это именно тот случай, для которого
* удобен оператор switch.
 */
switch($path) {
	case 'main': //условия
		//сюда прописываем действия (echo или любое другое)
		break;
	case 'payment': //условия
		break; //действия
	default: // - пишем, если ниодно действие не совпало
		$page = 'main';
}
//сокращенный вариант:
switch($page) {
	case 'main': case 'payment': //условия
		//сюда прописываем действия (echo или любое другое)
		break;
	default: // - пишем, если ниодно действие не совпало
		$page = 'main';
}

// пишем такую же конструкцию через if:
if($page == 'main') {
	//действия
} elseif($page == 'payment') {
	//действия
} else { // - пишем, если ниодно действие не совпало
	$page = 'main';
}
// эту конструкцию тоже можем сократить:
if($page == 'main' || $page == 'payment') {
	//действия
} else { // - пишем, если ниодно действие не совпало
	$page = 'main';
}
// расшифровка: если переменная $page не является 'main' или 'payment', то мы ее сделаем 'main'

10-2;
// include - эта функция включает и выполняет указанный файл (указывает какой файл нужно запустить и какие
// переменные оттуда вытянуть или может все содержимое страницы подгрузить с того файла в наш)
//vars.php // отсюда берем информацию

$color = 'зелёное';
$fruit = 'яблоко';

//test.php
echo "Одно $color $fruit"; // Одно
include 'vars.php'; // сюда подключаем
echo "Одно $color $fruit"; // Одно зелёное яблоко

// 11-й урок массивы и циклы

11-1; // Массивы
$country = array();
$country [] = 'Chaos name 1';
$country [] = 'Chaos name 2';
$country [] = 'Chaos name 3';
$country [] = 'Chaos name 4';

echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран
unset($country[2]); // удаляем из массива 2 строчку
// (отсчет идет с 0, поэтому реально это 3-я строчка 'Chaos name 3)
echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран, предыдущая информация не стирается
$country [] = 'Chaos name 5'; // добавляем новую строчку
echo '<pre>'.print_r($country,2).'</pre>'; // вывод на экран, предыдущая информация не стирается
// как видим новая строчка не заняла место 2-й удаленной, а стала 4-й. Каждая новая, не учитывает удаленные,
// а присваивает номера дальше

//Вывод из массива данных на экран:
$var = 'Произвольный текст';
$array = array (
	'key'=>'value',
	'key2'=>'value2',
	'key3'=>'value3',
	'names'=>array('Вася', 'Петя', 'Илона', 'Даша'),
);
echo '<pre>'.print_r($array,1).'</pre>'; // это команда для просмотра структуры массива
echo $array['names'][1]; // На экран вывелся 'Петя'
//кроме print_r есть еще одна функция: var_damp - она отличается от предыдущей тем, что указывает
// дополнительно типы данных и (длину строки) - более профессиональный, но менее удобный.
echo '<pre>';
var_dump($array);
echo '</pre>';

11-2; /* Циклы
 1. while
 3. do-while
 3. for
 4. foreach (для массивов)
 */

11-2-1; //Какой цикл быстрее и почему?
while //- перебирает блок кода до тех пор, пока заданное условие истинно. Циклический просмотр блока кода до тех пор,
// пока выполняется заданное условие. Для этого лучше while.
	//Все эти циклы используют мало ресурсов, поэтому мы не замети проблему с ними.
do...while //- проходит через блок кода один раз, а затем повторяет цикл до тех пор, пока заданное условие истинно
for // - перебирает блок кода указанное количество раз. Используется для счетчика, сделать какое-то определенное
// количество раз определенное действие. Для данного случая будет быстрее for.
foreach //- перебирает блок кода для каждого элемента массива. Используется для обхода массива! Он быстрее всего
// обходит массив.


11-2-2; /* Сравнение циклов через решение одной и той же задачи:
	Условие - нужно вывести на экран следующее:
	The number is: 1
	The number is: 2
	The number is: 3
	The number is: 4
	The number is: 5 */

//с помощью while:
$x = 1;
while($x <= 5) {
	echo "The number is: $x <br>";
	$x++;
}

// с помощью do... while:
$x = 1;
do {
	echo "The number is: $x <br>";
	$x++;
} while ($x <= 5);

//с помощью for:
for ($x = 1; $x <= 5; $x++) {
	echo "The number is: $x <br>";
}

//с помощью foreach:
$numbers = array("The number is: 1", "The number is: 2", "The number is: 3",
	"The number is: 4", "The number is: 5");
foreach ($numbers as $x) {
	echo "$x <br>";
}
//верхний пример foreach можно написать через функцию:
function num($numbers = array("1", "2", "3", "4", "5")) {
	foreach ($numbers as $x) {
		echo "The number is: $x<br>";
	}
}
num ();

11-2-3a; // while - принцип написания похож на if
//Если нужно производить выполнение операторов цикла в PHP скрипте только при выполнении определённого условия,
// то в PHP используется цикл while
//Синтаксис цикла while в PHP
while(условие)
{
	Операторы цикла через ;
     }
//  "=" - это не равно, а базовый оператор присвоения, устанавливает значение
//"==" - это уже равно, "===" - тождественно равно (переменные равны и имеют тот же тип)
$x = 1;
echo $x.'Текст до цикла<br>'; // выведется: '1Текст до цикла'
while($x == 1 || $x == 2 || $x == 3) {
	echo 'Произвольный текст';
	$x = $x + 1; // увеличиваем переменную на 1 вплоть до 4
	//можно так же сократить это же выражение:
	// ++$x;
	echo $x.'<br>'; // выведется: 'Произвольный текст2', и так далее до 'Произвольный текст4'
}
echo 'Текст после цикла'.$x; // выведется последняя строчка: Текст после цикла4

//Операторы инкремента и декремента
//++$a	Префиксный инкремент	Увеличивает $a на единицу, затем возвращает значение $a.
//$a++	Постфиксный инкремент	Возвращает значение $a, затем увеличивает $a на единицу.
//--$a	Префиксный декремент	Уменьшает $a на единицу, затем возвращает значение $a.
//$a--	Постфиксный декремент	Возвращает значение $a, затем уменьшает $a на единицу.


//второй вариант:
$x = 1;
echo 'Текст до цикла<br>';
while($x < 10) {
	echo $x.'Произвольный текст<br>'; // выведется 9 раз
	++$x;
} echo 'Текст после цикла'.$x;

// тот же второй вариант, только уже в html в виде таблицы:
$x = 1;
echo '<table border=1"><br>';
while($x < 10) {
	echo '<td>';
	echo $x.') Произвольный текст<br>'; // выведется 9 раз
	++$x;
} echo '</td>';


//Использование цикла while более корректно для поиска корней уравнения, потому что мы изначально не знаем, в каком
// диапазоне находится корень, а использование цикла for предполагает, что мы это знаем.
//Пример скрипта на PHP с использованием цикла while. Скрипт ищет решение уравнения x²-20x+100=0
    $y = 100;
    $i = 0;
    while($y != 0) {
		$i = $i + 1;
		$y = $i * $i - 20 * $i + 100;
	}
   echo "Решение уравнения {$i}"; //Решение уравнения 10

// Рассмотрим дальше на примере одной и той же таблицы, на html и с помощью циклов:
/* тут два ряда в таблице, в каждом из которых 3 ячейки
 	<table border="1" cellpadding="5">
		<tr>
			<td>1:1</td>
			<td>1:2</td>
			<td>1:3</td>
		</tr>
		<tr>
			<td>2:1</td>
			<td>2:2</td>
			<td>2:3</td>
		</tr>
	</table>
 */

// второй вариант той же таблицы:
$i = 1; // указывает с какого числа начинается отсчет
echo '
	<table border="1" cellpadding="5">
	<tr>';
while($i <= 3) { // повторяем ячейки 3 раза
	echo '<td>1:'.$i.'</td>'; // содержимое ячейки
	++$i; // увеличение переменной i на единицу
}
	echo '</tr>
		<tr>
			<td>2:1</td>
			<td>2:2</td>
			<td>2:3</td>
		</tr>
	</table>';

//третий вариант - мы так же можем использовать циклы в циклах:
// тут выводим на экран счет от 1 до 9 три раза с указанием порядкового номера цикла:
$i = 1; //начальные условия
$x = 1; //начальные условия
while($i <=3) { // количество циклов
	while($x < 10) { // цикл вывода цифр от 1 до 9
		echo $x; // вывод на экран цифры
		++$x; // следующее добавление +1 вплоть до 9
	}
	echo $i;
	++$i; // после прохождения цикла повышает $i на единицу: $i = 2
	$x = 1; // а $x сбрасывается до единицы: $x = 1, после чего цикл повторяется
	// пока не получим $i = 3, после чего цикл дойдет до конца и завершится
}
// вот что в итоге выведется на экран: 123456789112345678921234567893 (где 1,2,3 после 1-9 это $i)

//Пример ошибочного цикла:
$x = 10;
while($x < 10) {
	echo $x;
} // тут по результату ничего не ведет на экран, так как $x = 10 и не может быть < 10

11-2-3b; // DO WHILE - аналогична while, только отличие, что в начале у нас в обязательном
// порядке первая интерация цикла, то есть первый вывод будет работать.
echo 'Перед циклом<br>';
$x = 1;
do { // do - что делать?
	echo $x.'<br>'; // выводится
	++$x;
} while ($x < 10); // обратить внимание мы местами поменяли действия с условием
echo 'После цикла';
//мы тут делаем определенное действие, пока выполняется условие
//первая проверка цикла проходит теперь не в начале цикла, как было при while,
//а после первого выполнения, то есть первая часть do выполнится всегда, даже если условие
// не удовлетворяет
1:23:40 / 1:57:27;

11-2-3c; //FOR
echo 'Перед циклом';
for($x = 1; $x <10; ++$x) {
	echo $x.'<br>';
}
echo 'После цикла';

// цикл в цикле
echo 'Перед циклом'; // приблизительно так нужно будет сделать домашку.
for($x = 1; $x <= 5; ++$x) {
	for($y = 1; $y <= 10; ++$y) {
		echo $x.':'.$y.'<br>';
	}
}
echo 'После цикла';

11-2-3d; //FOREACH - используется для перебора массивов
$names = array('', 'Вася', 'Петя', 'Илона', 'Даша'); // наш исходный массив
echo '<pre>'.print_r($names,1).'</pre>'; // просмотр исходного массива, в коде не нужно писать - это для себя
//$k - ключ (сокращение от key), $v - значение переменной (сокращенное от value)
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo 'Квартира = '.$k.', Владелец = '.$v.'<br>';
}

//второй вариант (массив тот же):
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $v.', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//третий вариант (меняем только способ вывода, но резельтат будет как в варианте два):
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $names[$k].', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//Четвертый вариант - самый короткий без создания ключей (результат аналогичный второму):
echo 'В нашем доме живут: <br>';
foreach($names as $v) { // ключ в этом способе не создаем, только значение передаем, зато быстрее так обрабатывается
	echo $v.', '; // получили вывод всех имен в виде:"В нашем доме живут: , Вася, Петя, Илона, Даша,"
}
echo '</br>';

//Пятый вариант - перебор массива (ключ и значение задаем прямо в массиве):
$names = array('Name1'=>'Вася', 'Name2'=>'Петя', 'Name3'=>'Илона', 'Name4'=>'Даша'); // Name - ключ, Вася - значение
echo '<pre>'.print_r($names,1).'</pre>'; // просмотр исходного массива, в коде не нужно писать - это для себя
//$k - ключ, $v - значение переменной
echo 'В нашем доме живут: <br>';
foreach($names as $k=>$v) {
	echo $k.'=  '.$v.'</br>';
} //получим:
//В нашем доме живут:
//Name1= Вася
//Name2= Петя
//Name3= Илона
//Name4= Даша

11-2-4; // У всех четырех циклов есть специальные функции: break и continue;
// break - обрывает цикл;
$names = array('Вася', 'Петя', 'Илона', 'Даша');
echo '<pre>'.print_r($names,1).'</pre>';
foreach($names as $k=>$v) {
	if ($v == 'Илона') { // если цикл дошел в массиве до "Илона", то
		break; // то цикл останавливается
	} echo $v.', '; // на экран выведется только "Вася, Петя,"
}

// continue - заканчивает данную итерацию цикла;
$names = array('Вася', 'Петя', 'Илона', 'Даша');
echo '<pre>'.print_r($names,1).'</pre>';
foreach($names as $k=>$v) {
	if ($v == 'Илона') { // если цикл дошел в массиве до "Илона", то
		continue; // то цикл оборвется и "Илона" не выведется
	} echo $v.', '; // на экран выведется только "Вася, Петя, Даша,"
}


 Урок 12:; //Домен и хостинг
//Хостинг
//Домен
//DNS
//Сайт hostinger.ru
//FTP-клиент Far
//FTP-клиент FileZilla
//Настройки сервера: phpinfo() - функция для просмотра версии php, программ, IP и прочего на сервере.
// Через этот сайт можно получить уязвимости сайта, поэтому после проверки удаляем со страницы


Урок 13:; //Пользовательские функции
/*PHP имеет более 1000 встроенных функций, кроме того, вы можете создавать свои собственные пользовательские функции.
Функция — это блок операторов, который можно многократно использовать в программе.
Функция не будет выполняться автоматически при загрузке страницы.
Функция будет выполнена вызовом функции.*/

13-1; //Считаем количество элементов в массиве:
// допустим нам в одном коде нужно посчитать количество жильцов и стран в массивах, похожие действия
$array = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис',
);
$count = 0; // создание переменной, откуда начинается счетчик
//Подсчеты - счетчик жильцов
foreach($array as $v) {
	++$count; //count — Подсчитывает количество элементов массива
}
//вывод
echo 'В нашем доме живут ('.$count.') ';

foreach($array as $v) { //вывод массива на экран + добавление счетчика жльцов
	echo $v.', ';
} // получим на экране: "В нашем доме живут (5) Петя, Ульяна, Даша, Маша, Денис,"

//считаем количество стран в массиве:
$country = array(
	'Украина', 'Польша', 'Франция',
);
$count = 0;
foreach($country as $v) {
	++$count;
} echo 'Стран в массиве= ('.$count.') ';

/* Бывают коды очень большой длинны 1000+ строк и в нем может быть некоторый участок кода,
 * который будет повторяться в некоторых местах как в примере выше - подсчет жильцов и стран
 * в этом случае на помощь приходит функция. Они аналогичны с изученными инклюдами:
 * include 'text.php' - подставляем участок кода в определенный файл
 */
//Функция count:
$count = count ($array);
$count = count ($country);

//Еще одна особенность - нам не обязательно результат помещать в какую-то переменную, мы можем вызвать
//функцию прямо внутри кода:
$array = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
echo 'В нашем доме живут ('.count($array).'):';
foreach($array as $v) {
	echo $v.', ';
} // получим вывод: "В нашем доме живут (6):Петя, Ульяна, Даша, Маша, Денис, Степан,"


13-2; //Вызов (запуск) функции:
//Запомнить: страница php - это программа, а функция - это подпрограмма
//func (); - у разных функций свои названия
//Создание функции:
function count2 () { // называем count2, так как count уже было, а повторять нельзя
	// тут пишем тот код, который должна выполнять функция
	echo 'Произвольный текст из функции<br>';
} //дальше мы эту функцию вызываем:
echo 'Текст до функции<br>';
count2(); // подставится "Произвольный текст из функции"
count2(); // подставится "Произвольный текст из функции"
count2(); // подставится "Произвольный текст из функции"
echo 'Текст после функции';

/* у функции есть некоторые особености - переменные, котрые мы создаем за пределами функции - не существует внутрии функции
 * если перед function count2 строчкой выше прописать $var1 = 'text'; то эта переменная никак не повлияет на функцию.
 * с другой стороны если переменную новую разместить внутри функции, то она не будет выполняться вне функции
 * разберем на примере предыдущей функции:
 */
$var1 = 'text1';
function count2 () {
	//echo $var1; //ошибка
	$var2 = 'text2 ';
	echo $var2;
	echo 'Произвольный текст из функции<br>';
}
//echo $var2; //ошибка
echo 'Текст до функции<br>';
count2(); // подставится "text2 Произвольный текст из функции"
count2(); //
count2(); //
echo 'Текст после функции';
/*
 * Функции полностью независимы. Хоть они и находятся в одном месте, все равно они друг друга не видят.
 * Функция должна быть независимой и всегда работать так как надо. Переменные с однаковым названием (если так получилось)
 * выполняются отдельно и не зависят друг от друга. Переменные внутри функции не видны за пределами функции. И те
 * что за пределами функции не видны внутри функции.
 */


13-3; //как передать переменную из-вне функции внутрь функции? Рассмотрим на примере $var1, для этого размещаем ее
// внутри круглых скобок (в коментах очередность действий выполнения):
$var1 = 'Степан'; // 1-е - задаем переменную
function count2 ($t1, $t2, $t3) { // 3-е отправляем на выполнение функции уже не $var1, а значение переменной $t1
	echo $t1.'<br>'.$t2.'<br>'.$t3.'<br>'; //4-е действие - выводим на экран
}
echo 'Текст до функции<br>';
count2($var1, 'Пантера', 2022, 2023); // 2-е переносим в этот код ($var1) кроме того прописываем новые, не извне
//count2(); // тут пришлось закоментить, потому что выдает ошибку
echo 'Текст после функции';
//2023 не выведется, так как в функции function count2 не введено переменную $t4 и в эхо ее тоже нет.
//если в функции убрать $t3 - выдаст ошибку, так как в функции передавать больше значений можно, меньше нельзя.


13-4;  // разбираем что еще можно делать с функцией:
function hard ($num1, $num2) { //в круглых скобках передается аргумет функции. Вы можете добавить столько аргументов,
	// сколько хотите, просто разделите их запятой. Аргумент подобен переменной.
	$sum = ($num1*5+$num2*10)/2 - 1;
	$sum = 'Результаты подсчетов: '.$sum;
	echo $sum;
}
//затем в произвольном месте, не обязательно рядом, можно даже через 100-200 строк, потом вызываем нашу функцию:
hard(5,3);
// и смотрим результат: "Результаты подсчетов: 26.5" - расчет произведен.


13-5; // Улучшаем эту же функцию добавбляя новые условия выполнения через IF и ELSE:
function hard ($num1, $num2) {
	$sum = ($num1*5+$num2*10)/2 - 1;
	if ($sum <20) {
		$sum = 'Результаты подсчетов: '.$sum;
		echo $sum;
	} else {
		echo 'Слишком большое число у переменной (результат больше 20)';
	}
}
hard(1,3);
echo '<br>';
hard(30,40);


13-6; //О выводе на экран:
/*
 * Принято так, что функция не должна содержать вывод на экран, то есть echo не должно быть в функциях
 * Функции должны получать какие-то данные и возвращать какие-то данные. А захотим ли мы вывести какие-то
 * данные на экран мы должны уже сами решать.
 * Теперь как это происходит - напишем эту же функцию, только без вывода информации на экран:
 */
function hard ($num1, $num2) {
	$sum = ($num1*6+$num2*10)/2 - 1;
	if ($sum <20) {
		$sum = 'Результаты подсчетов: '.$sum;
		return $sum; // меняем echo на return
	} else {
		return 'Слишком большое число у переменной (результат больше 20)'; // меняем echo на return
	}
}
$temp = hard(1,1); // Результаты подсчетов: 7
echo $temp;


13-7; // сами пишем функцию, которая должна считать:
$names = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
function count2 ($names) {
	$count = 0; // теперь мы должны переменную $count посчитать
	foreach($names as $v) { // между ")" и "{" нельзя ставить ";" - сейчас поставил и потом искал пол часа ошибку!
		++$count;
	}
	return $count; // 6
}
echo count2 ($names); //6


13-8; // Обычно это все выводится проще, благодаря встроенным функциям:
$names = array(
	'Петя', 'Ульяна', 'Даша', 'Маша', 'Денис', 'Степан',
);
$count = count ($names);
echo 'итого '.$count.' имён'; // echo "итого .$count. имён"  - так тоже можно писать
// "итого 6 имён"


13-9; // разберем более сложные функции на примере задания из домашки (создать таблицу и окрасить ячейки в разные цвета):
function makeTable ($x,$y) { //здесь можно проставить цифры, но все равно если мы внизц в "echo makeTable (5,3);"
	// зададим другие цифры, то приоритет к исполнению функции отдастся цифрам из "echo makeTable (5,3);"
	$text = '';
	$text .= '<table>';
	for($i=1; $i<=$y; ++$i) {
		$text .='<tr>';
		for($i2=1; $i2<=$x; ++$i2) {
			$color = 'white'; // цвет всех ячеек
			if($i == 2 && $i2 == 3) {
				$color = 'red'; // ячейка 2:3 будет красная
			} elseif ($i == 2 && $i2 == 4) {
				$color = 'green'; // ячейка 2:4 будет зеленая
			} elseif ($i == 3) {
				$color = 'blue'; // третья строка будет синяя
			}
			$text .= '<td style="background-color:'.$color.';">'.$i.':'.$i2.'</td>';
		}
		$text .='</tr>';
	}
	$text .= '</table>';
	return $text; // return работает по аналогии с break - завершает выполнение текущей функции
	//return может возвращать только одну переменную!!! Если записать две через запятую, то выдаст ошибку.
	// но есть лазейка - можно вернуть несколько - массивом.
}
echo makeTable (5,3); // задаем количество столбцов и строк


13-10;// Функция count
//count — Подсчитывает количество элементов массива или Countable объекте
count(Countable|array $value, int $mode = COUNT_NORMAL): int
//Подсчитывает все элементы в массиве, если используется массив. Если используется объект, который реализует
//интерфейс Countable, функция возвращает результат выполнения метода Countable::count().


13-11; //Функция preg_match
//preg_match — Выполняет проверку на соответствие регулярному выражению
preg_match(
    string $pattern,
    string $subject,
    array &$matches = null,
    int $flags = 0,
    int $offset = 0
): int|false
// Ищет в заданном тексте subject совпадения с шаблоном pattern.

13-12; // Функция по регистрации пользователя и проверки условий (это не регистрация, а просто пример функции):
function addToDB ($login, $password) {
	// Процедура добавления пользователя в общую Базу Данных
}
function reg ($login, $password) {
	if ($login == 'Vasya') { // Если логин 'inpost' совпадет с логином в базе 'Vasya', то
		return false; //в регистрации отказано
	}
	addToDB ($login, $password);
		return true; // регистрация прошла, добавили в базу
}
if (reg('Vasya', '123')) {
	echo 'Вы успешно зарегистрировались, поздравляем!';
} else {
	echo 'Такой логин уже есть в базе данных, вы не зарегистрировались!';
}


13-13-1; //Функция по вызову текста:
function textMake ($text) {
	$text = 'Разные '.$text.' и буквы'; // эта строчка привязывает переменную извне функции к функции
	return $text;
}
$text = 'слова'; // этот блок с переменными можно разместить и перед функциями, разницы нет
$text = textMake($text); // вызов переменной текст - тут можно в левой части вместо $text можно заменить на другую переменную
echo $text; // вывод переменной текст на экран
// вывод на экран: "Разные слова и буквы"

13-13-2; //Предыдущую же функцию можно сократить благодаря значку и: "&" перед переменой в функции - "склеивание переменных":
function textMake (&$text) {
	$text = 'Разные '.$text.' и буквы'; // убрали "	return $text;"
}
$text = 'слова';
textMake($text); // убрали переменную в левой части строки
echo $text;

13-14; /* Домашнее задание:
 * Сделать калькулятор. 3 входящих параметра:
 1. Первое число, 2. Второе число, 3. Действие (плюс, минус, умножить, поделить).
 * По примеру: function calc($num1,$num2,$action)
  * 4. Если $action не задан, то по умолчанию должно складывать переменные.
 */

 14; // Урок 14: Методы передачи данных GET и POST, работа с формами

 14-1; /* Формы - это блочные элементы, наподобие div, внутри которіх содержатся формы. Форм может быть несколько
на странице (пример: поле авторизации и поле регистрации). Формы сами по себе независимые.
*Атрибуты, которые есть у нас в форме:
1) action - указание файла, для отработки, этот атрибут указывать нужно всегда. Этот файл создаем заранее. Если мы
 хотим сделать отправку и обработку страницы на одной странице, а это лучший вариант для одностраничного сайта, то нам
 достаточно поле названия файла оставить пустым:
<form action="">
2) method - метод отправки переменных $_POST или $_GET: method="post" или method="get".
 $_POST и $_GET - это суперглобальные переменные, которые приходят из формы. Данные переменные
 пишутся таким синтаксисом.
 GET и POST - это наши два массива. Изначально они созданы пустыми. Это тожде самое, что если бы мы писали
 $_GET = array(); - так создаются пустые массивы
 Если мы передаем данные методом GET и POST, то эти массивы наполняются.
3) intime -
	*/

	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
	?>

<form action="" method="get">
	GET	<input type="text" name="login"> <!--слово GET перед input отображает название поля ввода-->
	<input type="text" name="password">
	<input type="submit" name="submit" value="submit">
</form>
<!--можно сделать вообще две формы для каждого массива отдельно:-->
<form action="" method="post">
	POST	<input type="text" name="login"> <!--слово POST перед input отображает название поля ввода-->
	<input type="text" name="password">
	<input type="submit" name="submit" value="submit">
</form>

<?php
/* после этого на экран выведется:
GET:
Array
(
    [login] => roman.nik
    [password] => 1321
    [submit] => submit
)
POST:
Array
(
    [login] => inpost
    [password] => 3231321
    [submit] => submit
)/
Напомню, что [login] и [password] - это ключ переменной, а inpost и 3231321 - это уже значение переменной
*/

14-2;  // Разберем еще пример - авторизация на сайте:
echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
?>

<form action="" method="post">
	<input type="hidden" name="hide" value="скрытое значение">
	<div>Заполните логин:<input type="text" name="login"></div>
	<div>Заполните пароль:<input type="password" name="pass"></div>
	<div style="padding:15px">
		Пол: <br> <!--тег <label> используется для придания интерактивности тексту - можно включить кнопку нажатием
		 на текст "Мужчина"	так же label работает и с checlbox-->
		<label>Мужчина <input type="radio" name="gender" value="Мужчина"></label> |
		<!--в радио мы используем одинаковый тип и имя-->
		<label>Женщина <input type="radio" name="gender" value="Женщина"></label>
		<!--здесь value - это то что выведется текст в массив-->
	</div>
	<div style="padding:15px">
		Любимый напиток: <br> <!--так же label работает и с checkbox-->
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
		<!--в отличие от радио в чекбоксе при отправке данных выведется только последняя отмеченная запись.
		Чтобы этого избежать необходимо задать разные имена name (like 1, like2, ...) или записать в массив like []-
		создастся новый массив внутри массива $_POST
		Передачу данных в мссив возможна и в остальных местах, но в чекбоксе они обязательны-->
	</div>
	<div><input type="submit" name="submit" value="Отправить данные" style="border-style:hidden; border-radius:10px;
	background-color:#90ff90"></div>
</form>
<!--type ="button" в формах не используется, в основном в через JS делается.
тип = hidden - используется для указания кому отпарвляем остальные вводимые поля
name - это наш ключ переменной.
value - содержание значения данного поля
после каждой отправки данных страница перегружается и наново записываются данные в массив $_POST-->

<?php
14-3; //сокращенная форма работы с суперглобальной переменной и записью в массив:
echo '<p>Ваш логин: '.@$_POST['login'].'</p>'; // @ - этот значек убирает сообщения об ошибках.
?>
<form action="" method="post">
	<div>Заполните логин:<input type="text" name="login"></div>
	<div>Заполните пароль:<input type="password" name="pass"></div>
	<div><input type="submit" name="submit" value="Отправить данные"></div>
</form>

<?php
14-4; // Сокращенная форма для checkbox
echo '<p> Мы любим: '; //здесь как в примере 14-3 не получится одной строчкой сделать
foreach($_POST['like'] as $v) { // придется использовать foreach
	echo $v.','; // указываем выводить через запятую: "Мы любим: Чай,Молоко,"
}
/* освещим память - эту же функцию можно было бы написать и на основе того, что уже раньше учили:
$like = ''; // пустые ковычки - это пустота
foreach($_POST['like'] as $v) { // foreach используем для наполнения $like
	$like .=$v.','; // ".=" это мы переменную дописываем
}
echo '<p>Мы любим: '.$like.'</p>';
 */
?>
<form action="" method="post">
	<div style="padding:15px">
		Любимый напиток: <br>
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
	</div>
	<div><input type="submit" name="submit" value="Отправить данные"></div>
</form>

<?php
14-5; // Для проверки была ли отправлена информация после нажатия на кнопку в примере 14-2 на экран выводилось:
//"[submit] => Отправить данные"
// можно так же проконролировать отправку с помощью  функции isset:
	if(isset($_POST['submit'])) {
		echo 'Форма отправлена';
	}
// проверяем передались ли конкретніе данные, чтобы мы с ними работали

14-6; // Проверка для checkbox через isset:
if(isset($_POST['submit'])) {
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';

	$like = '';
	if(isset($_POST['like'])) {
		foreach($_POST['like'] as $v) {
			$like .= $v.',';
		}
		echo '<p>Мы любим: '.$like.'</p>';
	}
}

14-7; // Чтобы защитить от взломов сайты нужна проверка авторизации с базой
if(isset($_POST['login'], $_POST['pass'])) { // эта часть не даст войти без заполнения форм
		//в связи с этим блок ниже не будет выполняться
	echo $_POST['login'];
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
}
14-8;/*Безопасность: любая ошибка - это потенциальная угроза взлома. Хакеры используют ошибки для взлома.
 Никогда нельзя доверять входящим данным. Если мы хотим сделать наш скрипт, который будет
 работать непосрадственно с логином и паролем, то мы должны проверить - были ли передан логин и пароль!
 Нужно ловить не нажатие кнопки, а ловим существование логина и пароля! Тогда мы сможем его вывести и
 поработать с конкретным логином и паролем.
 Главное правило - если мы работаем с логином - мы должны проверять существование логина,
 если с паролем, то существование пароля. И так со всеми данными.*/

//	При этом если нам нужны какие-то значения по умолчанию, допустим мы передаем логин и пароль, а остальные
//	разделы формы пользователь не заполнил, то можно сделать так:
	if(isset($_POST['like'])) {
		echo 'Человек любит'.$_POST['like'][0];
	} else {
		echo 'Человек ничего не любит'; // выведется на экран, если ничего не отметил в чекбоксе.
	}

14-9 // Безопасность: Любые переменные и данные которые мы сами заполняем - безопасные, напрмер:
$x = 10;
	echo $x;
/* А данные, которые запоняются из формы - суперглобальные $_POST и $_GET вот их заполняет клиент, их и нужно проверять.
Если данные переданы правильно, то выполнять какие-то действия, а если неправильно переданы, то нужно вернуть его
обратно на нашу форму.*/

14-10  //полный текст кода с проверкой авторизации:
if(isset($_POST['login'], $_POST['pass'])) {
	echo $_POST['login'];
	echo 'GET: <pre>'.print_r($_GET, 1).'</pre>';
	echo 'POST: <pre>'.print_r($_POST, 1).'</pre>';
	if(isset($_POST['like'])) {
		echo 'Человек любит'.$_POST['like'][0];
	} else {
		echo 'Человек ничего не любит';
	} echo "Вы успешно зарегистрировались";
} else {// если регистрация не прошла, то выполняется блок кода расположеного ниже - скобка открылась
?>
<h1>Форма</h1>
<form action="" method="post">
	<input type="hidden" name="hide" value="скрытое значение">
	<div>Заполните логин:<input type="text" name="login" value=""></div>
	<div>Заполните пароль:<input type="password" name="pass" value=""></div>
	<div style="padding:15px">
		Пол: <br>
		<label>Мужчина <input type="radio" name="gender" value="Мужчина"></label> |
		<label>Женщина <input type="radio" name="gender" value="Женщина"></label>
	</div>
	<div style="padding:15px">
		Любимый напиток: <br>
		<label>Кофе <input type="checkbox" name="like[]" value="Кофе"></label> |
		<label>Чай <input type="checkbox" name="like[]" value="Чай"></label> |
		<label>Молоко <input type="checkbox" name="like[]" value="Молоко"></label>
	</div>
	<div><input type="submit" name="submit" value="Отправить данные" style="border-style:hidden; border-radius:10px;
	background-color:#90ff90"></div>
</form>
<?php } ?><!-- скобка закрылась-->
<!--Лайфхак: Вставка большого кода html в php:
для того, чтобы вывести большой код html нам не обязательно писать echo '' (где внутри кавычек писать html код на
много строчек). Достаточно закрыть php и дальше писать html, а в конце открыть php и закончили наше условие,
как в примере выше <?php } ?> -->

<?php
14-12 Различия между $_GET и $_POST - работа с ними полностью аналогична, нужно только указывать так же
 метод принятия в форме <form action="" method="post">. Абсолютно аналогичное действие, за исключением маленьких
 деталей.
 POST - это наши скрытые данные, засекреченные, когда мы данные отправляем на нашу страничку они отправляются,
 но мы их не видим куда отправились, то есть нигде не отображаются в нашем браузере. То есть наш массив передается
 в скрытом типе. Еще у POST можно передавать картинки.
 GET - метод передачи данных через адресную строку. При отправке методом GET мы получаем очень длинную адресную строку:
  /testphp1.ua/index.php?hide=скрытое+значение&login=132123&pass=1231231&gender=Женщина&like%5B%5D=Чай&submit=Отправить+данные
 - это строчка состоящая из ключей=значение, ... (+ это пробел)
  POST в адресной строке наши данные НЕ передает!
 Еще отличия:
 1) Методом GET нельзя передавать файлы,
 2) GET - ограничен по длине (нельзя передвать большие тексты - длинна поддержки зависит от браузера) -
 в последнее время эта проблема ушла с развитием браузеров.
 3) GET - виден на экране, в том числе и пароль, который в форме скрыт звездочками!
 4) Из плюслов: GET хорош при передаче ссылок из поисковых запросов:
 https://www.google.com/search?q=%D1%87%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+php&rlz=1C1SQJL_ruUA888UA888&oq=%D1%87%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+php&aqs=chrome..69i57j0i512l6j69i61.4942j0j1&sourceid=chrome&ie=UTF-8
 это ссылка из гугля запроса "что такое php".
5) GET - используется для навигации (использование ЧПУ, для SEO раскрутки)


14-13 // Разбор домашки к уроку 13 и задание к 14 уроку:
function calc($num1, $num2, $action='plus') {

}
/*Домашка сделать форму:
1) два поля для ввода данных
2) 4 радио для + - * /
3) сделать кнопку "отправить"
4) вывести число (ответ) без разницы где вверху или сбоку: 5+10 = 15 (отобразить входящие данные, саму формулу и результат).
5) не забывать пользоваться проверкой isset входящих данных, чтобы существовало значение первое и значение второе
if(isset($_POST['num1'], $_POST['num2'])) {..} нужно ввести значение 1 и 2 и отправить в нашу форму*/



Урок 15: //Улучшаем качество кода, include+GET, Суперглобальные массивы
/*План:
Ошибки домашек
Создаем навигацию include + GET
Изучаем область видимости переменных
Константы
$_REQUEST, $_SERVER, $GLOBALS
Самостоятельно изучаем пакет функций*/

15-1  //Навигация с GET - разбираем домашку №15:
$_GET = 'index.php?page=contacts'// переменная GET - это то что у нас в адрессной строке+?page=какая-нибудь страничка
$_GET['page'] = 'contacts'; // это говорит, о том, что мы можем спокойно передавать данные, используя навигацию,
// используя наши теги ссылок.


if(isset($_GET['page'])){ //если страница существует
//echo '<h1>'.$_GET['page'].'</h1>';
} else { //если нет, то создастся
$_GET['page'] = 'index';
}
?>
<div id="header">
	Навигация:
	<a href="15.php?page=main">Главная</a> |
	<a href="15.php?page=history">Наша история</a> |
	<a href="15.php?page=contacts">Контакты</a> |
	<a href="15.php?page=aboutus">О себе</a>
</div>
<div id="content">
	<?php include $_GET['page'].'.php';?> <!-- '.php' нужно обязательно указывать-->
</div>
<div id="footer">
	Тут пишем копирайты.
</div>

<?php
15-2 // Обычные функции с обычными переменными:
$x=5; //если х=5, то выведется на экран 10, если другая цифра - то ошибку выдаст. В javascript это рабьотает
// по другому и функция выполнится
if($x==5) { /* если функция соотвествует условию, то функция создастся, если нет, то не создастся */
function test($x) {
echo ($x*2);
 }
}
test($x); // получим на экране "10"

// а вот другой пример - внутри функции и вне - одна и та же переменная:
$x=5; //задали, но внутрь функции она не попадет
function test($x) { //внутри функции переменная останется внутри функции
	$x=10;
}
test($x) // а на экран выведется "5"

15-3 // Суперглобальные фукнции - в отличие от предыдущего примера, где переменные
//выполняются только внутри функции или только вне суперглобальные действуют везде.
//мы можем задавать так же переменные:
$x=5; // - локальные переменные
echo $x; //если только это оставить, то выведется "5"

unset($x); //почемуто не очистила предыдущую переменную :)))
$x=7;

$x=10;
echo $x; //в этом случае уже "510"

//Мы так же можем создать константу с помощью define - это такая переменная, которая пишется без знака $ и которая
// не может быть исправлена дальше по коду.
define("CON", "Привет, мир!"); // мы создали функцию в глобальной области видимости
echo CON; //пишем без ковычек!
function test() {
echo CON; // интересно передастся ли константа внутрь функции?
}
test();// да вывелось на экран: "Привет, мир!Привет, мир!"
//данная константа видна и за пределами функции и внутри функции!

//Когда использовать константы? Например для счетчика - указать, что на странице прилюбых раскаладах будет
// выводиться только 12 новостей:
define ('NEWSONPAGE', 12);
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>';//выводим новости 12 раз.
}
//если появится задача сделать 3 блока по 12 новостей, то просто копируем цикл for (3 строчки последние)
// еще два раза и всё.
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>';//второй блок
}
for($i = 1; $i <=NEWSONPAGE; ++$i) {
echo $i.'<br>'; //третий блок
}
15-4 /*Кроме констант есть и другие способы вывода в глобальную область - глобальные переменные:
	1) $_GET;
	2) $_POST - эти переменные и так видны внутри функции и их не обязательно туда
 передавать, но по канонам програмисты считают что функции создаются для того,
 чтобы туда можно было передать какие-то значения и вернуть какие-то значения:*/
 functio test() {
	 echo $_POST['x'];
	 echo $_POST['y'];
	 echo $_POST['z'];
} test ();
 /* 3) $_FILES - сюда будет попадать все, что содежится в <input type="file"/>
 Разберем на примере одновременного использования всех трёх:*/
$_GET['page'];
$_POST['login'];
$_FILES['file'];
?>
<form method="post" action="" name="page">
	<input type="text" name="login">
	<input type="file" name="file" accept="image/*">
</form>
<?php
/*  4) $_REQUEST - дубль от $_GET, $_POST - усложним задачу - у нас два запроса
GET и POSt с именем'page' */
$_GET['page'];
$_POST['page'];
$_POST['login'];
$_FILES['file'];

$_REQUEST = array(
	'page' <- $_GET // page пападет из GET
	'login' <- $_POST //login из POST
);
/* но в наших занятиях $_REQUEST использовать не будем, потому что работая
в наших скриптах мы должны делать полностью "прозрачной" нашу работу, так
чтобы это было очевидно - что за переменная, откуда пришла и что делает */

/*  5) $_COOKIE;
    6) $_SESSION; - работу куки и сессии мы разберем на отдельном уроке.
	7) $_ENV; - не будем вообще разбирать.
	8) $_SERVER;
	9) $_GLOBALS; - сегодня рассматривать не будем
расмотрим $_SERVER: */
echo '<pre>'.print_r($_SERVER,1).'</pre>'; // получаем полную информацию
// о сервере. Данную переменную в коде осталять нельзя, чтобы не отдать хакерам наш
// сайт. Так же нельзя показывать хакерам phpinfo();
//но есть и полезные фишки - можно блокировать айпи:
if($_SERVER['REMOTE_ADDR'] == '127.1.1.17') {
	echo 'Извините вам нет доступа';
}
//или наоборот запретить доступ не с нужного айпи:
if($_SERVER['REMOTE_ADDR'] != '127.1.1.17') { //настройка чтобы только у вас был доступ к серверу
	exit; //остановка скрипта
}

15-5 //Домашняя работа №15:
/*Завершить верстку макета и сделать рабочую навигацию с использованием include + GET. Сделать copyrights по виду:
2013 или 2011-2013 используя константу и функцию date().
Добавить в навигации еще один пункт меню "Админ панель или админ" и данную навигацию выводить только для пользователей
определенного IP. Кроме того внутри страницы main сделать проверку: if($_SERVER['REMOTE_ADDR'] != '127.1.1.17') ...
нужно заблокировать определенный IP адресс и выводить ссылку, то мы через эхо выводим ссылку на нашу страничку админки,
 если не совпадает, то на админку ссылку не выводим.
Так же самостоятельно изучить пакет проверок на php.net: isset, empty, is_array, is_bool, is_double, is_float, is_int,
 is_integer, is_null, is_numeric, is_real, is_string.
Приведение к типу: int, string, array, float.
*/
$var = 10;
$var = (int)$var;
$var = (string)$var;
// в домашке сделать тесты для себя:
$var = '1текст1';
echo (int)$var;
//еще протестировать:
$var = '1111';
$var = 'текст';
$var = 'текст2221';
$var = '1441текст';
$var = array ('пиво');
$var = (int)$var;
echo $var;

/* Еще выучить: Функции: gettype, count, include, include_once, require, require_once, rand, date */


Урок 16: //Фильтрация данных, $_COOKIE, $_SESSION

/*План:
Фильтрация данных
Безопасность при include
filter_var для адресов и email
int, float - для чисел
in_array для определённых множественных вариантов
$_COOKIE: Чтение, создание, редактирование и удаление
$_SESSION: Чтение, создание, редактирование и удаление*/

16-1 // Вывод ошибок
// Можно отключить в настройках: error_reporting(-1) поменять на ноль;
//Второй вариант отключение определенных ошибок - добавление знака @ - в то место, где может быть выведена ошибка
if (isset ($var)) echo $var; //иногда вместо такой записи пишут вот такую:
echo @$var; //если переменная будет, то она выведется, если нет, то вывод ошибок будет проглушон.

//Скрипт вывода ошибок: error_reporting(-1) можно в одном коде открывать и закрывать (меняя -1 на 0) по нескольку раз
// по мере необходимости.

//Обычно лезть настройки сервера нам никто не дает, поэтому для конкретного сайта в корне сайта создается файл:
//.htacess - для каждого сайта создается отдлельный файл!

//Разберем ошибки на примере домашки. В домашке у нас было так (? - это тернарный оператор):
$_GET['page'] = (isset($_GET['page']) ? $_GET['page'] : 'main');
include $_GET['page'].'.php';
//если не правильно будет указан файл или не найден, то воявится ощибка:
//"Warning: include(main.tpl): Failed to open stream: No such file or directory in..."

16-2 // Первое нам нужно не допустить возможности перехода по папкам и файлам через GET запрос - через редактирование
// url страницы, когда через точки и наклонную черту получают доступ к файлам, например:
test.ua/index.php?page=(сюда дальше хакер редактирует запрос и доходит до папок и файлов:)../../../inpost.zz.mu/index

16-3//46:20 Еще один вид хакерских атак - include-inject - позволяет подгружать файлы из соседних папок, которые есть
// в наличии, но подключать не нужно
// Второй вид инъекции: include-inject + upload-inject (сокращенно upload-inj)
// в файл картинки дописывается скрипт <?php echo $var; ? >, после чего при подключении этого файла через include
// запускается этот скрипт. Причем если подключить эту картинку через стандартный html: <img scr="file.jpg">,
// то скрипт не запустится.

16-4 //Когда мы делаем сайт, то он должен отвечать таким требованиям:
//1. Работает
//2. Безопасен
//3. Не имеет ошибок

16-5 // Приведение к типу - int, float - защита наших данных от передачи посторонних параметров.
//Для того чтобы в форму регистрации в поле ввода возраста вместо цифр не вписали что-то другое используется
// приведение к типу:
$_GET['id'] = (int)$_GET['id']; //id - это номер нашей записи, в дальнейшем мы поработаем с ним
//получается неважно какие данные получаем через адресную строку, в переменную мы получим уже обработанные,
// в нашем случае чистые числа

//Допустим для банковской системы, где имеем дело с передачей денег, то тут используем float:
$_GET['maney'] = (float)$_GET['money'] // тут даже если напишут в поле 5551515.145<php aendws... - все равно
// в переменную получим чистое число без мусора '5551515.145'

16-6 // Следующее нужно проверить точно ли нам передали нужные значения?
//Если мы подразумеваем, что через адресную строку 'page' мы можем передавать только 'main', то мы пишем:
if($_GET['page'] != 'main') { //если 'page' не равна 'main'
	exit(); // то мы обрываем наш скрипт
}
//То есть кто-то пытался через адресную строку ввести те значения, которые не допустимы на нашем сайте, и у него
// теперь это не выйдет.

16-7 //Существует третий вид проверок - встроенные функции в php
//Для того, чтобы работать с конкретной страницей, нам нужно быть уверенными, что были переданы какие-то конкретные
// параметры
if(isset($_POST['email'])) { //точно ли передан email?
	if(!empty($_POST['email'])) {// проверка - а не пустой ли email
	// обработка данных - заносим в базу данных или еще какое действие делаем
	}
}
//Бывают сложные проверки - действительно ли email ввели правильно? Есть ли @, name, domain, в домене точка должне
// быть .com например, ... Для этого используют встроенную функцию filter_var

//Что нам возвращает isset: true или false - существует или не существует переменная
// filter_var работает точно так же возвращет true или false.
// Если email внесен правильно, то true, если не парвильно, то false
// у этой функции есть набор фильтров: https://www.php.net/manual/ru/filter.filters.php
//как это все работает:
if(isset($_POST['email']) && filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) { //делаем проверку если у нас
	// существует переменная $_POST['email'] и (&&) filter_var(название функции), то есть проходит валидацию переменная
// $_POST['email'], после чего указываем как мы будем фильтровать - проверим на email -  FILTER_VALIDATE_EMAIL -
// стандартная настройка из ссылки выше
	echo 'Все ок!'; //если все проверки положительные выведется эта строка
}
Код проверка почты из моего проекта, удалил, за ненадобностью, но он рабочий:
if(!empty($_POST['email'])) {
    if(!filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) {
    $errorForm['emailError'] = "Почтовый адресс введен не верно!";
    }
}

?>
<form action="" method="post">
	<input type="text" name="email">
	<input type="submit">
</form>
<?php
//чаще всего функция filter_var используется для проверки адресной строки и email

16-7-1 Проверка логина на допустимые символы (код из моего проекта тоже):
if(!empty($_POST['login'])) {
    if (!preg_match("#^[a-zA-Z]*$#", $_POST['login'])) {
    $errorForm['loginError'] = "В логине допускаются только латинские буквы";
    }
}

16-8 // Не проще ли проверки такие делать через Java Script?
//JS делает на стороне клиента и если клиент захочет, то он не будет делать такую проверку, а php
// делает эту проверку на сервере, то есть данные уже пришли и клиент не сможет подделать данные

16-9 // Область допустимых значений - выводим три варианта допустимой страницы:
if($_GET['page'] == 'main' || $_GET['page'] == 'contacts' || $_GET['page'] == 'aboutus') {
	echo 'все хорошо!';
} else {
	exit ('Вы ввели недопустимые значения'); // завершаем через exit;
}
//если так делать, то проблемы с 'include-inject' отпадут, то есть в адресную строку не напишут какой-нибудь бардак
// и не смогут подключить сторонний файл, из-за того что мы заранее делаем проверку и определяем какое значение верное.
// Если хотя бы одно из этих значений верно, то мы работаем со скриптом. В противном случае мы можем его вырубить
// через 'exit '

//Данная запись она работает, но она длинная и не совсем красивая, лучше вариант через создание массива:
$allowed = ['main', 'contacts', 'aboutus', 'game1', 'program1'];
if(!in_array($_GET['page'], $allowed)) { // подключаем проверку из массива через отрицание(!)
exit ('Вы ввели недопустимые значения');
}

//Проверка возраста + проверка наличия самой переменной:
$sex = array ('man', 'girl');
if(isset($_GET['sex']) && in_array($_GET['sex'], $sex)) { //проверили наличие самой переменной и сравнили данные
	// с данными из массива
	//обработка анкеты
} else {
	$_SERVER['REMOTE_ADDR']; //узнаем с какого IP нас пытались взломать, обычно ломают пользователи сайта,
// поэтому через базу можно найти этого пользователя, по сессии, по кукам - это потом разберем.
	exit(); //запрос пытались подделать
}
?>
<!-- Html обычно в таком виде:-->
<select name="sex">
	<option value="man"> man</option>
	<option value="girl">girl</option>
</select>

<!--но мы его переделываем в такой: -->
<select name="sex">
	<?php foreach($sex as $v) { ?>
	<option value="<?php echo $v; ?>"><?php echo $v; ?></option>
	<?php } ?>
</select>

<?php
16-10 // Сессии и куки - что это такое?
//PHP так устроен, что он не хранит данные из переменных и при обновлении страницы или когда код считается до самого
// конца переменная очистится. Если нам нужно удержать/запомнить какие-то данные исользуются сессии и куки -
// они привязываются к определенному пользователю - это не общие переменные, которые существуют между страницами.
//База данных взаимодействует с каждым отдельным пользователем и позволяет пользователям выводить конкретные данные.
// Базы данных будем изучать позже.
//Куки и сессии - это для конкретного пользователя переменные, а БД - это переменные доступные для всех.

// Куки и сессии - это созданные файлы в виде баз данных, в которых содержится набор переменных, это обычные наши
// массивы, аналогичные с $_GET, $_POST, $_SERVER

//$_COOKIE - находятся у клиента (к/к)
//$_SESSION - хранится на сервере (с/с)

//Клиент может править куки как он захочет, поэтому этим данным не стоит доверять. Так как куки хранятся у клиента,
// то в них нельзя размещат важную информацию. Содержимое куки можно прочитать и изучить пароли и другие вещи.
//Если сессии - это безопасно, то зачем тогда куки?
// У сессий есть стандартное понятие - очистка брошеннх сессий. Обычная сессия 22-23 мин(стандартные настройки сервера),
// если на протяжении этого времени сессия небыла исправлена, изменена, страничку на сайте не коткрывал, не обрабатывал,
// к ней не делали запросов, то сессия конкретного пользователя "умирает"
//Время жизни куки наоборот будет столько, сколько мы хотим
// Кроме того так как сессия хранится на сервере, то это дополнительная нагрузка, дополнительные данные, которые будут
// захламлять наш сервер. Если пользователей мало, то и сессии будут весить очень мало

//Без куков покупки которые мы переместили в интернет магазине в карзину, но не оплатили через 22 минуты, исчезли бы
// так как сессия разорвалась. С помощью куков мы можем продлить хранение данных о покупках на пол года или год и
// клиент через время сможет продолжить работу с магазином и купить товар.

16-11// Как подклюбчить сессию?
//Для подключения пишем в начале скрипта:
error_reporting(-1);
ini_set('display_errors', 'on');
header('Content-Type: text/html; charset=utf-8');
session_start(); // вот тут стартует сессия

/* Если сессии не включить, то мы не сможем работать с $_SESSION, а именно:
1. Добавлять данные
2. Читать данные
3. Редактировать данные
4. Удалять данные
*/

//Добавление данных:
$_SESSION['name'] = 'login';
//Для вывода логина на экран:
echo $_SESION['name']; // эти данные может подтянуться даже на другой странице, отличной ото той, где этот
// логин вводился. При переходах по страницам логин будет виден (если включено).
//Удаляются данные через функцию unset. Разберем пример:
echo '<pre>'; //для наглядности просмотр в столбик массива
print_r($_SESSION); //тут еще показывает наш логин
unset($_SESSION['name']); //удаляем из файла
print_r($_SESSION); //после обновления страницы - уже нет

//для очистки всей нашей сессии, чтобы ее не существовало, мы пишем:
session unset;
session_destroy();

16-12 // Куки
echo '<pre>';
echo 'SESSION: ';
print_r($_SESSION);
echo 'COOKIE: ';
print_r($_COOKIE);

$_SESION['name'] = 'inpost'; //эта строка должна была перенести логин того кто открыл сессию, но почему-то
// не вывело - вместо этого пишет в куки инфо про phpstorm

//в куках мы увидим:
//[Phpstorm-34e77593] => ab538db4-0e52-42d1-ab31-b8ebe378b55b
//[PHPSESSID] => 88ec249b378b1e21aa5eb57680853ec4 // - это идентификатор, название файла сессии,
// которая принадлежит конкретному человеку. Этот идентификатор создается автоматически и содержится в куках.
// Но тут появляется момент уязвимости - вирус ворует идентификатор сессии из куков в системе клиента и после этого
// имеют доступ к сессиям на сервере. Подделывая куки злоумышленник может попасть на сайт. Чтобы хакеры не воровали
// нашу информацию время сессии ограничивают до 22 минут.

//Куки хранятся в разных браузерах у разных местах:
// C:\Users\Ваше имя пользователя\AppData\Local\Microsoft\Windows\INetCookies (win10)
//C: \ Users \ user \ AppData \ Local \ Google \ Chrome \ User Data \ Default (Chrome)
//C: \ Users \ user \ AppData \ Roaming \ Mozilla \ Firefox \ Профили (Mozilla)
// C: \ Users \ user \ AppData \ Local \ Packages \ Microsoft.MicrosoftEdge_8wekyb3d8bbwe \ AC \ MicrosoftEdge \
// Cookies (MS Edge)

//Добавлять данные, редактировать и удалять - можем только в период отправки заголовков,
// а читать данные - можно везде.
//Период заголовков будет существовать до первого echo в коде. Поэтому можем получить ошибку,
// если используем echo перед header('Content-Type: text/html; charset=utf-8') и session_start();

16-13 //Как создаются, редактируютися и удаляются куки?
//Создаем куки:
setcookie('name1', 'Roman', time()+60*60*24*30*12, '/');
// эта функция имеет 4 параметра: 1)ключ, 2)переменная, 3) время жизни куки (если ничего не указать, то быдет считать,
// что куки живут только сейчас, для увеличения времени после скобок добавляем + время в секундах,
// 4)'/'(ставится, чтобы кук работали по всему сайту).

//Редактируем куки:
setcookie('name1', 'NEW_MESS', time()+60*60*24*30*12, '/'); //кука умрет на стороне клиента
//путем замены имени
//Клиент не имеет достиупа к серверу, сервер не имеет доступа к клиенту

//Можно еще менять куки через переменную, но такой способ обычно не используется:
setcookie('name4', 'NEW_MESS', time()+60*60*24*30*12, '/'); // меняет у клиента
$_COOKIE['name4'] = 'AAAA'; //заменяет на сервере

//как убить куку:
setcookie('name4', 'NEW_MESS', time()-60, '/'); //ставим отрицательное время, что убивает куку у пользователя.

//Редактировать, добавлять и удялять куки (не сессии, а именно куки) можно до вывода информации на экран.
// Сессии можно в любой момент.

16-14 //Домашняя работа
/*
1-я домашка обязательна, 2 и 3 по жаланию.
1-я - на понимании куков и filter_var
2-я - на сессии и rand ()
3-я - на функции readdir и if-dir
*/


16-15// Домашнее задание №1 Форму для авторизации и выход (1:10:00 / 1:45:45)

/*https://youtu.be/xxTMusbYpIk?t=4200
Делается достаточно просто, простая форма на ввод логина, пароли и email. Далее проверяем сначало на то,
что заполнили поля, и email заполнили верно! После авторизации - запоминать ключ в куках. Выводить на экране.
Для email: filter_var. Последнее поле меню: ВЫХОД!
Сделать простую форму авторизации. В прошлом уроке было выводить меню для определенных айпи адресов.
Теперь добавить возможность по айпи либо для тех у кого прописан ключ, а ключ мы будем через форму авторизации:
логин, пароль, емеил, войти. Если логин и пароль ввели правильно, то мы создадим куку с именем:*/
$_COOKIE['access'] = 1; //значит выводи меню ADMIN, то есть своего рода авторизация.
/*Если куки не существует, то мы проверяем айпи адресс. Если айпиадресс проходит выводим ADMIN, если айпи адресс
не подходит, то мы не выводим айпи вообще
Задача простая - проверить форму, поработать с filter_var и поработать с куками. И добавим еще выход из кук,
выход из админки меню ВЫХОД! Эта кнопка должна убить $_COOKIE['access'] через отрицательное число, то есть будет
отдельно созданная страничка на которую человек перейдет и кук убьется.
Нужно учесть только что куки можно создавать только до вывода любой информации на экран, поэтому нажатие, всю
обоработку данных, ее нужно делать в самом начале, нижний блок из кнопок обработки мы помещаем в index.php
в верхний блок, до вывода html.*/
if (isset($_POST['submit_auth'])) {
	//
}
if (isset ($_GET[exit])) {
	// передается через index.php?page=main&exit=1 так мы сделаем выход
}
16-16// Домашнее задание №2 Битва алкоголиков (https://youtu.be/xxTMusbYpIk?t=4558)
/*Мини-игра, цель которой показать, что алкоголизм - это плохо. Мы создаём страничку main.tpl под игру.
Создаются 2 персонажа, у обоих по  10хп (2 сессионных переменных), создаётся форма, где пользователь вводит число
от 1 до 3 и отправляет запрос на сервер. На сервере запустить rand(1,3), и если значение человека со значением
случайным совпадает, то снимаются ХП с персонажа человека (клиента), если не совпадают - с серверного персонажа.
Отнимать надо от 1 до 4хп, случайным образом). То есть вероятность 33%, что отнимутся у клиента, и 66%, что
у серверного персонажа.
В момент, когда у одного из персонажей ХП становится 0 и ниже,- перебрасывать на другую страницу при помощи
переадресации (header) на страницу gameover.php, и выводить текст, победил ли игрок, или система.

Цели игры: разобраться в сессиях и переадресациях. Попробовать на практике изученную самостоятельно функцию rand();*/
if(!isset($_SESSION['client'])){//если клиента не существует, то создаем ниже
$_SESSION['client'] = 10;
$_SESSION['server'] = 10;
}
/*далее через форму мы вводим число от 1 до 3, если число не совпало с rand(1,3), то мы выиграли у компьютера
отнимая от 1 до 4 хп
После победы происходит перенос на новую страничку, для этого используем функцию:*/
header("Location: /index.php?page=game1over&action=lose"); //функция переадресации на новую страницу
/*Еще с header("Location...") используется exit;*/


16-17// Домашнее задание №3 Файловый менеджер
/*Простая файловая система на подобии norton-comander, far, FileZilla с упрощенной версией.
Её путь будет: program.php .
Необходимо:
1) вывести каталог папок и файлов для данной директории, используя scandir('.'). Перед названием выводить иконку папки,
 или иконку файла соответственно. Проверку делать на: if(is_dir()) - else.
2) Папки сделать кликабельными, через ссылку передавать второй аргумент - путь к файлу по примеру:
<a href="/program.php&link=echo (isset($link) ? $link.'/'.$v :$v);">имя папки</a> .
Данный путь будет содержаться в массиве после использования функции scandir.
3) По переходу по ссылке будет передаваться $_GET['link'], который необходимо будет подставить в функцию scandir
для того, чтобы отобразить файлы и папки внутри конкретной директории.
4) Таким образом мы сможем воссоздать файловую систему и передвигаться по директориям и поддиректориям.

Цели программы: изучить новые функции + цикл с массивом и множества аргументов для $_GET.*/
1:22:41 / 1:45:45
scandir('.') //анализирует данную папку
scandir('./1')//то анализируем папку '1'
//в файловой системе идем только вглубь, назад возвращаться не нужно.

Урок 17: Ядро, структура сайта, MVC
/*План:
	Архитектура сайта
	Ядро
	Структура сайта
	MVC
	Шаблоны*/

17-1-1 //Настройка файла index.php
error_reporting(-1);
ini_set('display_errors', 'on');
header('Content-Type: text/html; charset=utf-8');
session_start();

//конфиг сайта
include_once './config.php';
include_once './libs/default.php';
include_once './variables.php'; //- для работы с нашими переменными

//роутер - распределение между страницами, что мы будем подключать:
include '/modules/'.$_GET['module'].'/'.$_GET['page'].'.php';
include '/skins/'.SKIN.'/index.tpl'; //главную страницу подключаем (используем переменную SKIN из config.php)
//в index.tpl (это тут все от <!DOCTYPE html> до </html>)- подключаем в html код в раздел

17-1-2 //index.tpl
?>
<title><?= echo @$title; ?></title> <!-- для вывода разного содержания для разных страниц с помощью контроллера
будем доставать эти данные из базы данных-->
<body>
<?php
include $_GET['module'].'/'.$_GET['page'].'.tpl';
?>
</body>

<?php
17-2-1 //страница с конфигурациями: config.php:
//задаем настройки сайта (всего сайта, а не страницы) через константы:
define('CREATED', 2013);
define('SKIN', 'default'); //шаблон - default
//define('NEWSONPAGE', 12); //12 новостей на странице
//подключаем базу данных:
define('DBLOGIN', 'inpost');
define('DBPASS', '123');
define('ADMINLOGIN', 'roman');
define('ADMINPASS', '123123');
//здесь будем хранить: соединения с базами данных, адресс нашего сайта и прочее

17-2-1 // страница variables.php
//задаем допустимые названия страниц, чтобы защититься от взлома:
$allowed = ('main', 'contacts', 'aboutus', 'game1', 'program1');

if(!isset($_GET['module'])) {
$_GET['module'] = 'static'; //папка "modules/static/" c файлами: main.tpl и .tpl, main.tpl и .tpl,...
} elseif (!in_array($_GET['module'], $allowed)) {
// подключаем проверку из массива через отрицание(!)
header ("Location: /index.php?module=404"); //вывод информации, что страница отсутствует
exit ();
}
if (!isset($_GET['page'])) {
$_GET['page'] = 'main';
}

17-3 // страница с конфигурациями: .htaccess
AddDefaultCharset UTF-8
php_flag display_errors ON

17-4 // библиотеки/ модули: папка modules
//в нее добавляем все классы, функции, пагинатор (навигация по страницам - внизу экрана 1, 2, ...898), аплоадер
// картинок - все делаем отдельными файлами с понятным названием

17-5 //папка с функциями: libs в ней создаем файл default.php - здесь будем записывать стандартные функции, которые
// будут использоваться везде, на всем сайте.

//для примера разберем функцию, которая будет выводить на экран массив - для мониторинга нескольких массивов
function wtf($array, $stop=false) {
	echo'<pre>'.print_r($array,1).'</pre>';
	if(!$stop) {
		exit();
	}
}
//вызов функции:
wtf($array,1);
wtf($array2,1);
wtf($array3); //тут 1 не прописали, значит false и функция остановилась

17-6 //MVC - Models (набор функций, базовое ядро) View (Вид, Представление) Controllers (Обработка данных) -
// размещать их нужно в разных файлах.
//За вывод информации отвечает верстальщик и СЕОшник, он определяет что где и как выводить, а Controllers -
// это уже часть программиста

//Controllers: отсутствует вывод на экран!

//Models: в 99% случаев не выводим на экран информацию через echo!
// используем return 'переменная или значения' возвращаем в контроллер и редко когда в представление

//View: весь вывод информации на экран + частичное php (echo $var; циклы, htmlspecialchars, приведение к типам -
// echo(int)$var;)

//1-й вариант разделения:
include $_GET['page'].'_controllers.php'; // 'news_controller.php'
include $_GET['page'].'_view.php'; //'news.view.php'
//2-й вариант разделения:
include $_GET['page'].'.php';
include $_GET['page'].'.tpl'; // tpl - изобрели для верстки
//3-й вариант разделения - реже всего используется:
include $_GET['page'].'.php'; //'news.php'
include $_GET['page'].'.html'; // 'news.html'

//4-й вариант - мы будем использовать его - это 2-й вариант + разбивать по папкам:
include '/modules/'.$_GET['page'].'.php';
include '/modules/'.$_GET['page'].'.tpl';

//примеры модулей:
//all_news.php - показать все новости
//view_news.php - просмотр одной новости в расширенном виде с комментариями пользователей сайта
//search_news.php - поиск по новостям

//но более понятно будет если называть по другому - первая часть - общая, дальше различия:
//news_all.php
//news_view.php
//news_search.php
//voting_all.php
//voting_once.php
//voting_last.php

//если на сайте планируется очень много модулей, то тогда лучше группировать их по отдельным папкам:
//news/all.php
//news/view.php
//news/search.php
//voting/all.php
//voting/once.php
//voting/last.php

//Примеры подразделов в папке модули: news, static, voting

17-7 // skins и подпапка default - папка с шаблонами: index.tpl - в него перенести весь html код с index.php.
include '/skins/default/index.tpl'; // это записать в index.php
//И такую же запись продублировать в body файла index.tpl

17-8-1 //404.php - создаем для ошибок отдельную папку 'modules/errors'( потом можно сюда добавить ошибки 403 и 500)
header("HTTP/1.1 404 Not Found");

17-8-2 // 404.tpl- создаем для ошибок отдельную папку 'skins/errors'
"Данная страница отсутствует!"


Урок 18: //База Данных MySQL. Основы
/*	План:
	Как всё устроено
	Создание БД
	Создание пользователя
	localhost
	Создание таблиц
	Частичная настройка и оптимизация таблиц*/
//https://youtu.be/a_DoWa7B6w8?t=1409/

18-1 База данных - это массив, который хранится, выдается между страницами и эти данные общие для всех, каждый
может получить доступ к этим данным. В отличии от сессии и кук. Потому что куки содержатся у клиента на
компьютере, сессии содержатся на сервере, но при этом другие пользователи к ним не имеют доступа без
определенного идентификатора, который знают только куки, которые содержатся у пользователя на компьютере.

База данных содержит огромное количество функций, основное назначение которых:
чтение, добавление, редактирование, удаление

18-2 // phpMyAdmin
доступен по ссылке: http://localhost/openserver/phpmyadmin/index.php
пароль и логин: root

Создаем базу данных во вкладке - "База данных". Задаем кодировку UTF-8: 'utf8_unicode_ci'. Жмем кнопку "создать"

Подключаем определенных людей к этой базе данных с указанием логина и пароля (авторизация). Для этог вкладка
"Учетные записи пользователей" => кнопка "Добавить пользователя".
 Затем заполняем форму:
	"Имя пользователя",
	"Имя хоста" - выбираем локальный, так как база у нас на компьютере.
	"Пароль:"
	добавляем ему все привелегии - в графе  Данные, Структура и Администрирование
	ограничения не ставим
	выбираем базу данных с которой будет работать этот пользователь
	добавляем пользователя

Возвращаемся в базу данных, проверяем привилегии и видим там нового пользователя

Если база не появляется сразу после создания - жмем вверху слева зеленую стрелку "Обновить панель навигации"

Обычно база данных делается одна на весь сайт

18-3 //config.php - в этом файле добавляем константу:
define('DB_NAME', 'main'); //main - это имя базы данной, которую создали в phpMyAdmin
define('DB_LOGIN', 'test'); //логин админа
define('DB_PASS', '1111'); //пароль админа
define('DB_LOCAL', 'localhost'); // расположение базы ("Хост")

18-4 Создание базы данных на хостинге (удаленном сервере)
Через панель выбираем наш сайт / Дополнительно / Базы данных MySQL /Создаем базу данных
В этом случае в файле config.php ставим параметр расположения ни localhost, а адресс базы нашего сайта
Затем через панель хостинга переходим уже в phpMyAdmin и попадаем в полную аналогию нашего локального phpMyAdmin

18-5 // Создаем таблицу и указываем ее значения
вводим имя, например "comments" и количество полей

тип таблиц выбираем : MyISAM или InnoDB
сравнение - кодировка выбираем utf8_unicode_ci

18-6 //Заполняем поля таблицы:

18-6-1 // Имя - в подсказке выбираем "id", "login"/"name", "data", "age", "text" и тд
Уникальность пользователей.
Чтобы отделять одинаковые сообщения одни от других в ID пользователя добавить счетчик просмотров и тогда в базе
не будет полностью одинаковых записей. Для этого в настройках в разделе в первой строчке там где прописываем
Имя пишем "id" дальше в колонке "Индекс" выбираем "PRIMARY"

18-6-2 //Тип выбираем для "id" выбираем "INT", для "name" - "TEXT", для "text" - "TEXT", для "date" - "DATE".
Есть еще более расширенные варианты числовых данных, даты и прочего. Например для чисел - от выбора типа зависит
байтовый размер типа (чем больше прежполагается будет база, тем больше нужно выбирать тип):
	TINYINT - 1 байт (числа базы от 0 до 256 ограничение, количество строчек, если выбрали этит топ для 'id')
	SMALLINT - 2 байт
	MIDIUMINT - 4 байт
	INT - 8 байт - если не знаете, что выбрать выбирайте INT.
	BIGINT - 16 байт
	чем больше байт, тем больше чисел она поддерживает, но и настолько медленнее будет сама база
	например, для поля "age" нам хватит 'TINYINT', так как до 256лет никто не доживет

для имени "name" нужно выбирать тип "VARCHAR" и указываем длинну "255" в следующей вкладке

18-6-3 //Длина/Значения - пока не будем разбирать, оставляем пустым

18-6-4 //Значения по умолчанию:
тут можно задать например если выбрали тип DATE в вкладке "по умолчанию" выбрать "как определено" и прописать
вручную формат даты и времени: "2013-01-01 12:12:12". Или с помощью "как определено" можно прописать логин
по умолчанию от которого будет писаться коментарий, если не выбран другой, например "guest"

18-6-5 // Сравнение - это наша кодировка, задаем если нужно задать кодировку отличную от предыдущих настроек.


18-6-6 // A_I:  Атрибут AUTO_INCREMENT может использоваться для генерации уникального идентификатора для новых строк.
Если отметить этот параметр в строчке 'id' и в вкладке "Индекс" выбрать "PRIMARY", то 'id' у каждой следующей
записи комментариев будет увеличиваться на единицу.

18-6-7 // После того как мы нажали кнопку "Создать" эту новую базу мы сможем увидеть слева.

18-6-8 // если нужно для эксперимента что-то вставить в новую базу, то переходим в вкладку "Вставить":
//'id' не заполняем

18-7// Домашка
Сделать БД: "Пользователи" - туда внести "имя", "возраст/год рождения", "дата создания своего аккаунта", логин,
пароль, краткую информацию о себе. Лучше всего посмотреть по разным сайтам какие поля заполняюься при регистрации.
для пароля выбираем тип "text" , для пароля - "varchar" или "text"
Создать Базу Данных, пользователя и 3 таблицы: comments, users, news. Сохранить структуру таблиц в формате .sql .
 Кроме этого создать 1 word-файл, в котором написать маленькое описание трёх таблиц, то есть что значат конкретные
 поля. По примеру: `age` - возраст зарегистрированного пользователя. `text` - сообщение комментария и т.д.
Дополнение к уроку:
Для возраста мы указываем `age` типа TINYINT, содержание: 1 или 0 .

Если таблица называется `users`, то поле мы называем `login`, в общей связке мы получим: `users`.`login`.
Ошибкой будет назвать поле `user_login`, в таком случае мы получим `users`.`user_login`, то есть тавтология -
повторение дважды слова `user`.
В свою очередь мы будем применять имена из двух слов `user_login` тогда, когда таблица не связана будет прямо
с пользователями, допустим это у нас таблица `news`, и мы указываем имя пользователя, который написал данную
новость: `news`.`user_login`.


Урок 19: Запросы select, insert, update, delete
/*План:
Разбираем структуру PMA
Создаем, редактируем и удаляем таблицы
Изучаем 4 главных команды: INSERT, UPDATE, DELETE, SELECT*/

19-1 //Разработка модуля
Есть задача: создание пользователя (регистрация пользователя).
1. Смотрим конкурентов, создаем схему и по этой схеме создаем нужную таблицу/таблицы в БД
2. Функционал по регистрации:
	- регистрация;
	- авторизация;
	- востановление пароля;
	- выход из системы;
	- кабинет пользователя;
3. В нашей сайте в папке modules и папке skins создаем папку cab. В кабинете (папка cab)
создам страничку с регистрацией registration.tpl и registration.php.
4. В файле variables.php добавляем в исключения в $allowed надпись 'cab'
5. Путь к файлу: index.php?module=cab&page=registration
6. Создаем логику приложения - структуру таблички. В PhpMyAdmin воздаем новую базу 'users':
	6.1 'id' - Тип (INT), Индекс(PRIMARY), A_I(галочку ставим)
	6.2 'login' - Тип (VARCHAR), Длинна 100 (максимум 255)
	6.3 'password' - Тип (VARCHAR), Длинна 100
	6.4 'email' - Тип (VARCHAR), Длинна 100
Тип таблицы - InnoDB, Сравнение (кодировка): utf8_unicode_ci
Создаем таблицу.
7. Вносим первые записи через PhpMyAdmin вкладка "Вставить": заполняем поля ('id' не заполняем!)
login, password, email, ok/вперед
8. Слева в меню переходим к выбору нашей таблицы (PhpMyAdmin):
	8.1 Обзор - выводится вся наша табличка. Тут мы можем делать:
		- Изменить
		- Копировать
		- Удялять записи
	8.2 Структура
		- редактирование полей таблицы
		- удаление
		- добавить поле в таблицу (в конец/начало/после 'id')
		- информация о таблице (размер и т.д.)
	8.3 SQL - тут указаны SQL-запрос(ы) к таблице users.users
	8.4 Поиск - обычно не используется
	8.5 Вставить - разбирали выше (для экспериментов создано)
	8.6 Экспорт - Экспорт строк из таблицы "users" - бэкап нашей базы данных:
		- выбираем обычный, сохранение таблицы - структура и данные, остальное по умолчанию.
	8.7 Импорт - в таблицу "users" - бекап данных (востановление)
	8.8 Привилегии - Пользователи с правами доступа к "users.users"
	8.9 Операции:
		-параметры таблицы - редактирование (тут полезное коментарии добавить можно и сменить
		AUTO_INCREMENT - прописать 10000 - тогда id будет начинаеться не с 1, а 10001)
		- обслуживание таблицы (пока это не будем разбирать)
		-Удалить данные или таблицу
	8.10 Триггеры (пока не нужно)

19-2 //Команды для работы с БД (вкладка SQL):
1. Добавить данные - INSERT INTO:
		- добавляются по одной записи в нашу табличку;
		- имена таблиц и ячеек указываем (ключи) с `обратным апострофом` (буква Ё в рус раскладке),
		а 'значения' (с обычным - буква Э в рус раскладке);
	1.1 Разберем синтаксис для единичной вставки (можно писать в столбик):
			INSERT INTO
			`таблица` (`users`)
			SET
			//`ключ1` = 'значение1', `ключ2` = 'значение2', `ключ3` = 'значение3' (в конце запятая не ставится),
			//например:
			`login` = 'Salex',
			`password` = 'qwerty',
			`email` = 'salex@gmail.com'
		Жмем "ОК" и каждую новую запись так же добавляем
	1.2 Синтаксис для вставки в php:
			mysqli_query ("INSERT INTO `users` SET
			`login` = `Salex`,
			`password` = 'qwerty',
			`email` = 'salex@gmail.com',
			`age` = 22");
	(цифры можно без кавычек, слова в кавычках)
	1.3 Синтаксис для множественной вставки:
	INSERT INTO `users`(`id`, `login`, `password`, `email`) VALUES ('[value-1]','[value-2]','[value-3]','[value-4]')

2. Отредактировать данные - UPDATE
	2.1  Условие WHERE - ссылка, указание на конкретные записи. WHERE используется при UPDATE,
	DELETE, SELECT, кроме вставки.
	WHERE 'key' = 'value' //например: WHERE `id` = 4;
	WHERE `age` >= 18 AND `login` = 'inpost'; //аналог php: if ($age>=18 && $login=='inpost')
	WHERE `age` >= 18 OR `login` = 'inpost'; //аналог php: if ($age>=18 || $login=='inpost')
	2.2 Меняем запись `id` = 4
	UPDATE `users` SET
	`login` = 'Петя', //то что хотим изменить
	`email` = 'petya@mail.ua', //то что хотим изменить
	WHERE `id` = 4 // где меняем
	//нужно быть внимателным - без WHERE может поменяться у всех пользователей
	2.3 Математические операции:
	UPDATE `users` SET
	`age` = `age`+ 2 //добавит к возрасту 2 года
	WHERE `id` = 4 //если не указать WHERE всем пользователям добавит + 2 года

3. Удалить данные - DELETE FROM
	Если в DELETE FROM не прописать условие WHERE, то удалятся все записи.
	3.1 Как удалить пользователя 'Salex':
	DELERE FROM `users` WHERE `login` = 'Salex'
	// Равенство: если в php пишем ==, то в MySQL = это важно!
	//так как в php одно = это присваивание, в MySQL = это равно, а присвоение это @=
	// не равно в MySQL пишется != или <>
	3.2 Удаление по шаблону:
	DELETE FROM `users` WHERE `id` = 10001 AND `age` > 100 AND `email` = '121212@mail.ru'
	Удаление нескольких записей по шаблону:
	DELETE FROM `users` WHERE `age` > 20 //удалит все записи у кого возраст больше 20.
	//если таких записей с `age` > 20 не будет, то ничего не удалит и ошибку не высветит
	// а если ошибиться в названии ключа, например 'agadadadfa' > 20, то выдаст ошибку.
	Любой запрос можно проверить через панель MySQL и убедиться, что у вас все грамотно написано.
	Можно задавать диапазон:
	DELETE FROM `users` WHERE `age` >= 20 AND `age` <=30 //удалит всех от 20 до 30 лет
	3.3 Востановить удаленные записи очень сложно. Можно через бекап, если вы заранее делали "экспорт".
	3.4 Удаление с форума сообщения №34454:
	DELETE FROM `table` WHERE `id` = $_GET['mess']
	<a href="index.php?mess=34454"
	//без WHERE удялятся все записи с форума
	3.4 Для удаления записей с пустым полем нужно писать:
	WHERE `id` = '' //удялятся пустые записи и записи с '0'
	WHERE `id` = //выдаст ошибку
	3.5 Лимит удалений - LIMIT:
	DELETE FROM `users` LIMIT 2 //удалит 2 записи - используется для удаления по частям

4. Выбрать данные - SELECT:
	4.1 Примеры выбора:
	SELECT `login`, `password` FROM `users` //выберет пользователей, которые указали логин и пароль
	SELECT * FROM `users` //выберет всех пользователей - это обязательный минимум полей
	SELECT * FROM `users` WHERE `age` < 23 //выберет все данные с возрастом до 23 лет.
	SELECT * FROM `users` WHERE `age` != 23 //выбор пользователей чей возраст не равен 23 года.
	SELECT * FROM `users` WHERE `age` <> 23 //тоже самое, только это более правильно так писать в БД
	SELECT * FROM `users` WHERE `login` = 'inpost' //выберет пользователя 'inpost'
	//Пример поиска по сайту новостей (новости в базе данных хранятся):
	SELECT * FROM `news` WHERE `category` = 'economy' //отсортирует только новости про экномику
	SELECT * FROM `news` WHERE `id` = '56887' //найдет новость 56887
	4.2 Сортировка - ORDER BY:
	SELECT * FROM `users` ORDER BY `id` ASC //сортировка по 'id' по возрастанию
	//ASC (по возрастанию - 1, 2, 3, 4) DESC (по убыванию 4, 3, 2, 1)
	4.3 Двойная сортировка
	//если после сортировки у нас выдало несколько пользователей с одинаковым возрастом, то можно
	// дополнительно просортировать еще и по 'id', для этого через запятую добавляем:
	SELECT * FROM `users` ORDER BY `age` ASC, `id` ASC
	//Сортировка пользователей по возрасту = 20 лет и затем по 'id':
	SELECT * FROM `users` WHERE `age` = 20 ORDER BY `id` ASC
	//Это можно использовать для выода последних новостей по экономике на главную страничку
	// или для вывода на экран сначала последних комментариев, потом более старых
	4.4 Ограничение количества вывода - LIMIT сколько всего:
	SELECT * FROM `news` WHERE `category` = 'economy' ORDER BY `id` DESC LIMIT 10
	//выведет на страничку 10 последних новостей по экономике
	4.5 Указание к количеству вывода - LIMIT начало, сколько всего:
	// делается через запятую, где первое число - это порядковый номер записи начиная с нуля
	// с которой начинаем вывод, а второе - это количество выводимых записей
	SELECT * FROM `users` WHERE `age` = 20 ORDER BY `id` ASC LIMIT 1, 2
	//вывести начиная со второй (1-я это ноль) и две записи
	//Пример по выборке комментариев для странички сайта:
	SELECT * FROM `comments` LIMIT 0, 5 // выберется 5 коментариев начиная с 0-го
	SELECT * FROM `comments` LIMIT 5, 5 // вывод следующих 5 комметариев и т.д.
	// после этого в чате добавляем 1 страничка, 2-я и т.д. - получился пагинатор,
	// постраничная навигация:
	$limit = 10;
	$_GET['page'] = 1; //если 'page' = 1, то выведется страница 1 (с 0 по 10 записи)
	(($_GET['page'] - 1) * $limit) = 0 // первая страница начинается с 0, так как для 1 страницы $limit=0
	//для вывода второй страницы:
	$_GET['page'] = 2;
	(($_GET['page'] - 1) * $limit) = 10 // так как $limit=10
	//для третей страницы:
	$_GET['page'] = 3;
	(($_GET['page'] - 1) * $limit) = 20 // так как $limit=20
	$count = ($_GET['page']-1)*$limit; //счетчик
	LIMIT $count, $limit
	Страница 1: 0,10
	Страница 2: 10,10
	Страница 3: 20,10
	Страница 4: 30,10
 	//итого скрипт пагинатора:
	$limit = 10;
	$count = ($_GET['page']-1)*$limit; //счетчик
	LIMIT $count, $limit
	4.6 //Подсчет количества через SQL запрос в PHP
	С помощью команды COUNT можно подсчитать количество строк в выборке.
	Давайте, например, подсчитаем всех юзеров в таблице:
	$query = "SELECT COUNT(*) FROM users"; //php
	А теперь подсчитаем всех, у кого зарплата равна 900:
	$query = "SELECT COUNT(*) FROM users WHERE salary=900"; //php

19-3 //Подитожим предудущие знания по командам для работы с БД (вкладка SQL):
	1. Добавить данные - "INSERT INTO"
	2. Отредактировать данные - "UPDATE" + WHERE
	3. Удалить данные - "DELETE FROM" + WHERE + LIMIT
	4. Выбрать данные - "SELECT" + WHERE + ORDER BY + LIMIT

19-4 //Продолжим начатое в начале урока - этапы разработки модуля:
Есть задача: создание пользователя (регистрация пользователя).
1. Создаем модуль и странички.
2. Смотрим конкурентов, создаем схему и по этой схеме создаем нужную таблицу/таблицы в БД
3. Наполнять модуль: создать HTML-таблицу + PHP-обработку для взаимодействия с БД (этот пункт изучим
на следующем уроке)
4. Тестирование работы модуля

19-5 //Домашняя работа:
Создать 13 пользователей в таблице `users`. Составить группу запросов:
1. Добавить пользователя:
	1) Петрович
	2) Yamamoto, возраст 10 лет
	3) inpost, возраст 2 года, пароль 123, email inpost@list.ru
	4) Добавить 10 произвольных пользователей с разными данными в возрасте от 18 до 40 лет
2. Отредактировать пользователя:
	1) Yamamoto => возраст исправить на 9 лет
3. Удалить данные:
	1) Удалить Петровича
4. Выбрать данные:
	1) Выбрать всех пользователей в возрасте от 20 до 25 лет и отсортировать по позрасту DESC (в обратном порядке)
	2) Выбрать пользователя inpost
	3) Выбрать 4 пользователей.

Эту домашку сохранить в php файле в таком виде:
	1.1 INSERT INTO ...
	1.2 ....


Урок 20: Форма и работа PHP с MySQL
/*План:
mysqli функции
Создаем формы на HTML
Обработка форм
Добавление данных в MySQL*/

20.1 Освежим память - 3 вида хранения данных:
	1) $var (переменные - в основном в пределах страницы или скрипта);
	2) $_SESSION (храним логины), $_COOKIE(тоже можно хранить логин, а так же поисковые запросы,
	карзину товаров, языковую раскладку сайта и тд);
	3) База данных (MySQL) (коментарии, страницы, товары, пользователи)

20.2 Работа с БД:
	1) Открытие соединения;
	2) Выполнение запроса: INSERT, UPDATE, DELETE, SELECT
	3) Закрыть соединение (выполняется автоматически с последней строчкой нашего файлика, иногда нужно
	ручное закрытие соединения, но об этом позже поговорим);

20.3 Соединение с БД - на странице index.php в разделе роутер:
mysqli_connect('HOST', 'NAME', 'PASSWORD', 'БазаДанных'); //типовое подключение
//у нас в проекте мы использовали константы в файле config.php:
define('DB_LOCAL', 'test');
define('DB_LOGIN', 'test');
define('DB_PASS', 'test');
define('DB_NAME', 'main');
//подключаем согласно наших данных:
mysqli_connect('DB_LOCAL', 'DB_LOGIN', 'DB_PASS', 'DB_NAME');
//Если сменится пользователь или расположение сайта не нужно лезть в скрипты - меняем
// в файле config.php

20.4 Указываем кодировку для передачи данных (добавляем в index.php):
//Во время присоединения БД мы получаем идентификатор БД:
$link = mysqli_connect('DB_LOCAL', 'DB_LOGIN', 'DB_PASS', 'DB_NAME');
В переменной $link будет содержаться не сама база данных, а просто ссылка и через эту ссылку будет
отправляться запрос У этой ссылки есть идентификатор соединения.
Если БД несколько, то создаем несколько ссылок на БД($link1, $link2, $link3, ...).
mysqli_set_charset($link,'utf8'); //Набор символов, который необходимо установить.

20.5 Запросы в базу данных через php:
$query = "INSERT INTO 'table' SET `key` = 'value'"; //Добавить данные в БД.
$query = 'SELECT * FROM users'; //Выбрать из БД
//Отправим этот запрос через команду mysqli_query:
mysqli_query ($link, $query);

20.6 Перехват ошибок запросов к БД
Если при внесении в БД мы допустим ошибку, то она не выведется на экран. Такая особенность БД. Например:
$res = mysqli_query ($link, "SELECT * FROM `zzz`"); //вместо `users` указали неправильное название `zzz`
var_damp($res); // выведет bool(false), потому что произошла ошибка - если нет ошибок функция возвращает true
Перехват ошибки простой - вместо var_damp($res) пишем:
if($res === false) {
	echo 'Тут была ошибка: '.mysqli_error($link);
	exit();
}

Второй вариант через die (более короткий):
$res = mysqli_query ($link, "SELECT * FROM `zzz`") or die('Тут была ошибка: '.mysqli_error($link));
Рекомендуется все запросы к БД выводить одним из этих способов.

20.7 Экранирование символов:
если хотим постиавить одинарную кавычку в коде нужно использовать экранирование (\) - обратная черта:
echo '<h1>Te'xt</h1>' - без экранирования кавычка считает закрытие кода посреди текста,
echo '<h1>Te\'xt</h1>' - так правильно (при выводе на экран \ не будет виден)

Чтобы вписать двойыне кавычки при использовании html в php и JavaScript, тоже придется использовать
экранирование:
echo "<div style = \"text-decoration:underline;\" >";
\ ставится влотную к символу, который хотим экранировать.

Для БД тоже используется экранирование:
`login` = 'Sau Pau\'lo', //в базу внестся как 'Sau Pau'lo'

В MySQLi есть команда для автоматического экранирования введенной информации:
`login` = '".mysqli_real_escape_string($link, $login)."', //с помощью этой команды нам удастся
// сохранить БД от поломки через использование экранируемых символов при регистрации логина.
`login` = '".mysqli_real_escape_string($link, "Sau P'aulo")."' '//в базу внестся как 'Sau Pau'lo'

Экранируемые символы: NUL (ASCII 0), \n, \r, \, ', ", и Control-Z. '

Там где кавычки не используем (числовые данные), то нужно использовать преобразование к типу:
`age` = .(int)$age; //тоже защита

20.8 Регистрация пользователя на сайте: // index.php?module=cab&page=registration
20.8.1 registrathion.tpl:?>
<div style="padding:100px;">
	<?php echo if(!isset($_SESSION['regok'])) { ?>
	<form action="" method="post">
		<table>
			<tr>
				<td width="90">Логин *</td>
				<td><input type="text" name="login"
						   value="<?php echo @htmlspecialchars($_POST['login']); ?>"></td>
				<td><?php if (isset($errors['login'])) {echo $errors['login'];} ?></td>
			</tr>
			<tr>
				<td>Пароль *</td>
				<td><input type="password" name="password"
						   value="<?php echo @htmlspecialchars($_POST['password']); ?>"></td>
				<td><?php @echo $errors['password']; ?></td> <!--короткая запись с глушилкой ошибок-->
			</tr>
			<tr>
				<td>E-mail *</td>
				<td><input type="email" name="email"
						   value="<?php echo @htmlspecialchars($_POST['email']); ?>"></td>
				<td><?php if (isset($errors['email'])) {echo $errors['email'];} ?></td>
			</tr>
			<tr>
				<td>Возраст</td>
				<td><input type="text" name="age"></td>
				<td></td>
			</tr>
		</table>
		<p style="font-size:10px;">* - поле обязательное для заполнения</p>
		<input type="submit" name="sending" value="Зарегистрироваться">
	</form>
	<?php } else { unset($_SESSION['regok']); ?>
	<div>Вы успешно зарегистрировались на сайте!</div>
	<?php } ?>
</div>
<?php
20.8.2 //Вносим логику в registrathion.php:
//обработка регистрации:
if(isset($_POST['login'], $_POST['email'], $_POST['password'])) {
	$errors = array ();
	if(empty($_POST['login'])) {
		$errors['login'] = 'Вы не заполнили логин';
	}
	if(empty($_POST['password'])) {
		$errors['password'] = 'Вы не заполнили пароль';
	}
	if(empty($_POST['email']) || !filter_var($_POST['email'], FILTER_VALIDATE_EMAIL)) {
		$errors['email'] = 'Вы не заполнили email';
	}
	if(!count($errors)) {
		mysqli_query($link, "
		INSERT INTO `users` SET
		`login` = '".mysqli_real_escape_string($link, $_POST['login'])."',
		`password` = '".mysqli_real_escape_string($link, $_POST['password'])."',
		`email` = '".mysqli_real_escape_string($link, $_POST['email'])."',
		`age` = ".(int)$_POST['age']."
		") or exit(mysqli_error($link)); //вывод ошибок БД
	$_SESSION['regok'] = 'OK';
	header("Location: /index.php?module=cab&page=registration");
	exit();
	//выполняем какие-то действия
	}
}

20.8.3 Чтобы данные из полей при неверном введении не вводить заново то в input добавляем следующее:
value="<?php echo @$_POST['login']; ?>">

20.8.4 XSS-inj - хакерский взлом логина(уязвимость полей форм):
если ввести в поле логин надпись te<">text<b>text   "- в таком случае за края формы вылезет текст:
texttext''> - значения из переменной $_POST будут выводиться на страницу.
Чтобы этого не происходило добавляем в параметр value функцию htmlspecialchars:
value="<?php echo @htmlspecialchars($_POST['login']); ?>"> //функция экранирует, подменяет одни символы другими
С помощью этой функции мы не запрещаем использовать определенные символы, но они уже не ломают нам систему.

20.8.5 Очистка данных: если человек успешно внес данные и получил надпись об успешной регистрации, нажмет F5
(обновит страницу), то эта запись повторно внесется в БД и создаст дубликат.
Для этого нужно сделать после регистрации переадресацию на другую страницу (можно и на эту же)

20.9 Домашняя работа:
Очень простое задание, по аналогии сделать страницу на подобии отзывов и туда добавить форму добавления
комментариев. В свою очередь так же сделать обработку входящих данных. Кроме этого для textarea изучить
функцию на PHP: nl2br.
Необходимо делать вместе с домашкой к 21-ому уроку.

 Дополнение к домашке: Создать безопасную форму регистрации пользователя и вывод всех зарегистрированных
пользователей.  Не должно быть SQL-inj или XSS-inj. Перечень тестовых логинов без кавычек: "<b>inpost</b>",
"O'Henr''y", "Vo&quot;va", "Правда 1%", "ОбычныйUserId#1","x&*5!@#$%^*&?"," \ \ YE / / ","%%%%","\\","////".


Урок 21: Выборка из БД и вывод на экран
/*План:
PHP + MySQLi + SELECT*/

21.1 Вывод массива на экран по элементно:
Расмотрим БД в виде массива c подмассивами:
$users = array(
		1 => array (
				'id' => 4,
				'login' => 'inpost',
				'password' => '123',
				'email' => '123@mail.ru',
				'age' => 27,
		),
		2 => array (
				'id' => 5,
				'login' => 'Vasya',
				'password' => '234',
				'email' => 'vasya3@mail.ru',
				'age' => 20,
		),
		3 => array (
				'id' => 10,
				'login' => 'Petya',
				'password' => 'qweqr',
				'email' => 'petya@mail.ru',
				'age' => 17,
		),
		4 => array (
				'id' => 77,
				'login' => 'Masha',
				'password' => '1111',
				'email' => '1111@mail.ru',
				'age' => 18,
		),
		5 => array (
				'id' => 150,
				'login' => 'Dasha',
				'password' => '0000',
				'email' => 'dasha@mail.ru',
				'age' => 18,
		),
);
//Воспользуемся нашей функцией wtf из папки libs
wtf($users); // выведется наш массив в виде 5 элементов
//переберем массив циклом foreach, где $k = это наши ключи (1, 2, 3, 4, 5), $v = array (...) - массив
//Сейчас попробуем распечатать каждый из этих массивов ($k):
foreach($users as $k=>$v) {
    echo '<div>Запись №'.$k.'<br>';
    echo '<div>Идентификатор пользователя №'.$v['id'].'<br>';
    echo 'Имя пользователя: '.$v['login'].';<br>
        Его возраст:'.$v['age'];
    //wtf($v, 1); //1 передаем, чтобы скрип не остановился.
    echo '</div>';
}
exit();

21.2 Вытягиваем данные из БД - mysqli_fetch_assoc:
//Сделаем выборку одной записи из таблицы users:
$res = mysqli_query($link, "SELECT * FROM `users` ORDER BY `id` LIMIT 1") or exit(mysqli_error());
$row = mysqli_fetch_assoc($res); //достаем из таблицы выбранную запись, помещает результат из $res в $row.
//wtf($row); //проверочный ввывод на экран через функцию
echo $row['login']; // напишет "Петя"
exit();

21.3 Получаем количество строк в наборе результатов - mysqli_num_rows:
//Обращение к БД, которые выводят пустой результат, для этого осуществляем
//поиск учетных записей с возратом пользователя больше 100 лет:
$res = mysqli_query($link, "SELECT * FROM `users` WHERE `age` > 100") or exit(mysqli_error());
echo mysqli_num_rows($res); //0 - функция подсчета количества выбранных выводов из таблицы

//Проверка циклом вместо echo:
$res = mysqli_query($link, "SELECT * FROM `users` ORDER BY `id` LIMIT 10") or exit(mysqli_error());
if(mysqli_num_rows($res)){ //если больше нуля (true)
	echo 'Всего'.mysqli_num_rows($res).' записей<br>';
	while ($row = mysqli_fetch_assoc($res)) {// перебираем циклом все значения
		echo '<div>Сушествует пользователей: '.htmlspecialchars($row['login']).'</div>';
		//div добавляем чтобы каждый результат отображался с новой строчки
	} // как только дойдем до 11 записи (у нас лимит 10 стоит) итерация завершится - 10 раз выведем все 10
	// пользователей
} else {
	echo 'Нет записей по данному запросу';
}
exit();

//Вывод списка всех пользователей на сайте:
$res = mysqli_query($link, "SELECT * FROM `users` ORDER BY `id`") or exit(mysqli_error());
if(mysqli_num_rows($res)){
	echo 'Всего у нас на сайте'.mysqli_num_rows($res).' пользователей зарегистрировано<br>
	А именно: <ul>
	';
	$i = 0;
	while ($row = mysqli_fetch_assoc($res)) {
		//if(++$i == 10) { //можно и так писать переменную через условие
		echo '<li>'.(int)++$i.'. '.htmlspecialchars($row['login']).'</li>';
		//++$i; - Переменная увеличивается на 1
		//$i++ - Запоминается старое и новое значение до окончания действия, и в конце увеличивается!
	}
	echo '</ul>';
} else {
		echo 'Нет записей по данному запросу';
}
exit();

Урок 22: Редактирование и удаление данных. 1 Модуль CMS
/*План:
PHP + MySQLi + UPDATE + DELETE
Изучаем создание полноценного модуля в админке по добавлению, редактированию и удалению информации на сайте*/

22.1 CMS - это система управления сайтом/данными
Основные функции:
1) Вывод на экран
2) ДОбавление
3) Редактирование
4) Удаление
 Вывод/просмотр доступен обычным пользователям, а остльные три - админам из админки.

phpMyAdmin - это тоже CMS, но для разработчиков.
Для модераторов права нужно урезать, чтобы не удаляли пользователей или не меняли даты сообщений и прочее.
Поэтому админка для модераторов с другим функционалом.
Обычным пользователем/жураналистам тожде можно дать доступ, но с еще более урезанным функционалом.

22.2 Ограничение доступа к странице
Мы раньше учили в 16 уроке авторизацию. Блокировка доступа через куки:
if(!isset($_COOKIE['access'])) {
exit();
}

22.3 Блок новостей:
22.3.1 Создаем папки и файлы main.**
./modules/news/main.php // контроллер - обработка
./skins/default/news/main.tpl //вид - вывод на экран

Самый главный файл на сайте - то main, при таком условии мы попадем на main:
indes.php?module=news

22.3.2 Создаем таблицу в базе данных под новости:
id - INT -PRIMARY
date - DATETIME
title - TEXT
cat - VARCHAR - 255 //категория
text - TEXT
description - TEXT  //краткое описание для главной страницы - превью
meta_title - TEXT //для SEO
meta_keywords - TEXT // ключевые слова для SEO
meta_description - TEXT //для SEO
status - //0 - не ободрено, 1 одобрено для вывода на сайте
Таблица: InnoDB
сравнение: utf8_unicode_ci

22.3.3 main.php: (00:29:57)
Создаем запрос:
$news = mysqli_query($link, "
	SELECT *
	FROM `news`
	ORDER BY `id` DESC
");

22.3.4 main.tpl (00:31:55)
//Выводим названия новостей циклом:
<div style="padding-top:20px; padding-bottom:20px">
<p> Все существующие новости </p>
<?php while($row = mysqli_fetch_assoc($news)) { ?>
<div>
	<div><b><?php echo $row['title']; ?></b> <!--вывод заглавия-->
		<span style="color:#5c636a; font-size:10px;"><?php echo $row['date'] ?></span><!-- и даты, серым-->
    </div>
</div>
<?php } ?>
</div>

Добавление новости у нас будет по кнопке:
<a href="/index.php?module=news&page=add">Добавить новую новость</a>  <!--у меня в проекте вместо page будет action-->

<?php
22.3.5 Создаем в папке 'news' файлы add.php(в модуле) и add.tpl(в статике)

22.3.5.1 add.tpl: //?module=news&page=add
?>
<div>
	<form action="" method="post">
		<input type="text" name="" value="">
			<div>
				Заголовок новости *: <input type="text" name="title"> <!--проверяем на ошибку вывода заголовка
				из позапрошлого урока, доделать самому-->
			</div>
			<div>
				Категория новости: <input type="text" name="cat">
			</div>
			<div>
				Описание новости:
				<textarea name="description"></textarea> <!--name соотвествует разделу в БД-->
			</div>
			<div>
				Полный текст новости:
				<textarea name="text"></textarea> <!--name соотвествует разделу в БД-->
			</div>
		<input type="submit" name="add" value="Добавить новость">

	</form>
</div>
<?php
22.3.5.2 add.php: //Делаем проверку на существование постов и пишем наш код обработки:
Функция trim() - обрезает строку, удяляя лишние пробелы в начале и конце строки, в скобках после переменной можно
по желанию указать какие еще символы мы хотим удалить.
Есть три варианта использования trim():
1) у условии if
2) прогнать $_POST через trim() с помощью цикла foreach
3) внутри функции mysqli_query
Выбирается один из этих способов:
if(isset($_POST['add'], $_POST['title'], $_POST['text']=trim($_POST['text']), $_POST['cat'], $_POST['description'])) {
	//echo 'Форма нормально отправилась'; //проверка - если все значения поста правильно записаны, то выведется
	//exit(); //если все норм то стираем и пишем дальше
		foreach($_POST as $k=>$v) {
		$_POST[$k] = mysqli_real_escape_string(trim($v)); //двумя функциями сразу пост прошлись
	// так мы все значения $_POST[''] обрезаем и не нужно каждое отдельно
	//если тут использовали mysqli_real_escape_string, то ниже можно не использовать, но Стас советует использовать
// в mysqli_query, а не в цикле, чтобы видеть применили мы mysqli_real_escape_string или нет и случайно не пропустили
		}
	mysqli_query($link, "
		INSERT INTO `news` SET
		//запрос можно стилизировать пробелами:
		//trim можно и сюда вставить:
		`cat` 		  = '".mysqli_real_escape_string($link, trim($_POST['cat']))."',
		`title` 	  = '".mysqli_real_escape_string($link, trim($_POST['title']))."',
		`text` 		  = '".mysqli_real_escape_string($link, trim($_POST['text']))."',
		`description` = '".mysqli_real_escape_string($link, trim($_POST['description']))."',
		`date`        = NOW() //ставит сегодняшнюю дату аналог настроке в MySQLi
	") or exit(mysqli_error());
	$_SESSION['info'] = 'Запись была добавлена'; //уведомление пользователя, что его новость была добавлена
	header('Location: /index.php?module=news'); //переадресацию на главную страничку на main
	exit();
}

22.3.5.2.1 Этот цикл проверки можно вынести в variables.php, чтобы ее  каждый раз не писать:
if(isset($_POST) && count($_POST)) {
	foreach($_POST as $k=>$v) {
	$_POST[$k] = mysqli_real_escape_string(trim($v));
}

Функция mysqli_real_escape_string() - экранирует кавычки и слеши.
Входящие параметры: 1.ССылка на коннект, 2. Переменная, которую необходимо экранировать
Выходящие параметры: экранный текст

22.3.5.3 main.php: (00:48:25)
//делаем проверку если сессия
if(isset($_SESSION['info'])) {
	$info = $_SESSION['info']; //передаем содержимое сессии в переменную инфо
	unset($_SESSION['info']); //удаляем сессию за ненужностью.
}

22.3.5.4 main.tpl:
if (isset($info)) { ?> //вывело, что запись была добавлена и сделало переадресацию
	<h1><?php echo $info; ?></h1>
<?php } ?>

<?php
22.3.5.5 Теперь добавление новостей уже должно работать. Делаем проверку. Модуль добавления новостей готов.
Осталось сделать модуль удалению и модуль редактирования новостей.

22.4 Удаление записей (1:20:00)
22.4.1 main.php:
//Первый вариант удаления через цикл foreach после нажатия кнопки($_POST['delete']):
if (isset($_POST['delete'])){
//wtf($_POST['ids']); первоначальная проверка, что попадает в $_POST['ids'] - этот вариант не самый оптимальный
//так как если отмеченно 3 checkbox, то в БД будет отправлено 3 запроса на удаление последовательно
	foreach($_POST['ids'] as $k=>$v) {
		mysqli_query($link,"
		DELETE FROM `news`
		WHERE `id` = ".(int)$v."
	");
	}
}
//Второй вариант - отправка запроса на удаление одним запросом:
// Функция implode говорит, что мы по определенному символу, у нас запятая, объединяем массив и на выходе
// получаем обычную строку. Вместо ',' можно использовать '</tr><tr>',чтобы получить колонки
if (isset($_POST['delete'])){
		//циклом прогоняем массив, чтобы привести его к типу число (int):
		foreach($_POST['ids'] as $k=>$v) {
		$_POST['ids'][$k]
		= (int)$v;
		}
		//wtf($_POST['ids'],1); //выведет на экран массив
		$ids = implode(',', $_POST['ids']);
		//wtf($ids); // выведет на экран 3, 2, 1
		mysqli_query($link,"
			DELETE FROM `news`
			WHERE `id` IN ".$ids."
		") or exit(mysqli_error());
}
//Каждый отмеченый checkbox добавляет цифры в массив:
//$_POST['ids'] = array(3,2,1);

if(isset($_GET['action']) && $_GET['action']=='delete'){
	mysqli_query($link,"
		DELETE FROM `news`
		WHERE `id` = ".(int)$_GET['id']."
	") or exit(mysqli_error());
	$_SESSION['info'] = 'Новости были удалены';
	header("Location: /index.php?module=news");
	exit();
}


22.4.2 main.tpl - теперь будет выглядеть так: ?>
<div>
	<?php if (isset($info)) { ?>
		<h1><?php echo $info; ?></h1>
    <?php } ?>

<a href="/index.php?module=news&page=add">ДОБАВИТЬ НОВУЮ НОВОСТЬ</a>
<br>
Все существующие новости:
	<form action="" method="post">
		<?php while(?row=mysqli_fetch_assoc($news)) { ?>
			<div>
				<div><input type="checkbox" name="ids[]" value="<?php echo $row['id']; ?>">
					<a href="/index.php?module=news&action=delete&id=<?php echo $row['id']; ?> ">УДАЛИТЬ</a>
                    <!--action - это действие делете, перехват события-->
					<b><?php echo $row['title']; ?></b>
					<span><?php echo $row['date']; ?></span>
				</div>
			</div>
			<hr>
		<?php } ?>
		<input type="submit" name="delete" value="Удалить отмеченные записи">
	</form>
</div>

<?php
22.4.3 variables.php
//временно закомментим - в последующих уроках ее немного изменим
//обработка трима сделать в add.php
/*if(isset($_POST) && count($_POST)) {
    foreach ($_POST as $k => $v) {
        $_POST[$k] = trim($v);
    }
}*/

22.5 Редактирование новостей (01:44:03)
22.5.1 main.tpl (добавим строчку радактирования новости)
<div>
<?php if (isset($info)) { ?>
<h1><?php echo $info; ?></h1>
<?php } ?>

<a href="/index.php?module=news&page=add">ДОБАВИТЬ НОВУЮ НОВОСТЬ</a>
<br>
Все существующие новости:
<form action="" method="post">
    <?php while(?row=mysqli_fetch_assoc($news)) { ?>
	<div>
		<div><input type="checkbox" name="ids[]" value="<?php echo $row['id']; ?>">
			<a href="/index.php?module=news&page=edit&id=<?php echo $row['id']; ?>">ОТРЕДАКТИРОВАТЬ</a>
			<a href="/index.php?module=news&action=delete&id=<?php echo $row['id']; ?> ">УДАЛИТЬ</a>
			<b><?php echo $row['title']; ?></b>
			<span><?php echo $row['date']; ?></span>
		</div>
	</div>
<hr>
    <?php } ?>
	<input type="submit" name="delete" value="Удалить отмеченные записи">
</form>
</div>

<?php
22.5.2 edit.php
if(isset($_POST['ok'], $_POST['title'], $_POST['text'], $_POST['cat'], $_POST['description'])) {
	foreach($_POST as $k=>$v) {
		$_POST[$k] = mysqli_real_escape_string(trim($v));
	}
	mysqli_query($link, "
		UPDATE INTO `news` SET
		//запрос можно стилизировать пробелами:
		//trim можно и сюда вставить:
		`cat` 		  = '".mysqli_real_escape_string($link, trim($_POST['cat']))."',
		`title` 	  = '".mysqli_real_escape_string($link, trim($_POST['title']))."',
		`text` 		  = '".mysqli_real_escape_string($link, trim($_POST['text']))."',
		`description` = '".mysqli_real_escape_string($link, trim($_POST['description']))."',
		`date`        = NOW() //если эту строчку убрать, то дата сменится на дату при редактировании
		WHERE `id` = ".(int)$_GET['id']."
	") or exit(mysqli_error());
$_SESSION['info'] = 'Запись была изменена';
header('Location: /index.php?module=news');
exit();
}

$news = mysqli_query($link,"
	SELECT *
	FROM `news`
	WHERE 	`id` = ".(int)$_GET['id']."
	Limit 1
	") or exit(mysqli_error());

if(!mysqli_num_rows($news)) {
	$_SESSION['info'] = 'Данной новости не существует!';
	header("Location: /index.php?module=news&page=news");
	exit();
}

$row = mysqli_fetch_assoc($news);
//wtf($row); //видим нашу новости в виде массива

if(isset($_POST['title'])) {
	$row['title'] = $_POST['title'];
}

22.5.3 edit.tpl  (01:55:34)
Тут у нас будет форма точно такая же как в add.tpl , только нужно добавить чтобы редактируемая новости подставилась
в поля формы, чтобы было что редактировать ?>
<div>
	<form action="" method="post">
		<input type="text" name="" value="">
		<div>
			Заголовок новости *: <input type="text" name="title" value="<?php echo htmlspecialchars($row['title']); ?>">
		</div>
		<div>
			Категория новости: <input type="text" name="cat" value="<?php echo htmlspecialchars($row['cat']); ?>">
		</div>
		<div>
			Описание новости:
			<textarea name="description"><?php echo htmlspecialchars($row['description']); ?></textarea>
		</div>
		<div>
			Полный текст новости:
			<textarea name="text"><?php echo htmlspecialchars($row['text']); ?></textarea>
		</div>
		<input type="submit" name="ok" value="Редактировать  новость">

	</form>
</div>

<?php
22.6 Домашняя работа
По такой же аналогии работают интернет магазины, где используется добавление, редактирование и удаление товаров.
В домашней работе сделать по аналогии с новостями управление товарами. Нам необходима простая категория, тоже самое
как выше указывали категорию, только сделать ее не через текст, не через инпут, а через <select>, то есть в <select>
(способ выбора) будет указано какие варианты можно выбрать (либо холодильники, либо телевизоры).
Нужно сделать раздел товары (goods)
Подсказка по <select> - чтобы запомнить предыдущий выбор option в селекте мы пишем:
<option selected="selected">
дальше через if проверяем если в $row находится наш выбор, то пишем селектед=селектед, если нет - не пишем.
Дальше по второму выбору если да, то все так же


Урок 23: Собственные функции, функция-оболочка, рекурсия
/*План:
mysqli оболочка
Пишем свои функции
Рекурсионный вызов функций
array_map*/

23.1 Функция в функции.
23.1.1 Функция распечатка:
function printR($var) {
    echo '<pre>';
    print_r($var);
    echo '</pre>';
}
$array = array(1,2,3);

//теперь используем ее:
printR($array);

23.1.2: (00:17:55) Функция работы с запросом и дебаг ошибок
для отображения правильного ошибок нужно:
Перед mysqli_connect прописать:
mysqli_report(MYSQLI_REPORT_OFF);
Начиная с PHP 8.1 работа немного изменилась, сейчас перехватить нельзя, сразу Fatal Error кидает без этой настройки.

(!) Итого файл 'db_config' уже должен выглядеть так:
mysqli_report(MYSQLI_REPORT_OFF);
$link = mysqli_connect(DB_HOST, DB_LOGIN, DB_PASS, DB_NAME);
mysqli_set_charset($link,'utf8');

//Пишем функцию оболочку для запроса:
$result = mysqli_query($link, "SELECT * FROM `comments`");
23.1.2.1 //функция
function q($link, $query) {
    //var_dump (mysqli_query($link, $query)); // посмотрим, что вернет функция
    return mysqli_query($link, $query);
    if($result === false) {
        echo 'Была ошибка';//дебаг
        exit(); //остановим код
    } else {
        return $result; // запрос составлен верно, то вернем на страницу $result
    }
}
//Используем ее:
$result = q($link, "SELECT * FROM `comments`");
//mysqli_query возвращает результат только в том случае, если запрос произошел без ошибок,
// если запрос произошел с ошибками - вернет false, то есть запрос небыл успешен:
var_dump($result);

В этой функции просто покажет сообщение об ошибке. Для того, чтобы знать из-за чего ошибка используем:
or exit(mysqli_error());

23.1.2.2 //измененная функция - улученный вывод сообщения об ошибке:
function q($link, $query) {
//var_dump (mysqli_query($link, $query)); // посмотрим, что вернет функция
    return mysqli_query($link, $query);
    if($result === false) {
        echo "Запрос: ".$query.'<br>'.mysqli_error($link);//дебаг(перехват ошибки)
        exit(); //остановим код
    } else {
        return $result; // запрос составлен верно, то вернем на страницу $result
    }
}
//С помощью этой функции мы избавимся от необходимости дописывать каждый раз проверку ошибок 'or exit(mysqli_error());'

23.1.2.3 //Записываем вывод ошибки в логи, а не на экран пользователя, уведомление на email:
function q($link, $query) {
    $result = mysqli_query($link, $query);
    if($result === false) {
        //$info = debug_backtrace();
        //wtf($info);//распечатка ошибки на экран
        $error = "query: ".$query."<br>\n".mysqli_error($link);//дебаг(перехват ошибки)
        //отправляем на почту письмо об ошибке (учить будем это в последующих уроках)
        //записываем ошибку в логи:
        file_put_contents('./logs/mysql.log', strip_tags($error)."\n\n", FILE_APPEND);
        echo $error;
        exit(); //остановим код
    } else {
        return $result; // запрос составлен верно, то вернем на страницу $result
    }
}
//У нашей функции один недочет - она не указывает на какой строчке была ошибка и в каком файле.
(00:43:04) //Для этого добавим в функцию новую функцию debug_backtrace();

23.1.2.4 Домашнее задание №1 - улучшить эту функцию (00:46:00)
Нужно сделать красивое оформление ошибок
Добавить вывод в сообщение об ошибке название файла и №строчки, остальное нам ненужно пока-что
Так же добавить дату создания ошибки - функция date("Y-m-d H:i:s");
Проверить добавляя в запросы лишние буквы

23.1.2.5 GLOBALS['']
Все переменные дублируются в глобальный массив GLOBALS[''], поэтому учитывая это можно еще сократить
нашу функцию:
//первый вариант:
function q($query) {
    $link = GLOBALS['link']; //делаем переменную $link видимой внутри функции
    $return = mysqli_query($link, $query);
//и так дальше - это часть кода - $link перенесли из условия внутрь функции

//второй вариант:
function q($query) {
    global $link; //получаем тот же эффект
    $return = mysqli_query($link, $query);
    //...

23.1.2.6 Добавить эту функцию в наш сайт в папку libs/default.php

23.1.2.7 Создаем mysql.log (00:53:50)
Функция записи ошибки в файл (00:57:12)
file_put_contents( //Пишет данные в файл
    './logs/mysql.log', //путь к файлу - адресс лога
    strip_tags($query).// содержание - функция удаляет теги HTML и PHP из строки (в нашем случае из запроса)
    "\n\n", // перенос строки
    FILE_APPEND); // дописывает новые логие, после предыдущих, без перезаписи

23.1.3 Функция myInclude: (01:01:45)
function myInclude() {
    if(file_exists()) {
        include ...
    } else {
        file_put_contents('./logs/mysql.log', strip_tags($error)."\n\n", FILE_APPEND);
        //отправка ошибки в файл
        exit();
    }
}

23.2 Новые Функции (01:13:27)
23.2.1 file_put_contents - Пишет данные в файл, достает контент из файла (мы изучили выше)
23.2.2 file_get_contents - Читает содержимое файла в строку, возвращает содержание файла (альтернатива,
из настроек только путь к файлу)

$var = file_get_contents('./logs/mysql.log'); //выведет на экран содержимое файла лога

23.2.3 file_exists('./logs/mysql.log'); // проверяет путь к файлу и возвращает true или false
if(file_exists('./logs/mysql.log')) {
    //делаем к нему запрос
}

23.2.4 trim(); - обрезает строку удаляя в начале и конце пробелы.

23.2.4.1 Нужно запомнить, что применении этой функции к массиву вложенному в массив, то эта функция только обрежет
только пробелы у массива первого уровня, а у второго нет.
Для этого нужно повторно использовать цикл foreach для вложенного в массив массива:
foreach($array as $k=>$v) {
    if(is_array($v)) {
        foreach($v as $k2 = $v2) {
            $array[$k][$k2] = trim($v2);
        }
    } else {
        echo $k.'=>'.$v.'<br>';
        $array[$k] = trim($v);
    }
}
wtf($array);
Такой принцип построения функции называется "рекурсия". //Из википедии: "Реку́рсия — определение, описание,
// изображение какого-либо объекта или процесса внутри самого этого объекта или процесса, то есть ситуация,
// когда объект является частью самого себя."

23.2.4.2 Функцию foreach для массива такого вида:
foreach($array as $k=>$v) {
    $array[$k] = trim($v);
}
Можно сократить используя стандартную функцию:
$array = array_map('trim', $array);
С функцией array_map можно вместо 'trim' применять и другие функции, напрмер 'cube' возведет все элементы массива в куб
Функция array_map - проганяет весь массив и обрабатывает какими-то действиями

23.2.4.3 Теперь создадим функцию с trim():
function trimAll($elem) {
    if(!is_array($elem)) { //если это не массив
        $elem = trim($elem); //то мы его обработаем тримом
    } else {
        $elem = array_map('trimAll', $elem); // делаем замыкание функции смой себя и каждый раз залазит глубже в массив
    }
    return $elem; //массив не будем трогать
}
//После прохождения выдает чистый массив без пробелов в начале и конце каждого значения массива

Пример использования:
$array = trimAll($array);

23.2.4.4 Домашнее задание №2
По этому принципу можно сделать функции, которые будут выполнять приведение к типу:
int, float, ...
делать обработку: mysqli_real_escape_string (для этой функции нужно будет применить global)
И еще htmlspecialchars (подсказка: 01:36:17 - тут и другие примеры функций):
function hsc($data) {
    if(is_array($data)) {
        $data = array_map('hsc', $data);
    } else {
        $data = htmlspecialchars ($data);
    }
    return $data;
}

23.2.4.5 Домашнее задание №3 (01:40:17)
Прочитать про следующие функции на php.net:
mb_stripos//Регистронезависимый поиск позиции первого вхождения одной строки в другую,
mb_strlen//Получает длину строки,
mb_strtolower//Приведение строки к нижнему регистру,
mb_strtoupper//Приведение строки к верхнему регистру,
str_replace//Заменяет все вхождения строки поиска на строку замены,
explode//Разбивает строку с помощью разделителя,
implode//Объединяет элементы массива в строку,
strip_tags//Удаляет теги HTML и PHP из строки

23.2.4.6 Добавить в файл .htaccess строчки:
AddDefaultCharset UTF-8
php_flag display_errors ON
php_value mbstring.internal_encoding UTF-8
php_flag magic_quotes_gpc off
php_flag magic_quotes_rubtime off
php_flag register_globals off


Урок 24: Классы, autoload, и класс отправки писем (2022-05-28)
/*План:
Классы
autoload
отправка писем
mail*/
//lesson24a (вступление по классам), lesson24b (основная часть)

24.1 Классы (24b 00:01:00)
Класс - это набор свойств и методов для реализации поставленной задачи.
Классы программисты создают один раз и потом ими всю жизнь пользуются на разных проектах/сайтах, меняя только
настройки (свойства класса).
Названия класса всегда начинается с Заглавной буквы, дальше верблюжий стиль.
Под каждый класс создается новый файл с именем класса: class_Mail.php
Классы имеют тип объект(object).
Классы сами по себе не являются ООП, но на них строится ООП.

24.1.0.1 Подключение класса:
include './libs/class_Mail.php'; //в main.tpl

24.1.0.2 Чтобы все классы не находились в памяти постоянно используется аутолоад (по мере
необходимости подгружает классы) - spl_autoload_register (до патча 8.0 использовался синтаксис
__autoload):
spl_autoload_register(function ($class) { //пишется в ядро - default.php
    include './libs/class_'.$class .'.php';
});

24.1.1 Шаблон:
class MyName1 {
    static $opacity = 100; // ПЕРЕМЕННЫЕ внутри класса называются - СВОЙСТВАМИ!
    static $size =30;
static function makeLine1 { //ФУНКЦИИ внутри класса называются - МЕТОДЫ!
        echo 'test'...
    }
static function makeLine2 {
    ...
    }
}
echo MyName1::$opasity; //класс ссылается на переменную - выведет 100.
echo MyName1::makeLine1(1, 5151); //класс ссылается на функцию класса

24.1.1.1 Оператор разрешения области видимости (::) (из php.net)
Оператор разрешения области видимости (также называемый "Paamayim Nekudotayim") или просто "двойное двоеточие"
- это лексема, позволяющая обращаться к статическим свойствам, константам и переопределённым свойствам или
методам класса.
При обращении к этим элементам извне класса, необходимо использовать имя этого класса.
Можно обратиться к классу с помощью переменной. Значение переменной не должно быть ключевым словом (например,
self, parent или static).
"Paamayim Nekudotayim" на первый взгляд может показаться странным словосочетанием для обозначения двойного двоеточия.
Однако, во время создания Zend Engine версии 0.5 (который входил в PHP3), команда Zend выбрала именно это обозначение.
Оно на самом деле означает "двойное двоеточие" - на иврите!


24.1.2 : Методы (Функции класса) делятся на 4 вида: (24b 00:06:50)
1) static (статические) - к ним мы можем ссылаться из любой точки кода. Статические функции и переменные
видны из других функций и классов, у них глобальная область видимости, так же как и у POST, GET,
сессий. На static ссылаемся через self::$var. Так как статические методы вызываются без создания экземпляра класса,
то псевдопеременная $this недоступна внутри статических методов. Доступ к статическим свойствам осуществляется
с помощью оператора разрешения области видимости (::), и к ним нельзя получить доступ через оператор объекта (->).
2) public (публичный) (24b 00:40:00) - можем менять значения и выводить значения.
На public ссылаемся через $this->var; (синтаксис отличается - внимание на $)
3) private - мы не можем менять переменные как в public, выдаст ошибку. Делается для того, чтобы с переменной мы
работали только внутри класса.
4) protected - тоже, что и private, только доступ получают и наследники класса в том числе

24.1.3.1 Класс на примере пагинатора (24b 00:10:17)
//1-й вариант для VIEW
class Paginator {
    static $howpage = 9; //количество страниц в пагинаторе для отображения
    static $shownumber = true; //количество страниц через котрые перепрыгнет при нажатии NEXT
    static $shownext = true; //отображение NEXT

    static function showPaginator() {
        echo '1,2,3,4';
    }
}
//Использование в tpl папка static:
Paginator::showPaginator();

//2-й вариант для контроллера
class Paginator {
    static $howpage = 9; //количество страниц в пагинаторе для отображения
    static $shownumber = true; //количество страниц через котрые перепрыгнет при нажатии NEXT
    static $shownext = true; //отображение NEXT

    static function showPaginator() {
        return '1,2,3,4'; //
    }
}
//Использование в php папка modules:
$pages = Paginator::showPaginator();

24.1.3.2 Использование одного класса пагинатора на разных страницах с разными настройками (24b 00:15:10)
В таком случае переназначаем свойство:
Paginator::$howpage = 5; //для это страницы будет вместо стандартных 9 выводиться 5 страниц
Paginator::$shownext = false; // для это страницы NEXT будет скрыто
$pages = Paginator::showPaginator();

еще можно внутри метода(функции) менять свойства:
static function showPaginator() {
    self::$shownext = false
}

24.2 Настройка нашего ядра через классы (24b 00:25:00)
24.2.1 config.php
У нас все настройки содержатся в константах - define ();
define('CREATED',2022);
define('SKIN','default');//это константа для смены скинов, если будет еще скины вдруг
define('ADMINLOGIN', 'Roman'); //и так далее

Но можно от этого избавиться использовав класс. Этот класс назовем ядро
class Core {
    static $CREATED    = 2022; //можно пробелами выравнивать в столбик, без табов!
    static $SKIN       = default;
    static $ADMINLOGIN = Roman;
    static $ADMINEMAIL = roma@gmail.com;
...
}
Получился псевдомассив, класс с набором переменных

Если в другом месте захотим сослаться на нашу переменную, то укажем:
echo Core::$SKIN;

24.2.2 'db_config.php' будет выглядеть так:
$link = mysqli_connect(Core::$DB_HOST, Core::$DB_LOGIN, Core::$DB_PASS,Core::$DB_NAME);

24.2.3 'index.php'
include '/skins/'.SKIN.'/index.tpl';
меняем на:
include '/skins/'.Core::$SKIN.'/index.tpl';

24.3 Экземпляры класса (24b 00:29:08)
Если у нас появляется необходимость использования в одном проекте один и тот же класс с разными настройками,
то на помощь придет создание экземпляров класса:
class Illustrator{
    public $radius = 10;
    public function makeGraphic() {
        echo $this->radius;
    }
    public function test() {
        $this->test(); //может ссылаться сам на себя, создавать рекурсию (в выпадающей полдсказке видно)
    }
 }
//Использование - если свойство public, то в экземплярах меняем через свойства:
$ill1 = new Illustrator;
//echo Illistrator::$radius; // синтаксис для статик (тут для сравнения)
echo $ill1->radius=33; // синтаксис для приват - выведет на экран 33, хотя по умолчанию стоит 10

$ill2 = new Illustrator;
echo $ill2->radius=5; // выведет на экран 5
//внутри каждого такого экземпляра будет содержаться полная копия класса и они будут сущенствовать независимо
//друг от друга

Стоит учесть, что экземпляр класса ($ill1, $ill2) пренадлежит не константе, это переменная, а область видимости
переменной закрытая, эти переменные внутри других функций уже не видны.

24.3.2 Смешение public и privat
Если у нас в классе свойство(переменная) приватное, а метод(функция) паблик, то синтаксис такой уже:
class Illustrator{
    privat $radius = 10; //внутри класса можем ссылаться, а за пределами нет
    public function makeGraphic() {
        $this->test(); //тут на приватную функцию можно ссылаться, так как в пределах класса.
        echo $this->radius;
    }
    public function changeRadius($radius) { //функция специально создана для изменения свойства $radius
        $this->radius = $radius; //
    }
    private function test() {

    }
}
//Использование тоже получает другой синтаксис:
$ill1->changeRadius(5); //меняем теперь через метод
$ill2->changeRadius(33);
//во второй функции класса изменений нет, поэтому пишем в таком синтексисе:
$ill1->makeGraphic();
$ill2->makeGraphic();

$ill1->test(); //это ошибка, так как метод (функция) приват, но мы можем ссылаться на нее к примеру внутри
//другой функции класса (в примере в makeGraphic)

Зачем переменные делают приватными? Иногда появляется потребность, чтобы не все переменные были доступны таким вот
образом. То же касается и приватных методов.
Правило(не всего поддерживают): абсолютно все свойства и все методы писать приватными, КРОМЕ тех, с которыми
наше приложение должно работать. Если какой-то метод внутри класса является вспомогательным, то он только приватным
должен быть.

24.3.3 Добавление свойств (переменных) внутри класса: (24b 00:55:00)
$test = new Illustrator;
$test->lala='Эксперимент';
var_dump($test);
//при выводе уже увидим, что к классу добавилась новая переменная

24.4 Создаем класс для почты(папка libs/class_Mail.php) (24b 01:31:10)
Сам PHP не рассылает письма, он создает файл в формате *.eml и этот файл копирует в папку sendmail.
Апач нам установил РНР, а вот отправщик писем sendmail.exe это отдельное приложение, которое собственно и должно
рассылать письма. Такая работа аналогична с работой с логами из предыдущего урока, когда мы какую-то информацию
помещаем в файл логов.

mail('кому', 'тема письма', 'текст письма');
mail('кому', 'тема письма', 'текст письма', $headers);

class Mail {
    static $subject = 'Вы зарегистрировались на нашем сайте'; //по умолчанию
    static $from = 'inpost@list.ru';
    static $to = 'inpost@list.ru';
    static $text = 'Шаблонное письмо';
    static $headers = '';

    static function testSend() {
        if(mail(self::$to, 'english words', 'english words')) {
            echo 'Письмо отправилось';
        } else {
            echo 'Письмо не отправилось';
        }
        exit();
    }
    static function send() {
        self::$subject = '=?utf-8?b?'. base64_encode(self::$subject) .'?=';//заголовок сообщения перекодированный
        // в base64, чтобы избежать проблем с кодировкой;
        self::$headers = "Content-type: text/html; charset=\"utf-8\"r\n";//тип письма и его кодировка, тип письма обычно
        // указывается html либо plain (текстовая версия);
        self::$headers .= "From: ".self::$from."\r\n"; //имя и e-mail отправителя;
        self::$headers .= "MIME-Version: 1.0\r\n"; //версия MIME-стандарта;
        self::$headers .= "Date: ".date('D, d M Y h:i:s O')."\r\n"; //дата отправки;
        self::$headers .= "Procedence: bulk\r\n";// этот заголовок необходим в случае массовой рассылки,
        // значение ставится bulk.

/*        if (mail(self::$to, self::$subject, self::$text, self::$headers)) { //проверка ушло ли письмо
            return true; // аналог - echo 'Письмо дошло';
        } else {
            return false; // аналог - echo 'Письмо не дошло';
        }*/
//можно записать короче:
    return mail(self::$to, self::$subject, self::$text, self::$headers);
    }
}
Использование класса:
Mail::$to = 'oleg@gmail.com';
Mail::$subject = 'Вы зарегистрировались'; //если в теме письма тот же текст, что и в свойствах, то можно не писать
Mail::$test = 'Ваш текст'
Mail::send();

Самая простая проверка отправилось ли письмо с помощью функции testSend().
Mail::testSend();

Если функция вернула true, то письмо отправлено, можно проверить в папке !sendmail в файле *.eml
Но если в файле *.eml запись есть, а получатель письмо не получил, то это может случиться по причинам:
    1) не настроена программа sendmail;
    2) хостер запретил отправку писем;
    3) проблема с заголовками.

Проверять почту желательнона gmail, тему и текст писать англ.буквами и проверить, чтобы не попало в спам.

Любой класс можно расширять. К классу отправки писем можно сделать рассылку нескольких писем, в таком случае
мы бы создавали массив и этот массив в цикле бы отправляли. Можно расширить, чтобы отправляло наше письмо
на разные почтовые ящики, через вызов в цикле подставляя каждый элемент цикла


Урок 25: Регистрация + Авторизация, установка прав доступа (2022-05-30)
/*План:
Регистрация
Hash
авторизация
подтверждение по email
права доступа*/

25.1 Регистрация(00:18:00)
Проверка на длинну логина:
if(empty($login)) {
    $errors['login'] = 'Вы не заполнили логин';
} elseif (mb_strlen($login) < 2) {
    $errors['login'] = 'Логин слишком короткий';
} elseif (mb_strlen($login) > 16) {
    $errors['login'] = 'Логин слишком длинный';
}
//то же и для пароля

Делаем проверку логина и email на уникальность: (01:31:16)
if (!count($errors)) {
        $res = q{"
            SELECT `id`
            FROM `users`
            WHERE `login` = '".mres($_POST['login'])."'
            LIMIT 1
        "};
    if(mysqli_num_rows($res)) { //функция - если такая запись существует
        $errors['login'] = 'Такой логин уже занят';
    }
}
// по аналогии и для почты

25.2 Hash пароли (00:26:30)
25.2.1 Hash пароли - это кодирование пароля по определенному алгоритму('MD5'), главной особенностью которой есть то,
что нельзя разобрать строку в обратном направлении. Длинна Hash всегда одинакова. Хеш содержит 128 бит (16 байт)
и обычно представляется как последовательность из 32 шестнадцатеричных цифр.
Несколько примеров хеша:
echo md5("md5"); // 1BC29B36F623BA82AAF6724FD3B16718
Пример MD5-хеша для «нулевой» строки:
echo md5("");// D41D8CD98F00B204E9800998ECF8427E

25.2.2 Пример применения
Регистрация:
$var = 'inpost'; //пароль при регистрации
$var = md5($var); //перекодируем в хещкод
//отправляем в БД

Логин зарегистрированного:
$var2 = 'inpost'; //пароль при авторизации
$vat2 = md5($var2); //перекодируем в хешкод
if ($var == $var2) {//хешкод совпадает
    //успешная авторизация
}

25.2.3 'Соль' - это произвольный текст
$salt = 'o4qi6kwj4eoi298347y892yokj';
$pass = 'inpost';
$pass = $salt.$pass.$salt;
$pass = md5($pass);
//Можно дополнительно еще раз прогнать через md5 результат:
$pass = md5(md5($pass).md5($salt2.md5(str_replace('AAA', '', $pass))));
В последнее время принято считать, что md5 не такое уже и безопасное, поэтому не рекомендуют его использовать
для шифрования паролей.

25.2.4 crypt() - функция шифрования, более продвинутая, чем md5.
function myHash ($var) {
    $salt = 'ABC';
    $salt2 = 'CBA';
    $var = crypt(md5($var.$salt), $salt2);
    return $var;
}

И когда мы пароль будем добавлять в БД мы его прогоним через функцию myHash
        q("
		INSERT INTO `users` SET
		`login`    = '".mres($login)."',
		`password` = '".myHash($password)."',
		`email`    = '".mres($email)."',
		`age`      = ".(int)$_POST['age']."
		");

25.3 Подтверждение по email (01:18:00)
После регистрации не стоит сразу авторизировать пользователя на сайте - нужно чтобы он подтвердил свой
email. Делается, чтобы боты от "фонаря" не писали почту.
В дальнейшем по проверенному email можно пользователю восстановить пароль.
Для того, чтобы удостовериться, что email принадлежит этому пользователю, мы сбрасываем на почту
просьбу подтвердить этот email
В БД мы так же создаем новое поле 'active' / тип TINYINT / длинна значения 1/
по умолчанию значение "0" /

Чтобы подтвердить пользователю, то мы должны создать еще один хеш. Второй хеш - это будет смесь
простой ссылки, по которой пользователь перейдет и будет означать, что определенный пользователь
подтвердил свой email.

$_SESSION['regok'] = 'OK';
Mail::$to = $_POST['email'];
Mail::$subject = 'Вы зарегистрировались на сайте';
Mail::$text = '...Если вы не регистрировались, то не отвечайте на данное письмо. Если это все-таки
вы регистрировались, то пройдите по ссылке для активации вашего аккаунта:
'.Core::$DOMAIN.'index.php?module=cab&page=activate&id='.$id.'&hash='.myHash($_POST['login'].$_POST['age']).'
';
header("Location: /index.php?module=auth&page=regin");
exit();

Где мы берем $id в запросе на активацию?
$id = mysqli_insert_id($link);

//Добавляем новое поле в БД и в функцию запроса к БД:
'hash' / VARCHAR / 255 / 'нет'
q("
		INSERT INTO `users` SET
		`login`    = '".mres($login)."',
		`password` = '".myHash($password)."',
		`email`    = '".mres($email)."',
		`age`      = ".(int)$_POST['age'].",
        `hash`     = ".myHash($_POST['login'].$_POST['age'])."``
		");

25.4 Активация (01:27:50)
25.4.1 activate.php (01:28:14)
В этой же папке создаем модуль активации - activate.php: (01:34:25)
Так как в почтовом письме hash передаем через параметр GET (в файле регистрации), поэтому
if(isset($_GET['hash'], $_GET['id'])) {
q("
        UPDATE `users` SET
       `active` = 1
		WHERE `id` = ".(int)$_GET['id']."
		    AND `hash` = '".mres($_GET['hash'])."'
    ");
$info = 'Вы активированы на сайте';
} else {
$info = 'Вы прошли по неверной ссылке';
}

25.4.2 activate.tpl
Cоздаем шаблон модуля активации activate.tpl: ?>
<div>
    <h1><?php echo $info; ?></h1>
</div>
<?php


25.5 Авторизация
После активации два пути:
1) пользователь вручную снова вводит свои регистрационные данные через отдельную форму
2) автоматическая авторизация после активации (2-й более преемлем)

25.5.1 authorization.php (01:37:30)
if (isset($_POST['login'], $_POST['pass'], $_POST['do_login'])) {
$res = q("
		SELECT *
		FROM `users`
		WHERE `login` = '".mres($_POST['login'])."'
			AND `password` = '".myHash($_POST['pass'])."'
			LIMIT 1
	");
if (mysqli_num_rows($res)) { //функция - если такая запись существует
    $_SESSION['user'] = mysqli_fetch_assoc($res);
} else {
    $error = 'Нет пользователя с таким логином и паролем';
}
}

25.5.2 authorization.tpl
<div style="padding: 100px;">
<?php if(isset($error)) {echo $error; ?>
    <form action="" method="post">
        Login: <input type="text" name="login"><br>
        Password: <input type="text" name="pass"><br>
        <input type="submit" name="submit" value="Вход">
    </form>
<?php } else {?>
    Позравляю, Вы авторизированы
<?php } ?>
</div>

<?php

25.5.3 Авторизация на куках и сессии (01:53:35)
Виды авторизации:
1) через адресную строку (старые форумы - неудобный)
2) через куки
Нам нужно сделать какую-то отметку, что пользователь зарегистрировался. Клиент должен серверу что-то скинуть, на
основании чего сервер даст ответ, что пользователь зарегистрирован (ок!).
Каким  образом клиент (компьютер пользователя) может запросить проверку у сервера?
Через GET, POST (старый вариант) и куки (самый простой).
В куках хранится не авторизация - в куках хранится идентификатор (ID сессии авторизации). Но этот ID сам по себе
ничего не значит без серверного ответа, то есть сервер должен убедиться, проверить эти данные в куках, что
действительно эти куки верные. После передачи кук на сервере мы должны проверить, что такая авторизация существует.
Если индентификатор существует, значит пользователь авторизирован.

Мы знаем, что в наших куках содержится ключ(идентификатор) сессии:
[PHPSESSID] => as60n31rkj7p1038tvo4de65aoltmr63 // идентификатор сессии => хеш
который говорит, что мы зарегистрированы и мы просим разрешения на вход на сайте, на что сервер должен ответить
авторизировать/впускать вас или нет.
Где хранить данные, что наш "билет" на вход действителен или не действителен? Значит мы эти данные должны хранить
на сервере.
У нас два варианта хранения этой информации:
1) в сессиях
2) сессия хранится в базе данных (особенно хорошо, когда БД хранится на других серверах, отличных от хостинга)

То что человеку можно, какие права у пользователя на данный момент - хранится в сессиях и эту обработку мы делаем
на сервере, поэтому хакер туда не сможет получить доступ и данные поламать. Мы делаем связку по [PHPSESSID]

Для проверки, что у нас хранится в куках создадим в корне файл temp.php:
echo '<pre>';
print_r($_COOKIE);
echo '</pre>';

Выведет на экран:
[PHPSESSID] => 3b7jde3t2rr28e1s3vnkrcjuquv52sue // идентификатор сессии => хеш


25.6 Права доступа (02:08:00)
В БД `users` добавим поле `access` / тип TINYINT /  длинна = 1 /по умолчанию  как определено = 0

25.6.1 Выход из сессий.
Добавляем папке "auth" файл exit.php и дубль exit.tpl (для отладки и проверки - выход из сессий):
session_unset();
session_destroy();
header('Location: /');
exit();
Далее для запуска файла дописываем в строке GET:
**/index.php?module=auth&page=exit
//После обновления странички temp.php там массив сессии будет пустой.

25.6.2 Создание доступа к странице (auth.php):
if (!isset($_SESSION['user']) || $_SESSION['user']['access'] != 1) {
    exit();
}
Это скрипт для блокировки страницы

25.6.3 Блокировка пользователя (02:13:50)
Делается просто - высталяем в базе в строчке `active` = 2 или `access` = 5

25.6.4.1 allpages.php (02:15:15)
В файле index.php если остались какие скрипты переносим в отдельный файл, а тут оставляем только редиректы
Создаем для этого отдельный файл allpages.php и подключаем его в index.php
include './modules/allpages.php';
Сюда пишем функционал, который будет подключаться ко всем страницам:
if(isset($_SESSION['user'])) {
    $res = q("
            SELECT *
            FROM `users`
            WHERE `id` = ".$_SESSION['user']['id']."
            LIMIT 1
        ");
    $_SESSION['user'] = mysqli_fetch_assoc($res);
    if($_SESSION['user']['active'] !=1) { //0 - не активирован, 1 - активирован, 2- забанен.
        header("Location: index.php?module=auth&page=exit");
    exit();
    }
}

25.6.4.1 Проверка на авторизацию в скинах (*.tpl):
if(isset($_SESSION['user'])) {
    //форма авторизации
} else {
    //вам необходимо авторизироваться.
}

25.7. Домашнее задание: (02:18:55)
25.7.1. Сделать авто-авторизацию на сайте. То есть для тех, у кого стоит при обычной авторизации галочка, что необходимо
автоматически авторизировать пользователя при следующем посещении сайта. Подробности в записи.
Так как сессия после выхода умрет, то для того чтобы снова авторизироваться, нам необходимо где-то хранить
идентификатор о том, что мы должны авторизироваться. Для этого используют куки. Чтобы хакеры не подделали ID код
нужно использовать хешкод, для автоавторизации. То есть в куках мы будем хранить ID пользователя и HASH, этот
хеш мы будем хранить в БД. Хеш будем создавать микс из логина, пользователя и email:
ID = 10; //id пользователя
HASH = ID+LOGIN+EMAIL //ключ в БД и куках для автоавторизации
Каждый раз когда пользователь хочет, чтобы его автоматически запомнили (ставит "галочку"), то мы будем в БД добавлять
хеш. Для всех это не делается, потому что если кто-то зальет вирус вашему клиенту, вирус сворует чужие куки и сможет
под чужим аккаунтом авторизироваться. Поэтому автоавторизация - это удобная вещь и абсолютно не безопасная для
посетителей. Это должно быть добровольно.
Спрашивать эту "галочку" должно при авторизации ($status = 'OK!';). Варианта два:
1) "Запомнить меня"
2) "Не запоминать"
После этого обычным UPDATE в БД прописываем новое значение в поле `hash` таблицы `users`
Этот hash мы сохраним одновременно и в куках (на странице авторизации) и в БД
А если кук не существует, делаем проверку:
} else {
    //проверять возможность на автоматическую авторизацию: myHash(ID+LOGIN+EMAIL)
}
Еще вариант разнообразия хеша - использовать функцию time():
hash = myHash(time() + ID);

Что такое автоматически авторизировать? Это значит, что мы должны создать переменную пользователя $_SESSION['user']
в БД $_SESSION['user'] = mysqli_fetch_assoc($res);
Но перед этим мы должны проверить точно ли такой хеш существует? А точно ли совпадает ID и хеш в БД?
Если такой хеш не существует, то его необходимо удалить.

Если хакер сможет своровать ID и хеш, то он сможет залогиниться и поэтому лучший вариант и в БД и в куках хранить
бонусом для сравнения: 1-й вариант - IP, 2-й вариант - браузер $_SERVER['HTTP_USER_AGENT'].
Но с IP есть проблема - он у большинства динамический и автоматическая авторизация не будет работать если человек
разлогинился. А HTTP_USER_AGENT можно подделать
IP и HTTP_USER_AGENT не нужно хранить в куках - это нужно хранить в БД
У кого может отсутствовать автоавторизация:
1) у незарегистрированных посетителей сайта
2) у тех, кто вышел (разлогинился)
3) у тех, кто не поставил галочку, чтобы его автоавторизировали
4) у тех кто захотел, чтобы его авторизировали, но не подошел IP или хеш или юзерагент, поэтому была удалена кука

У нас в итоге будет две куки - хеш и ID:
} elseif(isset($_COOKIE['autoauthhash'], $_COOKIE['autoauthid'])) {...

25.7.2. Комментарии только для авторизированных пользователей сделать (улучшить модуль комментирования на сайте).

25.7.3. Защитить модуль news от доступа пользователей, у которых нет прав смотреть данный раздел. Права есть в таблице
пользователей: access=5.


Урок 26: Работа над ядром: ЧПУ и оптимизация

26.1 ЧПУ, Mode Rewrite
ЧПУ - человекопонятный урл(адрес)
Замена нашего адреса:
test1.ua:8082/index.php?module=cab&page=regostration
на более понятный пользователю:
test1.ua:8082/cab/regostration

26.1.1 .htaccess
//Добавляем новый код:
RewriteEngine On
#Исключения, которые не обрабатываются ЧПУ:
RewriteCond %{REQUEST_URI} !^/admin
RewriteCond %{REQUEST_URI} !^/forum
RewriteCond %{REQUEST_URI} !^/ckeditor
#Стандартное поведение, что делать с папками и дирикториями:
RewriteCond %{REQUEST_URI} !-f
RewriteCond %{REQUEST_URI} !-d
#Автозамена:
RewriteRule ^(.*)$ index.php?route=$1 [L,QSA]

26.1.2 Проверка как выглядит адрессная строка:
26.1.2.1 в файле allpages.php первой строчкой пишем функцию:
wtf($_GET);

по запросу: http://testphpagro1.ua/index.php?module=news получаем
Array
(
    [route] => index.php
    [module] => news
    [page] => main
)

по запросу: http://testphpagro1.ua/index.php?module=game&page=game
Array
(
    [route] => index.php
    [module] => game
    [page] => game
)

http://testphpagro1.ua/index.php?page=services
Array
(
    [route] => index.php
    [page] => services
    [module] => static
)

26.1.2.2 Если такую же проверку сделать из variables.php, то вывод будет таким:
http://testphpagro1.ua/index.php?module=news
Array
(
    [route] => index.php
    [module] => news
)

http://testphpagro1.ua/index.php?page=services
Array
(
    [route] => index.php
    [page] => services
)

26.1.3.1 ЧПУ:(00:11:00)
//Если мы в адрессной строке вводим:
test.ua:8082/a/b/c
//Вот мы видим через wtf($_GET)
Array
    (
        [route] => a/b/c
    )
//то это означает:
$_GET['module'] = a
$_GET['page'] = b
$_GET['key1'] = c

26.1.3.2 В variables.php дописываем код в начале страницы: (00:10:00)
if(isset($_GET['route'])) {
$temp = explode('/', $_GET['route']); //функция разбивает строку в массив
//wtf($temp); если добавить к главной буквы http://testphpagro1.ua/a/b/c выведет ([0]=>a [1]=>b [2]=>c)
foreach ($temp as $k=>$v) {
    $_GET['key'.$k] = $v;
} //wtf($_GET); Array ( [route] => a/b/c [key0] => a [key1] => b  [key2] => c )
    unset($_GET['route']);// удаляем из массива [route] => a/b/c - он уже не нужен
wtf($_GET); получаем уже Array ( [key0] => a [key1] => b  [key2] => c )
}

26.1.3.3 Развиваем дальше этот же код (подгоняем ключи под наши стандарты сайта): (00:15:20)
if(isset($_GET['route'])) {
    $temp = explode('/', $_GET['route']);
    foreach ($temp as $k=>$v) {
        if($k ==0 ) {
            $_GET['module'] = $v;
        } elseif($k == 1) {
            if(!empty($v)) {
                $_GET['page'] = $v;
            }
        } else {
            $_GET['key'.($k-1)] = $v;
        }
    }
    unset($_GET['route']);
}

26.1.3.4 Использование ЧПУ
Если внести в строку ввода: test.ua:8082/auth/registration
получим массив:
Array([module]=>auth [page]=>registration)

Дальше в том же variables.php редирект:
header("Location: /index.php?module=errors&page=404");
приведем к новому виду:
header("Location: /errors/404");


Дополнительные проверки мы сделаем, когда изучим регулярные выражения

26.1.3.5 "Приколы ЧПУ" (00:18:00)
Чтобы наш ЧПУ работал без проблем нам нужно теперь еще добавить кое-что
Нам пришлось добавить проверку на пустые значения ключей, так как потом возникают проблемы если в конце строки
ввода поставить закрывающую косую черту /
Без него код считает строку как пустой файл:
(./modules/news/.php), а должно быть (./modules/news.php)
После добавления проверки на пустотувсе заработало:
if(!empty($v)) {...}

26.1.3.6 news/main.tpl
Далее правим ссылки в наших новостях, чтобы привести к новому виду
в main.tpl меняем ссылку:
href="/index.php?module=news&action=delete&id=(php код)"
на
href="/news/main?action=delete&id=(php код)" //внимание: знак & меняем на ?
//? означает, что мы к предыдущим двум стандартным параметрам добавляем еще один параметр
//получим вывод:
/news/main?action=delete&id=10
//Если мы хотим привести к такому виду:
/news/main/delete/10 //то последние два параметра будут key1 и key2
//и нужно уже будет писать так:
href="/news/main/delete/(php код)"

26.1.3.7 news/main.php (00:24:22)
//удаление новости:
if (isset($_POST['delete'])){
/*  foreach($_POST['ids'] as $k=>$v) {
    q("
        DELETE FROM `news`
        WHERE `id` = ".(int)$v."
	");
    }*/
    //измененный код из 26-го урока
    foreach ($_POST['ids'] as $k => $v) {
        $_POST['ids']['$k'] = (int)$v;
    }
    $ids = implode('/', $_POST['ids']);
        q("
            DELETE FROM `news`
            WHERE `id` IN (".$ids.")
        ");
    $_SESSION['info'] = 'Новости были удалены';
    header("Location: index.php?module=news");
    exit();
}

//if(isset($_GET['action']) && $_GET['action']=='delete'){
if(isset($_GET['key1'], $_GET['key2']) && $_GET['key1']=='delete'){
        q("
            DELETE FROM `news`
            //WHERE `id` = ".(int)$_GET['id']."
            WHERE `id` = ".(int)$_GET['key2']."
        ");
$_SESSION['info'] = 'Новость была удалена';
//header("Location: /index.php?module=news&page=main");
header("Location: /news");
exit();
}

26.1.3.8 ЧПУ - больше нужна поисковикам для раскрутки сайтов, для админки ЧПУ не нужна, так она не видна поисковикам.
Но об этом поговорим позже.

26.1.3.9 Если что-то не понятно как работает - разворачиваем массив через wtf($_GET);

26.1.3.10 Ошибка key2 (00:26:41)
test2.ua:8082/news/main/delete //Undefined index key2
Если мы используем внутри нашего сайта key2, но при этом его не передаем в адресной строке ошибка была в том,
что мы работаем с key2, но мы не проверили на ее наличие - проверяем все модули через isset:
if(isset($_GET['key1'], $_GET['key2']) && $_GET['key1']=='delete'){

26.2 Абсолютные и относительные ссылки (00:28:05)
Больше инфоррмации тут:
https://school-php.com/tricks/21/otnositelnyie-i-absolyutnyie-puti-v-html-i-php

26.2.1 Проблема картинок с нашим ЧПУ
Для начала в папку skins/default добавляем папки css, js и img. Перебрасываем их из корня
в конкретные скины. В дальнейшем это будет большим плюсом.

26.2.2 Пути к картинкам мы можем передавать тремя видами:
<img src="http://site.ru/skins/<?php echo Core::$SKIN; ?>/img/logo.png"> //это абсолютный путь
<img src="skins/default/img/logo.png">//относительный путь
<img src="/skins/<?php echo Core::$SKIN; ?>/img/logo.png">//относительно корня сайта - для простого переноса домена

В нащем проекте мы используем третий вариант - относительно корня сайта.

26.3 Динамические meta-данные, CSS, JS
26.3.1 Config.php (00:43:00)
Рассмотрим еще несколько свойств, которые нужно справить/добавить
static $JS = array();
static $CSS = array(); //пустой массив означает, что для всего сайта будут стандартные настройки из шапки index.tpl
static $META = array(
                    'title' => 'стандартный TITLE',
                    'description' => 'd',
                    'keywords' => 'k'
                    );

26.3.2 index.tpl
?>
<title><?php echo @$title; ?></title>
меняем на:
<title><?php echo hsc(Core::$META['title']); ?></title>
Обработано функцией для htmlspecialchars, так же меняем и остальные записи тут:
<meta name="description" content="<?php echo hsc(Core::$META['description']); ?>">
<meta name="keywords" content="<?php echo hsc(Core::$META['keywords']);?>">
<?php

26.3.3 Изменения для $META (00:47:25)
Важно! Теперь мы работаем над нашми модулями, мы создаем какие-то модули, у нас есть допустим новости.
В новостях мы что можем? Мы можем в main.php в начале дописать какое-то свое правило и это свое правило мы можем
писать непосредственно и с php понятное дело, мы можем из базы данных брать, мы можем генерировать специальные
метаданные. Если же мы метаданные какие-то не ввели, не уточнили, то берется из нашего ядра. В нашем ядре мы
прописали, что эти значения были по умолчанию.
Теперь если мы хотим этот параметр изменить, то мы пишем персональный title для конкретного определенного модуля,
то есть для новостей, к примеру, мы можем заменить старый параметр на новый:
Core::$META['title'] = 'Новый параметр';

Очень часто когда работаем с интернет магазинами 'description', 'title' и 'метаданные' - генерируются автоматически.
Для SEO нельзя дублировать 'description', 'title' и 'keywords', поэтому мы должны прописывать какие-то правила
для всего сайта(через allpages.php) или написать какие-то персональные правила для каждой конкретной странички.

Прописывая правила или вручную заполняя мы получим хороший... Мы могли бы так же метаданные хранить в БД и доставать
непосредственно в allpages.php:
$res = q ("
    SELECT *
    FROM `meta`
    WHERE '".mres($_GET['module'])."_".mres($_GET['page'])."'
    LIMIT 1
");
$row = mysqli_fetch_assoc($res); //достаем эти данные из $res
//теперь допишем эти данные в метамассив ядра
Core::$META['title'] = $row['title'];
Core::$META['description'] = $row['description'];
Core::$META['keywords'] = $row['keywords'];

//или более простой вариант:
Core::$META = $row;

Так мы сможем прописывать конкретные метаданные для конкретных страничек.

26.3.4 CSS, JS (00:54:00)
Если CSS подключить для корня ядра, то они будут доступны на всех страницах. Если нам нужна отдельный CSS стиль
для отдельной страницы, то мы используем специальные подключения. Если к приимеру нам в новостях нужен отдельный
стиль, то в main.php вверху страницы подключаем:
Core::$CSS[] = '<link type="text/css" rel="stylsheet" href="/css/news_style.css">';
Тоже и JS:
Core::$JS[] = 'Подключаем JS';

Для того чтобы он отобразился нам нужно упомянуть его в index.tpl (сразу подключения общего css):
<?php if(count(Core::$CSS)) {echo implode("\"n,Core::$CSS); } ?>
<?php if(count(Core::$JS)) {echo implode("\"n,Core::$JS); } ?>
"
Это значит, что если count вернет цифру ноль, то это событие не произойдет. Но при этом ноль не вернет в нашей новости,
потому что мы расширили там функционал. Благодаря этому новый CSS подключится толко на одной странице.

26.3.4 Почему нужны отдельные подключенния CSS, JS (00:57:05)
Есть популярная CMS JOOMLA, но у нее минус - JS подключается всегда в индексе для всех страниц. Итого если у нас есть
интернет-магазин и где-то в конкретном месте какой-то скрипт нужен только для данной страницы, то получается ситуация,
что чем больше использовалось скриптов, тем больше было нагромождение их. В итоге даже на тех страницах где JS не
нужен мы будем иметь все скрипты утяжеляя код. И чем больше проект, тем больше это становится проблемой.
Сейчас может этих проблем у JOOMLA нет, но раньше это было проблемой.

Много JS нужны при загрузке админки, которую обычный пользователь не увидит и ему не нужно подгружать эти скрипты.


26.4 ob_start обфусикация (01:05:00)
Функция ob_start() не дает обрабатывать сразу участок кода, а записывает его во временное хранилище, но вывод может
быть уже не на этой странице.
Функция ob_end_clean() закрывает запись во временное хранилище (буфер обмена)
Во временное хранилище может отправляться только вывод (echo, print_r), а к примеру header("Location: /") даже
если он размещен между этими функциями сработает.
Грубо говоря временное хранилище - это наша переменная.
Достаётся информация из нашей "переменной" (временного хранилища) при помощи функции ob_get_contents();

26.4.1 Пример использования (вывод текста):
ob_start();
    echo 'TEXT<br>';
    echo 'Text5<br>';
    $content = ob_get_contents(); //сюда записывается предыдущие две строчки

    echo 'TEXT3<br>';
    echo 'Text4<br>';
    $content2 = ob_get_contents(); //сюда записывается все, что выше этой функции - от начала ob_start();
ob_end_clean();

echo 'TEXT2'; //выведется раньше предыдущего блока, так как не попал в буфер обмена

echo '<br>'.$content2.'<br>'.$content; //вывод содержимого буфера обмена

26.4.2 Пример использования (перенос вывода сообщения об ошибке в другое место страницы)
Допустим у нас есть код, который выдаст ошибку, так как переменная не назначена:
if($var ==5) {
    echo 'text';
}

Теперь обернем это условие в функцию:
ob_start();
    if($var ==5) {
        echo 'text';
    }
    $content = ob_get_contents(); //запись об ошибке попадет в эту переменную
ob_end_clean();

echo '<div style="color:red">'.$content.'</div>';

26.4.3 ob_start() мы будем использовать для работы с контроллером, потому что он выполняется, обрабатывается еще до попадания на страницу.
В файле index.php в функцию помещаем наши инклюды и когда выдаст какое-то сообщение
не выведется выше index.tpl, а попадет в переменную:
ob_start();
include './modules/allpages.php';
include './modules/'.$_GET['module'].'/'.$_GET['page'].'.php';
$content = ob_get_contents();
ob_end_clean();
include './skins/'.Core::$SKIN.'/index.tpl';

Затем выводим эту переменную в одном из <div> в файле index.tpl:
<div id=content>
    <?php echo $content;
    include $_GET['module'].'/'.$_GET['page'].'.tpl';
    ?>
</div>
<?php
Но можно еще улучшить наш контролер и подключене include $_GET['module'].'/'.$_GET['page'].'.tpl'; пернести в index.php в блок функции ob_start(),
а в index.tpl оставим только наш вывод переменной: echo $content;
только добавляем к нему расположение от корня сайта:
// Роутер
ob_start();
include './modules/allpages.php';
include './modules/'.$_GET['module'].'/'.$_GET['page'].'.php';
include './skins/'.Core::$SKIN.'/'.$_GET['module'].'/'.$_GET['page'].'.tpl';
$content = ob_get_contents();
ob_end_clean();

include './skins/'.Core::$SKIN.'/index.tpl';


Урок 27: Создание админки, CMS (00:04:55)

27.1.1 Админка на техническом уровне называется CMS
CMS (англ. Content Management System) — это система управления контентом сайта. На профессиональном жаргоне
CMS ещё называют «движок сайта».
Управление подразумевает:
1) Создание данных (access = 2)
2) Редактирование данных (access = 2)
3) Отправка жалобы на контент (access = 2)
4) Сокрытие контента (access = 5)
3) Удаление данных (access = 5)

27.1.2 Фреймворки CMS - это наши модули (папка modules), которые имеют свои собственные библиотеки (папка libs)
На данный момент у нас на сайте есть фремворк, но отсутствует CMS. С CMS мы поработали, когда реализовали
в блоке новости - создание и редактирование новостей.

27.1.3 Назначение прав пользователям:
if(нажата кнопка && $_SESSION['user']['access'] == 2) {
    удаляем новость;
}

$res = q("запрос");
while($row = mysqli_fetch_assoc($res)) {
    echo 'Новость №'.$row['id'];
    if($_SESSION['user']['access'] == 2) {
        echo '<a>Удалить новость</a>';
    }
    echo $row['text'];
}
Кнопка 'Удалить' видна только тем, у кого есть права = 2

27.1.5 Хакеры могут удалять новости даже без кнопки удалить, просто прописав в адресной строке:
site.ua/index.php?action=delete&id=7
Вот поэтому и нужно выставлять права доступа к самому удалению, а не только скрывать кнопку "удалить"

27.2 Внешние и внутренние админки
27.2.1 Есть два варианта администрирования контента:
1) прямо на странице - скрыть, подредактировать или удалить контент
2) отдельный подсайт внутри нашего сайта, который является нашей админкой, со своим стилем, своими меню, навигацией
и расширенными функциями по управлению контентом на основном сайте.

27.2.2 Документация по админке (00:30:00)
Очень полезно где-то иметь небольшую документацию, где описывать работу модулей, которые мы создаем и описывать их
функционал. Это можно хранить на какой-то отдельной страничке. Собственно это касается не только CMS, к фреймворкам
так же можно хранить описание функционала. Описание функционала хорошо помагает тем, кто будет пользоваться нашей
админкой.
Для того, чтобы заказчику нравился ваш сайт, то по нему должна быть:
1) доступная документация;
2) человеко-понятный интерфейс.

27.3 Создаем админку
27.3.1 Создаем новые папки. (00:34:00)
Создаем в папке skins новую папку admin. Туда поместим index.tpl и какой-нибудь базовый модуль, с которым уже работали,
например новости. Создаем в ней же папки css. js. img. Для адинки будем делать отдельные стили css.
В папке modules создаем папку admin и в нее потом будем писать свои модули для работы. Создаем свой allpages.php
Чтобы этот шаблон подключался нам нужно подкорректировать ядро. Чтобы попасть в админку сайта стандартно после
названия сайта идет admin: agro2.ua/admin

27.3.2 Вносим изменения в variables.php (00:39:35)
//добавляем папку админки:
//ЧПУ
if(isset($_GET['route'])) {
    $temp = explode('/', $_GET['route']);
    //подключаем админку:
    if($temp[0] == 'admin') { //аналогично функции in_array($temp[0], array('admin', 'partners', 'advertisement', ...))
        Core::$SKIN = 'admin'; //заменяем папку default на admin
        Core::$CONT = 'modules/admin'; //заменяем папку modules на modules/admin
    unset($temp[0]); //удаляем за ненадобностью
}
//во второй части меняем переменные на счетчик $i:
    $i = 0;
    foreach ($temp as $k=>$v) {
        if($i == 0) {
            if(!empty($v)) {
                $_GET['module'] = $v;
            }
        } elseif($i == 1) {
            if(!empty($v)) {
            $_GET['page'] = $v;
        }
        } else {
            $_GET['key'.($k-1)] = $v;
        }
        ++$i;
    }
    unset($_GET['route']);
}

27.3.3 Вносим изменения в config.php (00:51:00)
//Добавляем:
static $CONT       = 'modules';

27.3.4 Вносим изменения в index.php
//Инклюды с путями через папку 'modules'
include './modules/allpages.php';
//меняем на:
include './'.Core::$CONT.'/allpages.php';
include './'.Core::$CONT.'/'.$_GET['module'].'/'.$_GET['page'].'.php';


27.4 Работа с новостями/товарами (01:05:00)
Основные возможности: //админка
1. Создавать /admin/news/create (create.php + create.tpl), т.е. /admin/$_GET['module']/$_GET['page']/
2. Редактировать //дальше по аналогии с созданием
3. Удалять
Дополнительные возможности: //доступно для всех пользователей
1. Вывод всех новостей
2. Страница конкретной новости, читать подробнее (WHERE `id` = $_GET['id'])

27.5 Домашняя работа (01:09:50):
1. Сделать нашу админку
2. Функционал новостей и товаров, который мы раньше делали поместить в админку
3. Проверить на защищенность от SQL инъекций
4. Оформить стиль админки (admin/index.tpl + css):
    1) поместить логотип слева вверху
    2) справа приветствие администратора, ссылка перехода на сайт
    3) навигацию (главная, товары, новости, отзывы, пользователи)
    4) контент из навигации, на примере пользователи "Список пользователей":
        а) название вкладки, кнопки: фильтр, сбросить фильтр, создлать пользователя, удалить пользователя
        б) панель вывода пользователей:
            *) название столбца (пустой - чекбокс, id, e-mail, login, age
            *)  дальше строчки с БД
    5) футер(Copyright@ronam.nikolaevich 2022, Документация)

27.6 Дополнение к уроку по админке (27b 00:00:30)
27.6.1 .htaccess:
удаляем: RewriteCond %{REQUEST_URI} !^/admin

27.6.2 variables.php
добавляем исключение, чтобы массив $allowed не обрабатывался в админке:
if(Core::$SKIN != 'admin') {
    $allowed = array('static',...
} else {
    if(!isset($_GET['module'])) {
        $_GET['module'] = 'static';
    }
}

или более лаконично:
if(Core::$SKIN != 'admin') {
    $allowed = array('static', 'auth', 'comments', 'contacts', 'errors', 'game', 'goods', 'news','partners',
    'services', 'voting');

if(!isset($_GET['module'])) {
    $_GET['module'] = 'static';
        } elseif(!in_array($_GET['module'],$allowed) && Core::$SKIN != 'admin') {
            header("Location: /errors/404");
        exit();
    }
}

27.6.3 Посмотреть как сделаны админки у imagecms.net, битрикс или аналогичных конкурентов

27.6.4 Вход а админку/авторизация (27b 00:07:30)
/admin/login
Название, логин, пароль, чекбокс "Запомнить", кнопка "Вход в систему", ссылка "Забыли пароль?"
//Минимум стиля.
Реализация - admin/static/main.php

27.6.5 Внешний вид админки (index.php и tpl)
//если пользователя нет в сессии (неавторизирован) или есть но нет прав - в index.tpl через права
//доступа скрываем страницу (навигацию, дивы и футер):
if(!isset($_SESSION['user']) || $_SESSION['user']['access'] != 5) {...

27.6.6 skins/admin/static/main.tpl - главная страница админки
сюда можно подключить страничку авторизации из шаблона default, где у нас эта авторизация уже есть:
if(!isset($_SESSION['user']) || $_SESSION['user']['access'] != 5) {
    include './skins/default/auth/login.tpl';
}

27.6.7 modules/admin/static/main.php
if(!isset($_SESSION['user']) || $_SESSION['user']['access'] != 5) {
    include './modules/auth/login.php';
}

27.6.8 modules/admin/allpages.php
Разграничиваем права, что если у нас прав нет и если гет модуль не= статик или ...:
if(!isset($_SESSION['user']) || $_SESSION['user']['access'] != 2) {
    if($_GET['module'] != 'static' || $_GET['page'] != 'main') {
        header("Location: /admin/static/main"); //переадресация на авторизацию
        exit();
    }
}
Можно изменить первую строчку, чтобы разделить функционал: если нет сессии вообще, то редирект
допустит пройти авторизацию, а если пользователь авторизованый, но у него нет прав, то сразу
отправлять на главную страницу или выводить сообщение "у вас нет прав для этого".

27.6.9 variables.php
//Обрезаем пост - проверить потом как работает
if(isset($_POST)) {
    $_POST =trimAll($_POST);
}

Урок 28: Регулярные выражения (2022-06-14)
/*План:
Регулярные выражения
Регулярки*/
Дополнение к уроку:
Таблица подсказок по регулярным выражениям:
https://www.exlab.net/files/tools/sheets/regexp/regexp.png

28.1
28.1.1. Числа:
$x = 10;
$y = 5;
echo $x + $y;
$res = $y/$x; //0.5
echo round($res); //1,
is_numeric()

Массивами: ... count(); array_sum;

Работа со строками:
mb_strlen('abc');//3
str_replace('Вас', 'Пет', 'Пети любит ананасы'); //'Васи любит ананасы'

preg_replace ()//аналог функции str_replace
preg_replace('паттерн', 'на что мы меняем', 'входящая строка')

'Вас' - окончание одно из следующих: я, и, ю   //эта строка называется "паттерн"
'Пет' + окончание // на что меняем
Вася -> Петя
Васи -> Пети
Васю -> Петю


28.1.2 Когда мы говороим о php, то мы говорим о том, что php нам готовим и выдает уже статичную, обычную html
страницу. Для того чтобы произошло какое-нибудь изменение на странице нам необходимо перезагрузить страницу.
Для того чтобы не перезагружать страницу нам необходимо использовать Java-Script

28.1.3 Регулярные выражения (00:16:10) используются для того, чтобы делать какие-то визуальные изменения в готовых
строках, кроме этого позволяет очень хорошо работать с html структурой. Но к этому мы перейдем позже, пока нам нужно
понять логику.

28.1.4 Функции: (00:18:20)
1) preg_replace - находит значение и сразу делает замену
2) preg_match - находит значение, ищет совпадение
3) preg_match_all - ищет все совпадения, возвращает результатом все что нашло

//Исходный текст для поиска:
"Пети любит ананасы"
//Задание найти все слова, в которых количество символов меньше 6:
preg_match <- Пети //выведет только первое попавшее соответствующее нашему условию
preg_match_all <- array('Пети', 'любит') //найдет все подходящие результаты
//Совпадения ищутся по патерну (поисковому фильтру, шаблону)

28.2.1 Структура паттерна:
$pattern = '#шаблон, по которому идет поиск#свойства данного поиска (модификаторы)'; //пишется как строка в кавычках
В паттерн вносят условия (правила) и свойства. А для разделения их между собой можно использовать абсолютно любые
символы какие взбредет в голову, можно использовать решетку, палочку вертикальную, слеш или лямбду. Но в учебниках
используют решетку.

28.2.2 Свойства паттерна (модификаторы)- это перечисление определенных параметров:
u - означает, что наша строка находится в кодировке UTF-8 (ставим всегда, кроме работы с англ раскладкой или цифрами)
i - регистронезависимый текст (ставим кроме случаев когда нужно найти определенные большие или маленькие буквы)
s - \s принимает не только пробелы, но и табуляцию и переносы строк(не обязательный параметр - сейчас и без него ищет).
U - отмена жадного поиска (жадный поиск - это когда мы задаем интервал для поиска от 2 до 6 символов, то сначал ищет
6 символов, если не нашло, то 5, и так далее)
... - есть и другие свойства
Можно указать одно свойство (тогда будет одна буква), можно несколько (тогда пишем все буквы свойств слитно без
знаков припинания, причем в любой последовательности, без разницы)

28.2.3 preg_replace (00:32:53)
$pattern = '#петя#ui'; //петя - маленькими буквами, но благодаря 'i' заменит и с большой буквой
$text = 'Вася любит ананасы, Петя любит кораблики. Аня самая лучшая. А на юге живут папуасы';
$replace_word = 'ЗАМЕНА';
echo $text.'<br><hr>';
$text = preg_replace($pattern, $replace_word, $text);
echo $text;

28.2.4 Правила паттерна (00:36:20)
Внутри нашего шаблона мы указываем определенные правила:
[] - перечисляем какой из символов может находиться тут:
$pattern = '#пет[яюи]#ui'; //Пети заменит, а Пете - нет
$pattern = '#пет[^в]#ui'; //отрицание - замена любого слова, начинающегося на 'пет' кроме слова 'петв'

Специальные символы нужно использовать вместе с наклонной чертой влево - экранирование:
'\#\/'

Диапазон (перечисление):
а-я //в шаблон попадут все буквы от а до я, за исключением буквы ё
а-яё //в шаблон попадут все буквы от а до я, включая ё (такая особенность русского языка)
а-Я // от а до Я включая большие и маленькие буквы или если указываем 'i', то можно писать просто а-я
a-z // от a до z
0-9 // от 0 до 9, причем 10 не пишем, так как это 1 и 0

28.2.5 preg_match (00:49:50)
С этой функцией замены тут нет, поэтому задаем, что мы ищем и в какой строке
$text = preg_match($pattern, $text); //вернет на экран 0 (нет совпадений) или 1 (одно совпадение)
Чтобы посмотреть найденные совпадения добавляем параметр $matches, который возвращается в виде массива.
$count = preg_match($pattern, $text, $matches);
//посмотрим, что у нас вывелось:
echo '<pre>'.print_r($matches, 1);

Это нужно не только, чтобы находить замену, но и чтобы находить строки и потом с ними работать.

28.2.6 preg_match_all (00:55:38)
1)//Допустим мы хотим найти все буквы "б" в тексте :
$pattern = '#б#ui';
$text = 'АааааааабббвввгггггдеЖ';
echo $text.'<br><hr>';
$count = preg_match_all($pattern, $text, $matches);
echo '<pre>'.print_r($matches, 1);
//получим вывод:
Array
(
    [0] => Array
        (
            [0] => б
            [1] => б
            [2] => б
        )

)

2)//Можно разнообразить и задать вывод всех букв от а до в:
$pattern = '#[а-в]#ui';
//получим массив:
Array
(
    [0] => Array
        (
            [0] => А
            [1] => а
            [2] => а
            [3] => а
            [4] => а
            [5] => а
            [6] => а
            [7] => а
            [8] => б
            [9] => б
            [10] => б
            [11] => в
            [12] => в
            [13] => в
        )

)
3)//Если вывести переменную полученную в результате функции, то получим число:
echo $count; //14

4) Если нам необходимо найти случайную букву от 'а' до 'в', после нее - случайная буква от 'в' до 'г'
$pattern = '#[а-в][в-г]#ui';
//получаем в выводе:
Array
(
    [0] => Array
        (
            [0] => бв
            [1] => вв
    )

)
5) Если добавить в паттерн букву 'я', которой нет в $text, то получим пустой массив на выходе:
$pattern = '#я[а-в][в-г]#ui';
echo $count; //0

28.3 Дополнительные символы: (01:01:10)
28.3.1 ^ - Поиск от начала строки, ставится сразу после решетки:
$text = 'АввгдеЖ';
$pattern = '#^[а-е][в-я]#ui';
echo $text.'<br><hr>' //АввгдеЖ
$count = preg_match_all($pattern, $text, $matches);
echo '<pre>'.print_r($matches, 1); // Array ([0] => Array ([0] => Ав))

28.3.2 $ - конец строки (01:06:35
$pattern = '#[а-е][в-г]$#ui'; //ничего не найдет
//Ноль возвращает если наша строка не удовлетворяет определенному шаблону, если удовлетворяет - вернется 1
$pattern = '#[а-е][в-я]$#ui'; // Array ([0] => Array ([0] => еЖ))
//Так от начала и до конца не может быть несколко строк, потому что в начале начинается только один символ, всегда
// одинаковый, то есть логично предположить, что нам preg_match_all не нужен и достаточно preg_match до первого
//совпадения
$count = preg_match($pattern, $text, $matches);
//Мы ищем от начала и до конца и говорим, что наша строка находится в центре и она состоит из двух символов:
//[а-е] - 1й  и [в-я] - 2-й. Из-за того что наша строка $text = 'АввгдеЖ' не совпадает с указанной, то в $count
//вернется число ноль.
//Для того чтобы наша строка нашлась мы можем некоторые условия прописать:
$text = 'АввгдеЖ';
$pattern = '#^а[а-я][а-я][а-я][а-я]еЖ$#ui';
echo $text.'<br><hr>';
$count = preg_match($pattern, $text, $matches);
echo '<pre>'.print_r($matches, 1).'<hr>'.$count;//Array([0] => Array([0] => АввгдеЖ)) - соотвествует $text
//$count выведется 1
//Теперь мы можем элементарно сделать вот так:
if(preg_match($pattern, $text, $matches)){//мы исполозовали функцию без _all, так как нам нужно только 1-е совпадение
    echo "МЫ НАШЛИ";// в нашем случае эта надпись выведется
} else {
    echo 'Беда'; //если $text подредактировать, то выведется эта надпись
}
Это пример, когда мы ищем полное совпадение строки нашему шаблону.

И еще один момент - когда мы ищем четкое совпадение от начала до конца по какому-то шаблону, то нам $matches может
вообще не пригодиться, поэтому можно его не использовать ($matches - позволяет посмотреть найденные совпадения) :
$count = preg_match($pattern, $text);

28.3.3 {} - Повторения (01:14:32)
В примере выше мы указали 4 символа и каждый раз их пришлось дублировать для того чтобы ... есть определенное
правило, которое говорится, что оно будет повторяться несколько символов подряд. В таком случае мы можем
указать количество символов для вот этого правила
[а-я] - 4 символа
Повторения используются в виде фигурных скобок:
[а-я] {4}

С помощью повторений слово "Вася" можно передать так:
В{1}а{1}с{1}я{1}// повторение каждого символа по 1 разу
Чтобы не прописывать после каждой буквы {1} принято считать, что если только 1 символ, то {1} можно неписать.

Если мы не значем сколько будет символов, то мы ставим так: {1,2} //не через дефис, а через запятую, где первая цифра
//означает минимальное количество совпадений, а вторая - максимальное {min, max}.
Вас[а-яё]{0,2} - 0 означает, что окончание может быть, а может и не быть.
Вас[а-яё]{0, } - если максимальное количество повторений не известно и стремится к бесконечности, то оставляем пустым.

28.3.4 Сокращения количества: (01:23:10)
{0, }  заменяется символом * //Вас[а-яё]*
{1, }  заменяется символом + //Вас[а-яё]+
{1}    если нужен только один символ, то ничего не указываем.// Вас[а-яё]
{0, 1}  заменяется символом ? //Вася? - допустимо Вас или Вася

28.3.5 Рассмотрим строку: (01:26:00)
//Ищем в тексте все слова, где есть буква "П" и после этой буквы произвольное количество символов от а до яё от нуля
//до бесконечности:
$text = 'Вася любит ананасы, Петя любит кораблики. Пёсик самый лучший. А на юге живут папуасы';
$pattern = '#П[а-яё]*$#ui';
echo $text.'<br><hr>';
$count = preg_match_all($pattern, $text, $matches);// используем _all, так как будем искать все совпадения.
echo '<pre>'.print_r($matches, 1).'<hr>'.$count; //[0] => папуасы // 1
//Нужно учесть, что пробелы мы в этот диапазон не включаем, мы берем только символы до пробелов, точка и запятая так
//же нее будут браться во внимание. Добавим $, этим находим все эти совпадения, но что в конце строки находятся.

Если начнем искать букву "А" с начала строки, то выдаст не только полноценные слова, но и части слов:
$pattern = '#А[а-яё]*#ui';
Array
(
    [0] => Array
        (
            [0] => ася
            [1] => ананасы
            [2] => аблики
            [3] => амый
            [4] => ая
            [5] => А
            [6] => а
            [7] => апуасы
        )
)
8 //количество совпадений

Чтобы вывести полные слова можно прописать патерн в таком формате:
$pattern = '#[а-яё]*А[а-яё]*#ui';
...
            [0] => Вася
            [1] => ананасы
            [2] => кораблики
            [3] => самый
            [4] => лучшая
            [5] => А
            [6] => на
            [7] => папуасы
...
8//количество совпадений

Если в патерне указать, что первым символом перед "А" должна содержиться какая-то буква (меняем * на +), то в
выводе [5] => А уже не появится, так как перед ней нет букв и в итоге будет 7 только результатов.
$pattern = '#[а-яё]+А[а-яё]*#ui';

Если место + поставить интервал от 2 до 6 {2,6}, то выведется еще меньше:
$pattern = '#[а-яё]{2,6}А[а-яё]*#ui';
...
            [0] => ананасы //тут перед второй буквой "а" 2 символа
            [1] => кораблики //тут перед буквой "а" 3 символа
            [2] => лучшая //тут перед буквой "а" 4 символа
            [3] => папуасы //тут перед второй буквой "а" 4 символа
...
4//количество совпадений

28.3.6 Дополнительные сокращения: (01:34:10)
\s - Пробельный символ - пробел + табуляция + перенос строки(\f\n\r\t\v),
\t - табуляция,
\n, \r - перенос строки,

Пример жадного поиска (максимум 100 ставим) и пробела [а-яё ]:
$pattern = '#[а-яё ]{2,100}А[а-яё]*#ui';
...
            [0] => Вася любит ананасы
            [1] =>  Петя любит кораблики
            [2] =>  Пёсик самый лучшая
            [3] =>  А на юге живут папуасы
...
Ищет максимально возможные регулярки.

Если ограничить жадность (U):
$pattern = '#[а-яё ]{2,100}А[а-яё]*#uiU';
...
            [0] => Вася любит а
            [1] => нана
            [2] =>  Петя любит кора
            [3] =>  Пёсик са
            [4] => мый лучша
            [5] =>  А на
            [6] =>  юге живут па
            [7] => пуа
...

Но просто ставить пробел не лучший вариант, поэтому мы используем спецсимвол (\s):
$text = 'Вася                       любит ананасы, Петя любит кораблики. Пёсик самый лучший. А на юге живут папуасы';
$pattern = '#Вася\s+[а-яё]+#ui';
...
            [0] => Вася                       любит
...

Если в строчке $text , кроме пробелов еще будут и табуляция и перенос строки, то в поиске все равно найдет и выдаст
с переносом строки
...
            [0] => Вася
            любит
...
Хотя раньше, чтобы перенос строки и табуляция находилась, то в свойствах регулярного выражения нужно было дабвалять "s"


28.3.7 . - абсолютно любой символ! (01:43:55):
А если мы хотим просто передать точку для поиска, то ее нужно экранировать \.
$pattern = '#В.{3}#ui'; //Буква "В" и 3 любых символа после нее включая пробелы.
...
[0] => Вася
[1] => вут //тут 4-й символ пробел
...

28.3.8 Обычные скобки () (01:51:40):
Если нам нужно повторить 1 символ 10 раз мы пишем:
а{10}

Если нам нужно повторить случайный символ 5 раз мы пишем:
[а-я]{5}

Если мы хотим, чтобы какое-то слово повторялось 3 раза, то мы его берем в скобки:
(Стас){3}
СтасСтасСтас - верно
СтасСтасАндрей - не верно

https://ru.wikipedia.org/wiki/Регулярные_выражения

28.4 Вторая часть по регулярным выражениям(28b 00:04:00)
28.4.1 Краткое повторение прошлого урока по регелярным выражениям (28b 00:04:00)

28.4.2 Сокращение заменители(28b 00:21:55)
Сокращения используются, чтобы писать как можно меньше кода + удобство визуального восприятия
\d - числа // [0-9]
\s - любой символ отступа // \f\n\r\t\v
\w - буквы // [-A-ZА-Я_] (в википедии: "Буквенный или цифровой символ или знак подчёркивания; буквы ограничены латиницей")

[] - в квадратных скобках указывается диапазон
{} - в фигурных - количество повторений

Выражение:  [0-9]{1,}
можно заменить на: \d+

Диапазон все цифры и буквы  от 'а' до 'я' + повторения от нуля до бесконечности: [\dа-я]*

28.4.4 знак . - любые символы: (28b 00:25:35)
$text = 'Вася любит ананасы, Петя любит кораблик. Пёсик самый лучший. А на юге живут папуасы';
$pattern = '#кораблик.{13}#ui';
$count = preg_match_all($pattern, $text, $matches);// [0] => кораблик. Пёсик самый
echo '<pre>'.print_r($matches, 1).'<hr>'.$count; //1

28.4.3 знак | - или (28b 00:26:15)
Если допустить, что кто-то может ошибиться и вместо "кораблик" напишет "караблик", то такое слово в выборку не попадет.
Для этого используем знак "|":
$pattern = '#к(а|о)раблик.{13}#ui';
(а|о) можно так же заменить через диапазон [ао]:
$pattern = '#к[ао]раблик.{13}#ui';

Но знак "|" дает нам больше возможностей. После знака "|" не обязательно должна быть только одна буква, может
использоваться очень длинный паттерн. Так например:
$pattern = '#к(а[0-9]{3}.?\<b\>|о)раблик.{13}#ui';// после а устанавливаем диапазон от 0 до 9, который повторяется
//3 раза, затем идет любой символ ".", который может быть, а может и не быть "?", затем идет знак меньше "<" затем
//буква "b", затем знак больше ">". В итоге будет выводить поиск либо с левой частью либо с правой.
Знак "|" создает еще один массив. Но об этом чуть позже.
Array
    (
    [0] => Array
        (
            [0] => кораблик. Пёсик самый
        )

    [1] => Array
        (
            [0] => о
        )

)

28.4.4 знак | - или в числах от 0 до 100
Знак "|" применяется в том случае, когда мы хотим какую-то запись , допустим у нас есть форма от 0 до 100.
Мы не можем сделать патерн: [0-9]{3} , так как он выдаст 000-999, а это нам не подходит
Если бы нам нужно было искать от 0 до 99, то можно было бы написать: [0-9]{1,2}
А нам нужен вариант с 100. Именно тут нам может помочь знак "|"
$pattern = '#^([0-9]{1,2})$#'; //эта регулярка найдет числа от 0 до 99
$pattern = '#^([0-9]{1,2}|100)$#'; //эта регулярка найдет числа от 0 до 100

28.4.5 знак | - или для IP адресов (28b 00:31:55)
Диапазон IP адресов от 0.0.0.0 до 255.255.255.255
Диапазон 0-255 мы можем логически объясни так:
0-99 | 100-199 | 2 (00-49 | 50-55)
и записать так:
[0-9]{1,2} | 1[0-9]{1,2} | 2([0-4][0-9] | 5[0-5])

функцией это можно было бы записать так:
$i==255;
if($i>=0 && $i<=255) {...}

итого диапазон от 0.0.0.0 до 255.255.255.255 мы могли бы записать так:
[0-9]{1,2}|1[0-9]{1,2}|2([0-4][0-9]|5[0-5])\.[0-9]{1,2}|1[0-9]{1,2}|2([0-4][0-9]|5[0-5])\.
[0-9]{1,2}|1[0-9]{1,2}|2([0-4][0-9]|5[0-5])\.[0-9]{1,2}|1[0-9]{1,2}|2([0-4][0-9]|5[0-5])


$text = '10.211.244.2';
$pattern = '#кораблик.{13}#ui';

28.5 Функция preg_quote (28b 00:40:00) - Экранирует символы в регулярных выражениях
$x = preg_quote('#~"/'); //передает в переменную экранированные символы, добавляя слешы \

Эту функцию удобно применять, когда у нас есть html код, в котором нужно было бы прописывать экрование каждого html
символа:
$code = preg_quote('<script src="/skins/js/fw.min.js?v6"></script>');
$code = preg_replace('#[0-9]{2}'.$code.'[а-я]+#iu');
echo $code;

28.6 Кармашки () (28b 00:47:40)
28.6.1 Используем кармашки для поиска
$text = 'Вася любит ананасы, Петя любит кораблик. Пёсик самый лучший. А на юге живут папуасы';
$count = preg_match_all($pattern, $text, $matches);
Допустим нам нужно получить первое слово, которое находится в предложении, поэтому стаим "^", бесконечное количество
букв и оно закончится проблелом "\s":
$pattern = '#^[а-яё]+\s#ui'; // Вася

Мы можем посмотреть так же найти второе слово:
$pattern = '#^[а-яё]+\s\w+\s#ui'; //Вася любит

Допустим нам нужно найти слово перед словом 'ананасы':
$pattern = '#\w+\sананасы#ui'; //любит ананасы

Допустим нам нужно найти слово "любит", но не выводить на экран слово "ананасы":
можно это реализовать удалив это слово из полученного результата при помощи функции str_replace('ананасы'), но
нам бы это могло не подойти, если бы слово "ананасы" встречалось перед "ананасы", а нам необходимо было бы получить
конкретно это слово. Для этого как раз и были созданы "кармашки" "()" - это то что мы хотим найти и заключается
в скобки:
$pattern = '#(\w+)\sананасы#ui'; //в массив с ключом "1" выведет "любит"
Array
(
    [0] => Array
        (
            [0] => любит ананасы
        )

    [1] => Array
        (
            [0] => любит
        )

)
Если нам дальше нужно будет вывести слово "любит", то нужно будет написать:
echo $matches[1][0]; //любит

Кармашков может быть несколько, допустим нам нужно вывести и слово "ананасы", тогда мы берем в кармашек слово
"ананасы" и тогда появляется третий массив [2][0] //ананасы:
$pattern = '#(\w+)\s(ананасы)#ui';

Первый массив[0][0] - это вся поисковая строка, а дальше - это кармашки, отдельные массивы.

28.6.2 Используем кармашки для замены:
$text = 'Вася любит ананасы, Петя любит кораблик. Пёсик самый лучший. А на юге живут папуасы';
$pattern = '#(\w+)\s(ананасы)#ui';//любит ананасы
$count = preg_replace($pattern, 'LALALALALA', $text);
echo $count; //Вася LALALALALA, Петя любит кораблик. Пёсик самый лучший. А на юге живут папуасы

К каждому кармашку можно обратиться используя две обратные косые черты и номер кармашка:
\\0
\\1
\\2

Это можно использовать для замены найденной строки на саму себя:
$count = preg_replace($pattern, '\\0', $text);
echo $count; //Вася любит ананасы, Петя любит кораблик. Пёсик самый лучший. А на юге живут папуасы

Как использовать? Мы можем перед найденной строкой добавить тег <b> и после нее </b>:
$count = preg_replace($pattern, '<b>\\0</b>', $text); //вместо 0 можно так же использовать 1 или 2
echo $count;// ... любит ананасы (выделилось жирным)...

Где это может понадобиться? Например результате в поиске google наши искомые слова будут выделены жирным тектом.
Так же можно сделать и с поиском у нас на сайте.

Добавление какого-нибудь символа (например "=") между найденными словами:
$pattern = '#(\w+)\s(ананасы)#ui';
$count = preg_replace($pattern, '<b>\\1=\\2</b>', $text); //вместо 0 можно так же использовать 1 или 2
echo $count;//

28.7 U - модификатор отмена жадного поиска (28b 01:16:20) (28c 00:00:00)
$text = '<b>Вася</b> любит ананасы, Петя любит <b>кораблик</b>. Пёсик самый лучший. <b>А на юге</b> живут папуасы';
$pattern = '#'.preg_quote('<b>').'.*'.preg_quote('</b>').'#ui';
$count = preg_match_all($pattern, $text, $matches);
echo '<pre>'.print_r($matches, 1).'<hr>'.$count; //выведет $text со всеми выделенными жирным словами

Если добавить модификатор U, то все слова вместе с жирными выводиться не будут, а выведутся в виде массива слова
отмеченные жирным:
$pattern = '#'.preg_quote('<b>').'.*'.preg_quote('</b>').'#uiU';
Array
(
    [0] => Array
        (
            [0] => Вася
            [1] => кораблик
            [2] => А на юге
        )
)
3//кол-во совпадений

Рассмотрим на примере поиска слов от начала от 5 до 15 символов. Жадный поиск выдаст все 15 символов:
$pattern = '#^.[5,15]#ui'; //Вася любит анан
Отмена жадного поиска - U - выдаст только первые 5:
$pattern = '#^.[5,15]#uiU'; //Вася

Жадный и не жадный поиск применяется, когда мы парсим("производить анализ, анализировать, разбирать") какую-то
страничку, какой-то сайт. Нажимаем "Просмотр кода страницы". Находим <div class="menu"> с каким-небудь классом
и видим его содержание, если мы будем использовать не жадный поиск (U), то он найдет первый закрывающийся тег
</div> и это все возьмется, вся менюшка, лишнего ничего бы не бралось. Если бы мы использовали жадный поиск
(без U), то оскало бы до самого конца кода, до последнего закрывающегося </div>
$pattern = '#^<div class="menu">(.*)</div>#ui';//до последнего </div> в коде
$pattern = '#^<div class="menu">(.*)</div>#uiU';//до первого </div> в коде
Этот код так же нужно экранировать и потому он будет выглядеть так:
$pattern = '#^'.preg_quote('<div class="menu">').'(.*)'.preg_quote('</div>').'#uiU';

28.8 Проверка логина (28c 00:08:30)(28d 00:00:00)
У нас регистрируется пользователь, вводит логин.
Дальше мы хотим проверить, точно ли он совпадает допустимым значениям - используем preg_match без _all, задаем поиск
с начала и до конца, ограничиваем длинну логина от 3 до 18 символов, устанавливаем, что символы берем только буквы
кириллица + буква 'ё' и латиница, символ пробела
$pattern = '#^[\wё\s]{3,18}$#ui';
$text = 'Вася Пупкин'; //корректный логин
$text = 'Вася Пуп!!!'; //некорректный логин из-за !!!
//$text = trim($text); //удаляем пробелы в начале и конце логина
Если пробелы в начале и конце логина на что-то влияют, то делаем проверку:
if(trim($text) != $text) {
    echo 'Не ставьте пробелы в начале или конце строки!';
} else {
    if($preg_match($pattern, $text)) {
        echo 'корректный логин';
    } else {
        echo 'некорректный логин';
    }
}

28.9 Домашняя работа (28d 00:07:30)


Урок 29: Углубляемся в MySQL (2022-06-24)
/*План:
Типы данных
Движки таблиц
Индексы*/

29.1. Типы данных (00:04:00)
29.1.1 Тип: INT
'id'
Тип: INT
Индекс: PRIMARY
AI: ставим галочку.

29.1.2 Тип: TIMESTAMP
'date'
Тип: TIMESTAMP
По умолчанию: CURRENT_TIMESTAMP
Атрибуты: on update CURRENT_TIMESTAMP
Теперь нам не придется каждый раз указывать свою дату, по умолчанию ставится сегодняшняя дата и время.
Так же эти настройки после внесения правок в таблице (новость или другое) меняют и дату и время на текущее.
Но вручную можно по дредактировать и поставить нужную.

29.1.3 Тип BOOLEAN
Типа boolean не существует в MySQli, тут это обозначает:
BOOLEAN = true/false
Это тоже самое, что TINYINT(с длинной 1) которая принимает значение 0 либо 1.

29.1.4 Тип ENUM
Имя: sex (пол) / country (страна)
Страна - экономим на месте
Вместо того, чтобы вносить в БД полное название страны можно записывать цифровой код, который занимает намного меньше
места + быстрее обрабатывается.
Нам нужно один раз создать массив:
$array = array(
    0=>'Украина';
    1=>'росия';
    2=>'белорусь';
);
echo $country[2]; //белорусь
Поэтому нам в БД нужно хранить цифры, 0, 1, 2, ..., которые будут преобразовываться в полноценный вид.

Аналогично с полом - можно писать мужчина, но в БД записывать 1 или 0

Тип ENUM - это массив, который будет представлять собой допустимые варианты для данного поля.
Нажать нужно: "Редагувати значення ENUM/SET"
По умолчанию: "Мужчина"

29.1.5 Тип SET (00:35:00)
Это тот же ENUM, за исключением того, что одно поле может содержать несколько значений

29.1.6 "По умолчанию": NULL (00:36:20)
NULL - это пустое значение.
Но NULL И пустота - это не одинаковая вещь. NULL != '' в MySQL. Это вроде бы синонемы, но по логике MySQL все пустые
значения должны быть NULL.
NULL в "по умолчанию" и в "структура" лучше не использовать.

29.1.7 "Сравнение" (00:40:30) - это наша кодировка.
Несмотря на то, что мы работаем в UTF-8 у нас б ольшой выбор других кодировок. По умолчанию считается, что нужно
использовать utf_general_ci либо utf_unicode_ci.
Разные кодировки даже одной группы имеют разное окончание _bin и _ci:
_ci - это регистроНЕзависимый поиск значений ('inpost' == 'INPOST')
_bin - это регистрозависимый поиск значений ('inpost' != 'INPOST')
Это нужно учитывать при выборе кодировки для логина (лучше _ci) и пароля(_bin).
пароль в _ci: korol
пароль в _bin: Korol, kOrol, koRol, korOl, koroL, KoroL, KoRoL, ...

29.1.8 "Атрибуты": UNSIGNED (00:40:30)
Например:
TINYINT(1байт) - имеет от -128 до 127 вариантов. Но что делать если нам нужны только положительные числа?
По умолчанию - используются и положительные и отрицательные числа (от -128 до  127).
UNSIGNED - указывает использовать только положительные числа (например использование для 'id') (от 0 до 255)

SMALLINT  (2байта) от -32 768	до 32 767 (всего 65 535)
MEDIUMINT (3байта) от -8 388 608	до	8 388 607	(всего 16 777 215)
INT       (4байта) от -2 147 483 648	до	2 147 483 647	(всего 4 294 967 295)
BIGINT    (8байта) от -2в63степени	до	2в63степени-1	(всего 2в64степени-1)

29.1.9 Разбитие таблицы на несколько частей (PARTITION) (01:04:30)
Допустим у нас есть таблица с 1 млрд пользователей. Сканировать такую таблицу невероятно долго. Поэтому для ускорения
такую таблицу разбивают на несколько меньших таблиц.
1-я от 1 до 10 000 000 (id)
2-я от 10 000 001 до  20 000 000 (id)
и так далее.
Можно вместо таблицы 'users' создаются таблицы 'users1', 'users2', 'users3', 'users4'..., но это не правильно.
Правильно внутри таблицы 'users' сделать разбитие на блоки 'users1', 'users2', 'users3', 'users4'...
Строчка PARTITION находится внизу таблицы.

29.2 Типы таблиц (01:09:30)
29.2.1 Таблицы делятся на типы:
1) InnoDB - БЫСТРЫЙ SELECT (в ущерб INDERT, UPDATE, DELETE);
2) MyISAM - БЫСТРЫЙ INDERT, UPDATE, DELETE (в ущерб SELECT - выбору самый низкий приоритет в исполнении);
3) MRG_MYISAM - редкое применение, рассматривать не будем
4) CSV - редкое применение, рассматривать не будем
5) MEMORY - таблица "создана внутри оперативной памяти" - при перезагрузке сервера все данные из таблицы очищаются
подходит для хранения сессий
6) ARCHIVE - редкое применение, рассматривать не будем
7) BLACKHOLE - означает, что таблица всегда пустая, в нее отправляться данные будут, но она их хранить не будет.

В нашем проекте чаще используется SELECT, поэтому для нашего проекта больше подходит 1-й тип.

29.2.2 Блокирование таблиц: (01:17:30)
При попытке какие-то данные вставить или удалить есть такое понятие в MySQL - блокирование таблицы. Мы делаем
какое-то запрос, который одновременно требует запрос ко второй таблице:
ТАБЛИЦА1=>ТАБЛИЦА2=>ТАБЛИЦА3
При обращении к таблице, если мы хотим где-то какой-то момент из данной таблицы, из таблицы2, в одном скрипте мы
делаем связь, обращаемся ко всем трем таблицам. При этом в свою очередь в момент, когда мы обратились к какой-то
из таблиц SELECT  и в этот момент другой скрипт из таблицы2 DELETE удаляет какие-то записи, то в движке MyISAM
выборка будет ждать до того момента, пока не удалится эта запись. MyISAM блокирует всю таблицу, а в это время
InnoDB блокирует только одну конкретную запись, что очень благоприятно сказывается на работе всего сайта.
//Например:
Удалить запись №9,
Выбираем запись №5
В MyISAM эти команды будут обрабатываться по очереди, а в InnoDB они будут идти параллельно.

При создании бэкапов в MyISAM нельзя пользоваться таблицей, а в InnoDB можно :)
Обычно бэкап таблицы размером 10Гб занимает от 5 до 10 минут.

Поэтому рекомендуют сайты делать на InnoDB. MyISAM используют для сбора статистик и подобного.

29.3 Индексы (01:35:00)
29.3.1 Основы.
Индексы в БД - это то же самое, что оглавления в книгах - помогают быстрее сориентироваться и найти нужный текст.
В книжках бывает, что в конце пишут ключевые слова и на какой странице они находятся. Благодаря таким ссылкам можно
более точно найти текст. Так же в книгах используют закладки. Все это можно в MySQL назвать как индексы.
Если для какой-то фразы нет закладки, то чтобы найти ее в тексте, то придется перечитывать весь текст с начала.
Эти закладки так же увеличивают объем книги. И вот этот баланс нужно соблюдать - между количеством закладок (скоростью
работы) и увеличением работы БД для текста без закладок.

Есть некоторые данные, которые часто используются, но не нуждаются в закладках. У нас в проекте это поле 'access'.
Мы его по тексту часто используем в виде проверки на access ==5 , но к БД не обращаемся, а сверяемся с сессией:
if(isset($_SESSION['user']['access'] && $_SESSION['user']['access']==5 )) {...}

Чем больше закладок мы создадим, тем хуже будет работать наш сайт.

А вот по логину мы делаем запрос, для него нужно создавать закладку.

Закладка действует таким образом: сначала находит первую букву, отбрасывает не подходящие варинты, затем вторую, опять
же отбрасывает то, что не вошло в фильтр и так далее, пока не найдет нужное слово. Это оптимизация, быстрая работа
нашего запроса к БД. Оптимизированный поиск примерно в 10 раз быстрее, вместо 0,01сек найдет за 0,001сек. Для одного
пользователя это не заметная разница, а если 100 человек одновременно запросят эту же страницу? А если больше человек?
После этого сайт может упасть. Поэтому чтобы сайт не падал нужно использовать индексы.


29.3.2 Создание индексов (01:52:00)
Для создания индексов нужно в таблице БД перейти в вкладку "Структура". Там внизу видем индекс с именем 'PRIMARY' по 'id'.
Если мы хотим добавить сюда индексы нужно нажать "Создать индекс" для 1 или нескольких столбцов. Откроется новое
диалоговое окно с полями: "Имя индекса", "Выбор индекса", "столбец", "размер".
Так же индекс можно выставить во время создания таблицы в графе "Индекс", для этого там доступны 4 вкладки:
1) PRIMARY - один и он одновременно UNIQUE + INDEX
2) UNIQUE - говорит о том, что у нас в БД не может быть двух+ одинаковых значений. При попытке записать подобное слово
будет выскакивать ошибка, что нельзя записать дубликаты (используется очень редко)
3) INDEX - то же самое, только дубликаты можно писать.
4) FULLTEXT - используется, чтобы очень длинных текстах искать определенные слова (используется если в каком-то рассказе
нужно найти определенное слово). Выбираем, когда ищем слово внутри текста.

29.3.3 Имя индекса
Для создания индекса есть правило создания имен:
'ixLogin' - первая часть 'ix' говорит, что это индлекс, а вторая 'Login' - для какого поля таблицы.
Для логина выбираем обязательно индекс UNIQUE, чтобы логины не повторялись. При попытке создания логина, который
есть в БД выдаст ошибку.
В остальных случаях используется обычный индекс для закладок.

29.3.4 Делаем закладки для индексов (01:58:50)
Итак мы анализируем весь наш сайт. На нашем сайте ищем все операции с WHERE, по каким полям мы делаем выборку,
сюда относятся и ORDER BY и GROUP BY, но в основном это для WHERE. Чтобы наш скрип быстро работал мы должны для
каждого WHERE отдельно создать условие и отдельный индекс.
1) WHERE `login` = 'inpost'; //отдельный индекс
2) WHERE `login` = 'inpost' AND `password` = 'LALALALA'; //отдельный индекс
3) WHERE `age` BETWEEN 18 and 25 //отдельный индекс

Для этого переходим в вкладку "Структура", внизу ищем поле "Создать индекс для" (количество столбцов):
"Создать индекс для 2-х столбцов";
Имя индекса: 'ixLoginPass';
Выбор индекса: 'INDEX';
Столбец: 'login(varchar(50))'; //составной индекс
Столбец: 'password(varchar(50))'; //составной индекс
Создаем для каждого запроса отдельный индекс.

"Создать индекс для 1 столбцов";
Имя индекса: 'ixAge';
Выбор индекса: 'INDEX';
Столбец: 'age(tinyint(4))';

29.4 Домашнее задание (02:08:00)
1. Оптимизировать таблицы, использовать индексы, enum поля (TINYINT лучше ENUM).
2. В админке сделать вкладку "пользователи" - сделать в ней функционал по управлению пользователями:
    - fullpage сделать
    - в ней поля: логин, доступ(радиобаттон), группа прав, почта, дополнительно: создан, последняя активность, ip
    - кнопки: отредактировать, удалить
3. Поиск пользователей сделать. Разобраться в запросе: WHERE `login` LIKE '%inp%' (POST => $_POST['search'] = 'inp').
4. Разобраться в следующем:
WHERE `login` LIKE '%inp%'
WHERE `login` LIKE 'inp%'
WHERE `login` LIKE '%inp'
5. MySQL: Разобраться в: DATE_FORMAT, COUNT(*) as `cnt`, MAX(`access`), MIN(`access`), SUM(`access`)
https://code.mu/ru/sql/manual/

Вопросы по 29 уроку:
1) Уточнить по доступу - на видео 29 урок (02:15:50) говорится, что сделать по другому распределение доступа:
0-забанен
1-незабанен
5-админка
//5 - первоначально считался админом. Просто ты захотел сделать на 2. Мне без разницы, оставь как тебе хочется
//на высоком уровне программирования всё же вместо цифр 1,2.5,0 - используют ENUM.


2) Можно ли менять тип таблицы и тип данных уже созданной таблицы? Это не навредит данным?
Станислав, 12:54
Придется очистить данные, и только потом поменять.
На реальном сайте сначала:
1. Создаётся новое поле
2. Обновляются записи и переносится функционал на НОВОЕ поле
3. Тестируется
4. Удаляется старое поле


Урок 30: Загрузка файлов (2022-06-29)
/*План:
Загрузка файлов*/

30.1.1 Вступление
Сегодняшняя тема - создание галереи на php. Эта тема на половину бесполезная, потому что написание подобными
алгоритмами получается код слишком большой и в связи с этим каждый раз писать подобные скрипты никто не заморачивается,
все пользуются готовыми библиотеками.
Мы ознакомимся с основами как это все работает, для того чтобы в дальнейшем взять какую-то готовую библиотеку и нею
удобно пользоваться. Загрузка файлов подразумевает не только просто какой-то файл, который с одного компьютера
перезалит на другой. В первую очередь это проверка типов, чтобы совпадали. Если мы заливаем в галерею, то нам не нужно,
чтобы в папке находилсь php, вордовские документы и т.п. Сюда можно еще отнести проверку на безопасность, не только на
сами типы, но еще на соответствие размерам.

30.1.2 Создаем папку для загрузки файлов (00:04:00)
В корне создаем папку: uploaded или images если работаем только с картинками

30.1.3 Права доступа к файлам (00:04:45)
Права различаются на три группы:
	- чтение,
	- изменение,
	- удалене;

В Windows с правами доступа проблем нет, если мы пользуемся IDE с правами администратора. Для UNIX систем есть
разграничения - у админа могут быть права на доступ к папке, а у приложения нет доступа, все зависит как будет
установлена программа. Из-за этого возникает путаница прав.
Для нормальной работы нам обязательно нужно выставить права на чтение и изменение к папкам и файлам.
Если не знаете какие права нужны, то можно сначала включить все права, затем тестить и по немногу права убираем.
Чем больше прав мы даем на папку - тем больше вероятность хакерских атак.

30.2 HTML форма для загрузки файлов: (00:12:20)
Загрузка файлов не работает методом get, поэтому выбираем только post0 В форме выбираем enctype="multipart/form-data"
для того, чтобы мы могли загрузить наши картинки.
<form action="" method="post" enctype="multipart/form-data">
	<input type="file" name="file" accept="image/*">
	<input type="submit" name="submit" value="Загрузить файл">
</form>

30.3.1 PHP загрузка файлов/изображений: (00:15:00)
Для ознакомления: https://www.php.net/manual/ru/features.file-upload.post-method.php

файлы загружаются не в post, a в $_FILES
if(isset($_POST['submit'])) {
	//wtf($_FILES, 1); // проверка содержимого массива
}
Получим массив если нажать "загрузить файл" и не присоединить:
Array
(
    [file] => Array
        (
            [name] => 
            [full_path] => 
            [type] => 
            [tmp_name] => 
            [error] => 4 //4 говорит, что файл небыл загружен.
            [size] => 0
        )

)

 Если присоединить файл, то уже в таком виде:
 Array
(
    [file] => Array
        (
            [name] => azot-1.jpg
            [full_path] => azot-1.jpg //откуда скопирован
            [type] => image/jpeg
            [tmp_name] => C:\xampp\tmp\php1CCF.tmp //временная папка
            [error] => 0 //0 - нет ошибок - дальше будем делать проверку if($_FILES['file']['error']!=0)
            [size] => 229357 // размер в байтах (1кБайт=1024байта)- будем делать тоже проверку чтобы не грузили
            // большие или маленькие файлы
        )

)

Но после этого файл попадает во временную папку и если нам нужен этот файл, то мы должны после этого его скопировать
в нашу папку, куда нам необходимо. Через время временная папка очищается.
Хакер может использовать тип файла [type] => image/jpeg выдав себя за изображение и загрузить php файл с каким-нибудь
вредоносным скриптом, поэтому доверять этому типу нельзя! Мы будем проверять по другому.

Для того чтобы проанализировать, что из себя представляет файл используется функция:
$temp = getimagesize($_FILES['file']['tmp_name']);
wtf($temp,1);//посмотрим что в нем:
Array
(
    [0] => 600 //размеры по ширине
    [1] => 450 //размеры по высоте
    [2] => 2
    [3] => width="600" height="450" //код для подстановки в картинку <img width="600" height="450" src="azot-1.jpg">
    [bits] => 8
    [channels] => 3
    [mime] => image/jpeg //тип файла - если здесь совпадает с предыдущей проверкой $_FILES['file']['type'], то все хорошо
)

Для контроля ошибок используем функцию:
if($_FILES['file']['error']!=0) {...
Коды ошибок (9 штук): https://www.php.net/manual/ru/features.file-upload.errors.php

Для проверки допустимых типов изображаений создаем массив: 
$array = array ('image/gif', 'image/jpeg', 'image/png');
Его мы будем сравнивать с $temp[mime]:
(!in_array($temp['mime'], $array)) {
	
Делаем проверку допустимого размера файла: 
if($_FILES['file']['size']<5000 || $_FILES['file']['size']>50000000) {	

Для копирования файлов используется функция:
move_uploaded_file(); //возвращает true/false
для этой функции нужно указать имя файла, причем имя должно быть обязательно латинскими буквами, без спецсимволов
и быть уникальным, то есть чтобы случайно два человека в одну и туже секунду не попытались загрузить файл с одинаковым
названием, поэтому мы название будем переименовывать, чтобы максимально отпали совпадения. Для этого в название файла
заложим: папку куда будем загружать + функцию времени + тип + случайное число + расширение .jpg :
$name = './uploaded/'.date('Ymd-His').'img'.rand(10000,99999).'.jpg'; // можно еще и + $_SESSION['user']['id']

Для проверки окончания файла можно сделать регулярное выражение:
preg_match('#\.(jpg|jpeg|gif|png)$#iu'), $_FILES['file']['name'], $matches);
Затем переделываем регулярку, на проверку окончания:
preg_match('#\.([a-z]+)$#iu'), $_FILES['file']['name'], $matches);
//wtf(matches, 1); //выдаст массив [0]=> .jpg  [1] =>jpg // далее используем $matches[1]
Далее проверяем c массивом $array2:
$array2 = array('jpg', 'jpeg', 'gif', 'png');
if(!in_array($matches[1]), $array2){...}

При загрузке изображения расширение может быть написано как большими так и маленькими буквами, поэтому мы сразу
через функцию делаем названия расширений маленькими буквами:
$matches[1] = mb_strtolower($matches[1]);	


30.3.2 Итоговый код загрузки файлов: (00:46:55)
$array = array ('image/gif', 'image/jpeg', 'image/png');
$array2 = array('jpg', 'jpeg', 'gif', 'png');

if (isset($_POST['submit'])) {
    if ($_FILES['file']['error'] == 0) {

        if ($_FILES['file']['size'] < 5000 || $_FILES['file']['size'] > 50000000) {
            echo 'Размер изображения нам не подходит';
        } else {
            preg_match('#\.([a-z]+)$#iu', $_FILES['file']['name'], $matches);
            if (isset($matches[1])) {
                $matches[1] = mb_strtolower($matches[1]);
                $temp = getimagesize($_FILES['file']['tmp_name']);
                //wtf($temp)//выводит массив с данными по размеру и [mime]- какой формат содержит изображение
                $name = '/uploaded/' . date('Ymd-His') . 'img' . rand(10000, 99999) . '.jpg';

                if (!in_array($matches[1], $array2)) {
                    echo 'Не подходит расширение изображения';
                } elseif (!in_array($temp['mime'], $array)) {
                    echo 'Не подходит тип файла, можно загружать только изображения';
                } elseif (!move_uploaded_file($_FILES['file']['tmp_name'], '.'.$name)) {
                    echo 'Изображение еще не загружено! Ошибка';
                } else {
                    echo 'Изображение загружено верно';
                    //Изображение добавили, что-нибудь сделаем-еще!
                    //$name;
                }
            } else {
                echo 'Данный файл не являетися картинкой. Принимаемые типы файлов: jpg, png, gif';
            }
        }
    }
}

30.4 Вносим измненения в .htaccess (00:52:10):
//Это не обязательно, но все-таки рекомендуется
php_value memory_limit 128M
php_value upload_max_filesize 50M
php_value post_max_filesize 50M
php_value max_input_time 3000

По умолчанию стоит максимальный загружаемый размер файла 2Мб, мы меняем на 50 если нужны высокого разрешения фотографии.
php_value max_input_time - время выполнения загрузки изображения/файлов, после чего обрывается соединение.

30.5 Изображения в БД: (01:03:40)
Для хранения изображений в БД в разделе новости создадим новое поле 'img' / VARCHAR / 255 / по умолчанию: нет / 
В ее содержание помещаем имя изображения, которое мы создали выше, имя находится в переменной $name.
Так у нас для данной новости или товара будет свое собственное изображение.
Информацию о картинках нужно хранить отдельно в другой таблице.

После того как мы добавил в БД изображение мы можем использовать его в тексте новости. Для этого в поле 'text'
добавляем html:  <img src="/uploaded/1020121-121-1321.jpg">

Так же можно загружать аватар нашего пользователя.

30.6 Домашняя работа:
30.6.1 Изменение размера изображения (00:59:40):
Для этого нужно будет самому доделать наш скрипт  - домашка, а самостоятельно разобраться с функциями:
resize изображения
MAX_WIDTH = 600;
MAX_HEIGHT = 400;

imagecreatefromjpeg
imagecreatefrompng
imagecreatefromgif imagecreatetruecolor($newwidth,$newheight);
imagecopyresampled($tmp,$src,0,0,0,0,$newwidth,$newheight,$width,$height);
imagejpeg($tmp,$filename,100);
imagedestroy($tmp);

30.6.2 Дополнительно (01:11:00):
1. Для товаров добавить изображение.
2. Изучить ресайз изображения.
3. Сделать страницу для редактирования профиля пользователя (не в админке!). Сделать с главной доступно по ссылке:
или по названию пользователя или добавить название "профиль", сделать его кликабельным и по нему переходить уже
к профилю пользователя.
Вывести:
	- аватарка
	- логин
	- почта
	- дата регистрации
	- возраст
	- о себе
	- редактировать профиль (загрузить аватарку, сменить логин, пароль, возраст, о себе,)
4. Сделать загрузку аватара пользователя с максимальным размером 100х100 пикселей (значит, что если пользователь
загружает изображение размером больше - уменьшить так, чтобы общий размер не превышал 100px по ширине И 100px по высоте.
Уменьшать необходимо пропорционально!
Для определения размера нужно использовать функцию getimagesize, нам не подходит если либо w>100 либо h>100
Если к примеру аватара пользователя w=150px (ширина), h=100px (высота), то нужно использовать стандартные
математические пропорции:
w1=150, h1 =100 
Нам нужно получить одну из сторон не больше 100px: 
w2=100, h2 = ? 
Решаем:
h2 = h1 *  w2 / w1 = 100*100/150 = 66.66(получили высоту h2 после резайза)
w2=100px, h2 = 67px;  

Так же стоит задать минимум для пропорций, так как 100px и 1px не будет видно изображение, слишком узкое.

Функция для использования: 
$temp = imagecreatefromjpeg ($_FILES['file']['tmp_name']);

30.6.3 Дополнение к уроку:
У тега input type=file есть атрибут accept. Укажите через него загрузку только картинок с расширением png, gif, jpg,
jpeg . Если используете PHP 7.2+ , то можно и bmp добавить расширение, правда его используем только как
imagecreatefrombmp, а дальше всё равно перекодируем в imagejpeg

30.7 Вопросы по 30-му уроку:
1) Если мы вставляем ссылку на изображение с помощью html, то зачем добавлять изображение в БД?


Урок 31: Работа над статикой и ядром (2022-07-18)
/*План:
Статичные страницы
Пару слов о Котерове
Анализ phpinfo
Работаем над движком*/

31.1.1 Статичные страницы (00:08:25 31b)
Статичные страницы - это страницы с минимумом php кода, на подобие about и прочее.
В модуле создаем папку SP (static pages) в него будем помещать пустые модули такие как main.php и заполнять эту
информацию, в скинах так же дублировать и там уже вводить html код. Частично это бы решило нашу проблему - в html коде
мы бы прописывали собственно html код в html файле, но с ним могут возникнуть трудности с редактированием. Как минимум
нам нужно через нашу админку читать и изменять эти данные. Гораздо проще работать с этим на начальных парах если подобное
мы будем хранить в БД, то есть этот обычный html код, который будет выводиться на статичных страницах это может быть
простой текстст, а может быть в перемешку с html тегами.

Как это реализуется:
Пользователь вводит страницу для доступа к нам на сайт, в доступе указывает, что хочет получить страницу "А", мы нашу
страницу проверяем из MySQL базы и если такая страница существует, то назад вернется готовый html код
клиенту/пользователю.

31.1.2 Доработка variables.php под статичные странички (00:15:25 31b)
Для того, чтобы будущие админы нашего сайта не сломали нам сайт при добавлении новых страниц редактируя массив
$allowed = array('static', 'auth', 'comments', 'contacts', 'errors', 'game', 'goods', 'news','partners', 'services',
'voting', 'users', 'uploaded');
так как нерадивый админ при добавлении нового исключения может не поставить запятую и вся главная страница
упадет.
Для избегания этого мы разместим этот массив в БД и дадим админу небольшой инструмент для работы с вот этим массивом,
то есть у нас будет в нашей админке какая-нибудь страничка по управлению "статикой", то админ не сможет выходить
за рамки определенной возможности, он сможет редактировать только внутренние части, весь синтаксис ему не нужно будет
знать, у него будет простое поле в котором будет написано "Введите имя" и это имя автоматически будет добавляться в БД,
в котром будет формироваться массив исключений страниц.
Клиенты ни при каких обстоятельствах не должны редактировать наш код, только функционал через админку!!!


31.1.3 Реализация статичных страниц в БД (00:24:00 31b)
Имя таблицы: pages
Имя: id /*в этом случае это поле не обязательно, но рекомендуемо*/ | Тип: INT | Индекс: PRIMARY / AI (галочка)
Имя: module  | Тип: VARCHAR | 255 |
Имя: static /*является ли эта страница статичной*/ | Тип: TINYINT | 1 | По умолчанию / 1
Имя: meta_description | Тип: TEXT
Имя: meta_keywords | Тип: TEXT
Имя: meta_title  | Тип: TEXT
Имя: text  | Тип: TEXT

Метаданные мы будем использовать дефолтные, которые у нас есть в конфиге. Эти данные будут переоформляться для
конкретных модулей либо статичных страниц и браться из мета значений БД и уже после для определенных модулей мы
будем брать метаданные из уже вложенных в таблицах, то есть если это товары, то будем брать из таблицы с товарами.
Будет три ступени метаданных: 1) дефолтные, 2) для методов, 3) для конкретной сущности, например товара.

В созданную таблицу занесем наши параметры(вкладка "Вставить"):
На примере страницы "404":
id -пусто
module - 404
static - 1
meta_... - Данная страницы отсутствует! (на все три метаданные вкладки)
text - Данная страницы отсутствует!
Жмем "Вперед"/"Ок"

Так же переносим все страницы из списка массива $allowed:
id - не заполняем
module - static
static - 0
остальные поля не трогаем

И так с каждой страницей из массива.

В итоге мы получили набор страничек, Теперь давайте запрограммируем так, чтобы они работали так как нам надо.
В случае статичной страницы у нас открывалась статичная информация, а в случае если это не статичная страница (нолик),
то у нас будет открываться по нашей стандартной схеме через контроллеры и вид.

31.1.4 Вернемся снова в variables.php - доделаем под статичные странички (00:42:05 31b)
Вот эту часть преобразуем в другой вид.
Старый код:
if(Core::$SKIN != 'admin') {
$allowed = array('static', 'auth', 'comments', 'contacts', 'errors', 'game', 'goods', 'news','partners', 'services', 'voting', 'users', 'uploaded');

if(!isset($_GET['module'])) {
        $_GET['module'] = 'static';
    } elseif(!in_array($_GET['module'],$allowed) && Core::$SKIN != 'admin') {
        //exit();
        header("Location: /errors/404");
        exit();
    }
}
 Новый код:
if(!isset($_GET['module'])) {
    $_GET['module'] = 'static';
} else {//формируем массив:
    $res = q("
            SELECT *
            FROM `pages`
            WHERE `module` = '".mres($_GET['module'])."'
            LIMIT 1
        ");
    if (!mysqli_num_rows($res)) {//!$res->num_rows
        header("Location: /errors/404");
        exit();
    } else { //проверка на статичность страницы:
        $staticpage=mysqli_fetch_assoc($res);//$row=$res->fetch_assoc();
            if ($staticpage['static']==1) {//проверка
                $_GET['module'] = 'staticpage';
                $_GET['page'] = 'main';
        }
    }
}

31.1.5 Создаем модуль: '/modules/staticpage/main.php' (00:52:30 31b)
И точно такой же скин: '/skins/default/staticpage/main.tpl'
В main.tpl пишем:
echo $staticpage['text'];

31.1.6 Отладка ошибок кода (00:57:00 31b) до (01:02:30 31b)

31.2 Кто такой Котеров и отношение Стаса к нему (01:09:05 31b)
"Те кто не читал Котерова - те не програмисты PHP"@Стас
После прохождения курса можно уже легко читать и понимать его курс.

31.3 phpinfo() (01:10:20 31b)
После заливки сайта на хост нам нужно знать все ли в порядке у нас на сайте. Для этого используем phpinfo().
1)Одно из важных- указано где находится php.ini, в котором можно донастроить наш сайт
Можно посмотреть конфигурацию Apache.
2)Серверный администратор - его почта.
3)Тайм аут скрипта - когда истекает время на загрузку скрипта и если после его завершения страничка все-таки не
загрузилась, то она прерывается.
4)HTTP Headers (заголовки): request - то что мы отправили, response - то что получили
Нужно помнить, что сначала отправляются заголовки, затем только информация.
Нужно в заголовках проверять какую кодировку нам возвращает сервер.
5) Core (ядро) - настройки php.ini - тут мы смотрим что у нас включено на сервере, а что нет:
allow_url_fopen - разрешение на подключение внешних ссылок и получение информации с внешней ссылки, можем с другого
сайта качать какую-то информацию, если отключено, то м ыне сможем парсить внешние сайты;
default_charset - кодировка по умолчанию (у нас она прописана в .htaccess);
display_errors - функция отображения ошибок (у нас она прописана в .htaccess);
error_reporting - уровень вывода ошибок (мы используем абсолютный уровень, у нас это настроено в index.php в \
строчке: error_reporting(-1));
log_errors - логирование ошибок (должно быть включено);
magic_quotes_... - магические кавычки (должно быть выключено, у нас через настрояки .htaccess отключено php_flag_...);
max_file_uploads - максимальное количество файлокза один раз;
post_max_size - максимальный размер файла (Мб), тут не только в файла размер, но и текста;
memory_limit - количество памяти выделяемое для выполнения одного скрипта(128Мб - это стандарт для работы с картинками,
если с картинками не работаем, то можно значительно меньше);
upload_max_filesize - максимальный размер файла заливаемого на сервер, тест не учитывается;
6) date - всегда включено, тут прописана стандартная таймзона, если она не настроена, то при обращени к функции date()
будет выбрасывать ошибку;
7) GD - для картинок;
8) настроки баз данных;
9) session - Настройка сессий;
10) Environment - переменное окружение;
11) PHP variables - данные сервера (расположение, адресс, порт и прочее);
12) остальное пока не нужно.

Нужно помнить, что можно настроить php.ini и тогда не нужно это вносить в .htaccess и в index.php,
но так как нам не всегда дается доступ к php.ini, поэтому эти настроки мы прописывали в скриптах.

31.4 Неверный адресс для pages (00:02:47 31c)
Проблему неверного адреса для modules мы решили ранее в этом уроке, теперь нужно решить проблему неверных
страниц.

31.4.1 variables.php
Чтобы защитить себя мы можем перчислить допустимые символы для адресной строки, для того чтобы люди не могли вводить
какие-нибудь точки, спецсимволы, пробелы и тому-подобное, чтобы пользователь не мог через адресную строку пытаться
нас как-то поломать мы сделаем лишь перечень допустимых символов:
if(!preg_match('#^[-a-z_\d]*$#iu', $_GET['page'])) {
    header("Location: /errors/404");
    exit();
}
31.4.2 index.php (00:07:50 31c)
//В роутер после:
ob_start();
include './'.Core::$CONT.'/allpages.php';
//добавим:
if(!file_exists('./'.Core::$CONT.'/'.$_GET['module'].'/'.$_GET['page'].'.php')
|| !file_exists('./skins/'.Core::$SKIN.'/'.$_GET['module'].'/'.$_GET['page'].'.tpl')){
    header("Location: /errors/404");
    exit();
}


Урок 32: mysql связи один ко многим и многие ко многим (2022-07-22)
/*План:
Создаём класс для работы с MySQL
Связь один ко многим
Связь многие ко многим*/

32.1.1 Стили PHP (00:05:46)
До этого мы работали с процедурным стилем PHP, но так как ООП набирает все больше оборотов, то PHP
все больше переходит на ООП.
Например на С++ или JAVA ООП является обязательным.

32.1.2 Создаём класс для работы с MySQL (00:20:20)
У нас есть функция q(), которая хорошо нас служила, но у нее есть недостаток - мы не можем менять $link, что может
понадобиться при работе с несколькими БД. Поэтому мы создадим один универсальный класс.
class DB
{
    static public $mysqli = array();
    static public $connect = array();

    public function _($key=0){
        if (!isset(self::$mysqli['key'])) {
            if (!isset(self::$connect['server']))
            self::$connect['server'])= Core::$DB_HOST;
            if (!isset(self::$connect['server']))
            self::$connect['user'])= Core::$DB_LOGIN;
            if (!isset(self::$connect['server']))
            self::$connect['pass'])= Core::$DB_PASS;
            if (!isset(self::$connect['server']))
            self::$connect['db'])= Core::$DB_NAME;

            self::$mysqli[$key] = @new mysqli(self::$connect['server'], self::$connect['user'], self::$connect['pass'],
            self::$connect['db']);
        if (mysqli_connect_errno()) {
            echo 'Не удалось подключиться к Базе Данных';
            exit();
        }
        if (!self::$mysqli['key']->set_charset("utf8")) {
            echo 'Ошибка при загрузке набора символов utf8: '.self::$mysqli[$key]->error;
            exit();
            }
        }
    return self::$mysqli[$key];
    }
    static public function close($key=0) {
        self::$mysqli[$key]->close();
        unset(self::$mysqli[$key]);
}
}


31.1.3 Использование класса DB: (00:45:15)
//Соединение с БД:
DB::_(0); //ключ можно указывать, а можно и не указывать
//Теперь у нас создалась $mysqli, с которой мы будем работать, создаем запрос:
DB::$mysqli(0)->query();//ключ тут нужно указывать
//Можно работать несколько иначе, соединив две предыдущие строчки в одну:
DB::_($key)->query("запрос");
//Закрываем соединение:
DB::close();
....
....
ОБРАБАТЫВАЕМ ФОТОГРАФИИ
//Для работы с графикой нам необходимо закрывать соединение, потому что графика обрабатывается очень долго.
....
//снова обратимся к mysqli при следующем запросе к БД:
q(); //откроется новое соединение

31.1.4 Изменим функцию q() из default.php (00:56:00):
Был такой код:
function q($query)
{
    global $link;
    $result = mysqli_query($link, $query);
    if ($result === false) {
        $info = debug_backtrace();
        $date = date("Y-m-d H:i:s");
        //wtf($info);//распечатка ошибки на экран
        $log = $date . "  QUERY: " . $query . '<br>'
            . mysqli_error($link) . '<br>'
            . 'FILE: ' . $info[0]['file'] .
            ' LINE: ' . $info[0]['line'];//дебаг(перехват ошибки)
        echo $log;
        //отправляем на почту письмо об ошибке (учить будем это в последующих уроках)
        //записываем ошибку в логи:
        file_put_contents('./logs/mysql.log', strip_tags($log) . "\n\n", FILE_APPEND);
        exit(); //остановим код
    } else {
    return $result; // запрос составлен верно, то вернем на страницу $result
    }
} // пример применения: $result = q("SELECT * FROM `users` ORDER BY `id`");

//Измененный код:
function q($query,$key = 0) {
    $res = DB::_($key)->query($query);
    if($res === false) {
        $info = debug_backtrace();
        $error = "QUERY: ".$query."<br>\n".DB::_($key)->error."<br>\n".
            "file: ".$info[0]['file']."<br>\n".
            "line: ".$info[0]['line']."<br>\n".
            "date: ".date("Y-m-d H:i:s")."<br>\n".
            "===================================";

        file_put_contents('./logs/mysql.log',strip_tags($error)."\n\n",FILE_APPEND);
        echo $error;
        exit();
    }
    return $res;
}

31.1.5 Изменим функцию mres(): (00:57:20):
//Была в таком виде:
function mres($elem)
{
    global $link;
    if (!is_array($elem)) {
        $elem = mysqli_real_escape_string($link, $elem);
    } else {
        $elem = array_map('mres', $elem);
    }
    return $elem;
}

//Теперь в таком:
function mres($el,$key = 0) {
    return DB::_($key)->real_escape_string($el);
}

31.1.6 ALIAS: (00:58:00):
q(); Запрос
mres(); mysqli_real_escape_string

РАБОТА С ОБЪЕКТОМ ВЫБОРКИ
$res = q(); // Запрос с возвратом результата
$res->num_rows; // Количество возвращенных строк - mysqli_num_rows();
$res->fetch_assoc(); // достаём запись - mysqli_fetch_assoc();
$res->close(); // Очищаем результат выборки из БД

РАБОТА С ПОДКЛЮЧЕННОЙ MYSQL
DB::_()->affected_rows; // Количество изменённых записей
DB::_()->insert_id; // Последний ID вставки
DB::_()->real_escape_string(); // аналог mres();
DB::_()->query(); // аналог q
DB::_()->multi_ query(); // Множественные запросы

DB::close(); // Закрываем соединение с БД.

31.1.7 Пример запроса: (01:00:00)
$res = q("SELECT NOW()"); //выборка
while($row=$res->fetch_assoc()) {//$res - объект
    wtf($row, 1); //вывод данных на экран
}
$res->close(); //очистка памяти
exit();

//новый запрос:
$res = q();// прошлый объект нам уже не нужем - мы создаем новый.
...

31.1.8 Работа с несколькими соединениями (01:11:00)
//пример работы с несколькими соединениями:
$res = q ("SELECT NOW()"); //нулевой ключ
$res = q ("SELECT NOW()", 'level1');
$res = q ("SELECT NOW()", 'level1');//если мы ссылаемся на тот же ключ, то мы работаем с предыдущеим соединением
$res = q ("SELECT NOW()", 'level2');
exit();

31.1.9 Изменение соединения (01:11:35)
Меняем параметры свойства класса $connect
DB::$connect['user'] = '111';
...

32.2 Связь один ко многим (01:12:30)
32.2.1 Таблица товаров:
'id' - INT - PRIMARY - AI
'name' - VARCHAR - 255 //название
'text' - TEXT //описание
'cost' - REAL или FLOAT //цена
тип таблицы: InnoDB
сравнение: utf_unicode_ci

32.2.2 Разбивка товаров по разделам/категориям в БД: (01:13:35)
Есть несколько вариантов, первый самый грубый - в таблицу добавляем поле 'cat' ('категория'), тогда каждому товару
дописываем в это новое поле таблицы категорию. Мы мносим так каждый товар в виде текста, но можно сделать в виде
массива, который содержит эти категории:
$array = array('ASUS', 'APPLE', 'SONY');
Теперь работая с нашим скриптом у нас есть массив, который указывает нам какие-то подданные.
Встает вопрос - как добавить новую фирму производителя, новую категорию? Звонить программисту? Нет.
Пользователь должен сам это все делать через админку. Для этого нужно этот массив перенести в БД и там хранить,
а редактировать и удалять БД будет очень просто пользователю.
Для этого создаем новую таблицу `goods_cat`:
'id' - INT - PRIMARY
'name' - VARCHAR - 255 //название
Можно добавить если нужно поле название по русски и еще что-то.

32.2.3 Алгоритм работы с категориями (01:20:00)
$res = q("
    SELECT *
    FROM `goods_cat`
    ORDER BY `id`
    ");
echo '<select name="cat">'; //форма для выбора
while ($row=$res->fetch_assoc()) {
    echo '<option value="'.$row['cat'].'">'.$row['cat'].'</option>';
}
echo '</select>'
$res->close();
В `goods` не нужно вручную теперь вносить категории

32.2.4 Один ко многим (01:22:20)
Как мы можем указывать категории? Мы можем непосредственно работать связью "один ко многим" - эта связь относится к
тому, что у нас есть товар и ему может принадлежать только одна категория. На примере ноутбуков - фирма ASUS одна
(категория), а моделей могут быть тысячи - "один ко многим". В этом случае у нашего товара не может быть несколько
категорий.

32.2.5 Связывание БД (01:24:50)
Мы можем связать по 'id' или по 'name'. Разберем оба варианта
У обеих вариантов есть свои плюсы и минусы и поэтому для разных проектов будет подходить первый или второй вариант.

32.2.5.1 Первый вариант по 'name':
$res = q("
    SELECT *
    FROM `goods`
    ORDER BY `id` = 1
    ");
$row = $res->fetch_assoc();
echo 'Данный ноутбук относится к категории: ' .$row['cat'];
$res-close();
Минус этого варианта - если в наименовании категории была допущена ошибка или еще внести изменения в название категории,
то нам придется делать запрос:
q("
    UPDATE `goods_cat` SET
   `name` = 'ACER'
    WHERE `id` = 1
    ");
Допустим одну заменить это не сложно, а что делать с товарами? Во всех же товарах тоже не верно написано 'ASUS', а
нужно 'ACER' сделать! И вот теперь мы должны делать второй запрос, дополнительный:
q("
    UPDATE `goods` SET
   `name` = 'ACER'
    WHERE `name` = 'ASUS'
    ");
А если не все нужно менять, а только определенную часть или например индекс не стоит по полю `name`, а в БД содержится
миллионы товаров и тут же возникуает огромная паника. С одной стороны вывести вывести очень просто $row['cat'], а вот
с другой стороны чтобы мы могли непосредственно изменить вот такой с 'ACER' на 'ASUS' нам придется всю нашу БД
перекалашматить, всю ее обработать.

32.2.5.2 Второй вариант по 'id'.
Второй вариант - запись в таблицу `goods` не название `name` из `goods_cat`, а 'id' цифровой код. В этом случае не
очень удобно определять по внешнему виду таблицы в какой категории товар, но очень удобно спокойно менять в `goods_cat`
и эти изменения никак не повлияют на таблицу `goods`.
$res = q("
    SELECT `name`
    FROM `goods_cat`
    WHERE `id` = ".$row['cat']."
    ");
$row2 = $res->fetch_assoc();
echo 'Данный ноутбук относится к категории: ' .$row['name'];
$res-close();
Тут еще минус, что приходится делать запрос к отдельной таблице, чтобы определить категорию.

А представьте, что мы работаем не с одним, а выводим сразу все ноутбуки:
$res = q("
    SELECT *
    FROM `goods`
    ");
while($row=$res->fetch_assoc()){
    $res2 = q("
    SELECT `name`
    FROM `goods_cat`
    WHERE `id` = ".$row['cat']."
    ");
$row2 = $res->fetch_assoc();
echo 'Данный ноутбук относится к категории: ' .$row['name'];
}
Чтобы получить какую-то категорию товаров нам приходится делать дополнительный запрос - на 100 товаров 100 запросов,
это нам придется постоянно дергать БД, а если зайдут 200 человек, то 200 запросов в долю секунды. Так мы просто повалим
нашу БД.
В 99% случаев запросы внутри цикла считаются ущербными. Если есть возможность этого избежать, то нужно избегать,
используя первый вариант, сохраняя в таблице `goods` поле `name` из `goods_cat`!
При выборке мы бы облегчили задачу, но при редактировании задачу ухудшили.

32.2.5.3 Есть третий вариант - смежный (01:32:55)
В таблицу `goods` добавляем поле `cat_id`, то есть сюда дублируем две информации и название и id. Номер категории нам
бы мог пригодиться в другом месте, где бы мы использовали идентификатор. Если бы номер категори нам был бы нужен,
если для товара использовались бы дополнительные описания.
Добавим столбцы "text" - TEXT в таблицу `goods_cat`
Пример содержания "HP - ноутбуки нового поколения, используются в ..."
Но если нам полное описание не нужно, то мы можем достаточно удобно вывести через столбец 'cat' нужную категорию.
С другой стороны так мы дублируем материал и нарушаем целостность, уникальность хотя и путем уменьшения количества
запросов.
Поэтому важно выбирать стратегию до начала разработки под конкретный проект. Нужно знать сколько будет запросов,
количество товаров. Если товаров мало, то нет ничего плохого, если мы будем хранить в категории имя категории, а не
идентификатор

32.3 Связь многие ко многим (01:36:45)
32.3.1 Связь многие ко многим - это возможность категории принадлежать ко многим товарам и товару придлежать ко многим
категориям.
Рассмотрим на примере ноутбуков - категории:
1) Производитель
2) Класс
3) Экран размер
4) Экран разрешение
5) Покрытие экрана
6) Процессор
7) Оперативная память
...
Это все "один ко многим", так как один ноутбук не мождет иметь два разных экрана или разные производлители.
А вот например книги могут иметь связь "многие ко многим", так как жанр может пересекаться:
1) жанр: исторический+детектив+биография+для взрослых
2) авторы: может быть написана двумя авторами
3) язык: может быть на двух языках (словарь)

32.3.2 Реализация связи "многие ко многим" в БД
Вот тут уже происходит более сложный механизм. Можно конечно в поле категории вписать двух авторов/товаров через запятую,
а затем искать по части текста с помощью LIKE '%ASUS%', но так мы можем найти: ASUS, ASUSTEK, ZASUS, ... - этот поиск
самый неоптимизированный, который не возможно использовать на крупных проектах. Поэтому нам нужен другой способ найти
эту категорию.
Для этого создаем новую таблицу `goods2goods_cat` (где цифра 2 - это замена слова "to")
'id' - INT - PRIMARY - AI //идентификатор нам в принципе не нужен, но на всякий случай создадим
'good_id' - INT //название
'cat_id' - INT //описание
тип таблицы: InnoDB
сравнение: utf_unicode_ci

Теперь из таблицы товаров `goods` убираем последнюю категорию 'cat', она нам не нужна и теперь мы должны связать товары
с категориями, для этого для каждой новой связи устанавливаем отдельную запись, заполняя поля 'good_id' и 'cat_id'
цифрами идентификаторами, через запятую не пишем, одна связь - одна запись.

32.4 Домашняя работа (01:51:45)
1. Делаем связь "один ко многим" для модуля новости (всего 2 таблицы).
Новости:
а) научные
б) криминальные
в) политические
Сделать в админке, где будет все три действия:
а) добавление
б) редактирование
в) удаление
Сделать публичную, чтобы пользователи заходили в раздел и видели возможность выбора категории, при выборе одной из
категорий у него будут выводиться статьи из этой категории.
По умолчанию должны выводиться все новости.
2. Делаем связь "многие ко многим" для модуля книг (всего 3 таблицы). В книгах есть книги и авторы.
Сделать в админке и отображение публично с возможностью выбора.
3. Для одного из модулей подключаем пагинатор. Спойлер: как делать пагинатор (01:57:45)
4. Самостоятельно читаем про нормальные формы mysql.

32.5 Пагинация
Навигация состоит из двух частей: вывод новостей и вывод навигации. Каждая из этих частей делается отдельно.
Расмотрение поэтапно:
1) Передача номера страниц - в адресной строке (цифра 10 говорит, что мы будем выводить с 10-й позиции и дальше)
LIMIT 10,10 (выводим с 10-й записи еще 10 записей)
Второй вариант - через номера страниц - page 1, page 2, ...
$limit=10; (количество страниц для вывода)
page 1 (с 0 по 9 идентификатор новости), (1*$limit-$limit = LIMIT 0, $limit)
page 2 (с 10 по 19 идентификатор новости), (2*$limit-$limit = LIMIT 10, $limit)
...







